>3	FunctionDef	callFunction (mxArray * plhs [ ] , const mxArray * prhs [ ])
>4	ParameterList	mxArray * plhs [ ] , const mxArray * prhs [ ]
>5	Parameter	 
>6	Identifier	prhs
>7	ParameterType	const mxArray * [ ]
>8	Parameter	 
>9	Identifier	plhs
>10	ParameterType	mxArray * [ ]
>11	ReturnType	inline void
>12	CompoundStatement	 
>13	ExpressionStatement	 
>14	Identifier	spAlpha
>15	Statement	 
>16	Statement	 
>17	Statement	 
>18	ExpressionStatement	 
>19	Identifier	X
>20	Statement	 
>21	Statement	 
>22	Statement	 
>23	ForStatement	for ( long i = 0 ; i < Ng ; ++ i )
>24	CompoundStatement	 
>25	IfStatement	if ( nn != 0 )
>26	CompoundStatement	 
>27	ExpressionStatement	 
>28	AssignmentExpr	offset = Jc [ countcol ]
>29	ArrayIndexing	Jc [ countcol ]
>30	Identifier	countcol
>31	Identifier	Jc
>32	Identifier	offset
>33	ExpressionStatement	 
>34	UnaryExpression	-- countcol
>35	Identifier	countcol
>36	IncDec	--
>37	ForStatement	for ( long j = 0 ; j <= nn ; ++ j )
>38	ExpressionStatement	 
>39	AssignmentExpr	Jc [ countcol ++ ] = static_cast < mwSize > ( offset + pB [ j ] )
>40	RelationalExpression	static_cast < mwSize > ( offset + pB [ j ] )
>41	RelationalExpression	mwSize > ( offset + pB [ j ] )
>42	AdditiveExpression	offset + pB [ j ]
>43	ArrayIndexing	pB [ j ]
>44	Identifier	j
>45	Identifier	pB
>46	Identifier	offset
>47	Identifier	mwSize
>48	Identifier	static_cast
>49	ArrayIndexing	Jc [ countcol ++ ]
>50	IncDecOp	countcol ++
>51	IncDec	++
>52	Identifier	countcol
>53	Identifier	Jc
>54	UnaryExpression	 
>55	Identifier	j
>56	IncDec	++
>57	Condition	 
>58	RelationalExpression	j <= nn
>59	Identifier	nn
>60	Identifier	j
>61	ForInit	 
>62	IdentifierDeclStatement	long j = 0 ;
>63	IdentifierDecl	j = 0
>64	AssignmentExpr	j = 0
>65	PrimaryExpression	0
>66	Identifier	j
>67	Identifier	j
>68	IdentifierDeclType	long
>69	ForStatement	for ( long j = 0 ; j < pB [ nn ] ; ++ j )
>70	CompoundStatement	 
>71	ExpressionStatement	 
>72	AssignmentExpr	Ir [ count ++ ] = static_cast < mwSize > ( r [ j ] )
>73	RelationalExpression	static_cast < mwSize > ( r [ j ] )
>74	RelationalExpression	mwSize > ( r [ j ] )
>75	ArrayIndexing	r [ j ]
>76	Identifier	j
>77	Identifier	r
>78	Identifier	mwSize
>79	Identifier	static_cast
>80	ArrayIndexing	Ir [ count ++ ]
>81	IncDecOp	count ++
>82	IncDec	++
>83	Identifier	count
>84	Identifier	Ir
>85	ExpressionStatement	 
>86	AssignmentExpr	Pr [ count ] = static_cast < double > ( v [ j ] )
>87	RelationalExpression	static_cast < double > ( v [ j ] )
>88	RelationalExpression	double > ( v [ j ] )
>89	ArrayIndexing	v [ j ]
>90	Identifier	j
>91	Identifier	v
>92	Identifier	double
>93	Identifier	static_cast
>94	ArrayIndexing	Pr [ count ]
>95	Identifier	count
>96	Identifier	Pr
>97	UnaryExpression	 
>98	Identifier	j
>99	IncDec	++
>100	Condition	 
>101	RelationalExpression	j < pB [ nn ]
>102	ArrayIndexing	pB [ nn ]
>103	Identifier	nn
>104	Identifier	pB
>105	Identifier	j
>106	ForInit	 
>107	IdentifierDeclStatement	long j = 0 ;
>108	IdentifierDecl	j = 0
>109	AssignmentExpr	j = 0
>110	PrimaryExpression	0
>111	Identifier	j
>112	Identifier	j
>113	IdentifierDeclType	long
>114	Condition	 
>115	EqualityExpression	nn != 0
>116	PrimaryExpression	0
>117	Identifier	nn
>118	ExpressionStatement	 
>119	AssignmentExpr	nzmax = spAlpha [ i ] . nzmax ( )
>120	CallExpression	spAlpha [ i ] . nzmax ( )
>121	ArgumentList	 
>122	Callee	spAlpha [ i ] . nzmax
>123	MemberAccess	spAlpha [ i ] . nzmax
>124	Identifier	nzmax
>125	ArrayIndexing	spAlpha [ i ]
>126	Identifier	i
>127	Identifier	spAlpha
>128	Identifier	nzmax
>129	IdentifierDeclStatement	 
>130	IdentifierDecl	nn = spAlpha [ i ] . n ( )
>131	AssignmentExpr	nn = spAlpha [ i ] . n ( )
>132	CallExpression	spAlpha [ i ] . n ( )
>133	ArgumentList	 
>134	Callee	spAlpha [ i ] . n
>135	MemberAccess	spAlpha [ i ] . n
>136	Identifier	n
>137	ArrayIndexing	spAlpha [ i ]
>138	Identifier	i
>139	Identifier	spAlpha
>140	Identifier	nn
>141	Identifier	nn
>142	IdentifierDeclType	long
>143	IdentifierDeclStatement	 
>144	IdentifierDecl	* pB = spAlpha [ i ] . pB ( )
>145	AssignmentExpr	* pB = spAlpha [ i ] . pB ( )
>146	CallExpression	spAlpha [ i ] . pB ( )
>147	ArgumentList	 
>148	Callee	spAlpha [ i ] . pB
>149	MemberAccess	spAlpha [ i ] . pB
>150	Identifier	pB
>151	ArrayIndexing	spAlpha [ i ]
>152	Identifier	i
>153	Identifier	spAlpha
>154	Identifier	pB
>155	Identifier	pB
>156	IdentifierDeclType	const long *
>157	IdentifierDeclStatement	 
>158	IdentifierDecl	* r = spAlpha [ i ] . r ( )
>159	AssignmentExpr	* r = spAlpha [ i ] . r ( )
>160	CallExpression	spAlpha [ i ] . r ( )
>161	ArgumentList	 
>162	Callee	spAlpha [ i ] . r
>163	MemberAccess	spAlpha [ i ] . r
>164	Identifier	r
>165	ArrayIndexing	spAlpha [ i ]
>166	Identifier	i
>167	Identifier	spAlpha
>168	Identifier	r
>169	Identifier	r
>170	IdentifierDeclType	const long *
>171	IdentifierDeclStatement	 
>172	IdentifierDecl	* v = spAlpha [ i ] . v ( )
>173	AssignmentExpr	* v = spAlpha [ i ] . v ( )
>174	CallExpression	spAlpha [ i ] . v ( )
>175	ArgumentList	 
>176	Callee	spAlpha [ i ] . v
>177	MemberAccess	spAlpha [ i ] . v
>178	Identifier	v
>179	ArrayIndexing	spAlpha [ i ]
>180	Identifier	i
>181	Identifier	spAlpha
>182	Identifier	v
>183	Identifier	v
>184	IdentifierDeclType	const T *
>185	UnaryExpression	 
>186	Identifier	i
>187	IncDec	++
>188	Condition	 
>189	RelationalExpression	i < Ng
>190	Identifier	Ng
>191	Identifier	i
>192	ForInit	 
>193	IdentifierDeclStatement	long i = 0 ;
>194	IdentifierDecl	i = 0
>195	AssignmentExpr	i = 0
>196	PrimaryExpression	0
>197	Identifier	i
>198	Identifier	i
>199	IdentifierDeclType	long
>200	IdentifierDeclStatement	 
>201	IdentifierDecl	offset = 0
>202	AssignmentExpr	offset = 0
>203	PrimaryExpression	0
>204	Identifier	offset
>205	Identifier	offset
>206	IdentifierDeclType	long
>207	IdentifierDeclStatement	 
>208	IdentifierDecl	countcol = 0
>209	AssignmentExpr	countcol = 0
>210	PrimaryExpression	0
>211	Identifier	countcol
>212	Identifier	countcol
>213	IdentifierDeclType	long
>214	IdentifierDeclStatement	 
>215	IdentifierDecl	count = 0
>216	AssignmentExpr	count = 0
>217	PrimaryExpression	0
>218	Identifier	count
>219	Identifier	count
>220	IdentifierDeclType	long
>221	IdentifierDeclStatement	 
>222	IdentifierDecl	* Jc = mxGetJc ( plhs [ 0 ] )
>223	AssignmentExpr	* Jc = mxGetJc ( plhs [ 0 ] )
>224	CallExpression	mxGetJc ( plhs [ 0 ] )
>225	ArgumentList	plhs [ 0 ]
>226	Argument	plhs [ 0 ]
>227	ArrayIndexing	plhs [ 0 ]
>228	PrimaryExpression	0
>229	Identifier	plhs
>230	Callee	mxGetJc
>231	Identifier	mxGetJc
>232	Identifier	Jc
>233	Identifier	Jc
>234	IdentifierDeclType	mwSize *
>235	IdentifierDeclStatement	 
>236	IdentifierDecl	* Ir = mxGetIr ( plhs [ 0 ] )
>237	AssignmentExpr	* Ir = mxGetIr ( plhs [ 0 ] )
>238	CallExpression	mxGetIr ( plhs [ 0 ] )
>239	ArgumentList	plhs [ 0 ]
>240	Argument	plhs [ 0 ]
>241	ArrayIndexing	plhs [ 0 ]
>242	PrimaryExpression	0
>243	Identifier	plhs
>244	Callee	mxGetIr
>245	Identifier	mxGetIr
>246	Identifier	Ir
>247	Identifier	Ir
>248	IdentifierDeclType	mwSize *
>249	IdentifierDeclStatement	 
>250	IdentifierDecl	* Pr = mxGetPr ( plhs [ 0 ] )
>251	AssignmentExpr	* Pr = mxGetPr ( plhs [ 0 ] )
>252	CallExpression	mxGetPr ( plhs [ 0 ] )
>253	ArgumentList	plhs [ 0 ]
>254	Argument	plhs [ 0 ]
>255	ArrayIndexing	plhs [ 0 ]
>256	PrimaryExpression	0
>257	Identifier	plhs
>258	Callee	mxGetPr
>259	Identifier	mxGetPr
>260	Identifier	Pr
>261	Identifier	Pr
>262	IdentifierDeclType	double *
>263	ExpressionStatement	 
>264	AssignmentExpr	plhs [ 0 ] = mxCreateSparse ( K , M , nzmax , mxREAL )
>265	CallExpression	mxCreateSparse ( K , M , nzmax , mxREAL )
>266	ArgumentList	K
>267	Argument	mxREAL
>268	Identifier	mxREAL
>269	Argument	nzmax
>270	Identifier	nzmax
>271	Argument	M
>272	Identifier	M
>273	Argument	K
>274	Identifier	K
>275	Callee	mxCreateSparse
>276	Identifier	mxCreateSparse
>277	ArrayIndexing	plhs [ 0 ]
>278	PrimaryExpression	0
>279	Identifier	plhs
>280	ForStatement	for ( long i = 0 ; i < Ng ; ++ i )
>281	CompoundStatement	 
>282	ExpressionStatement	 
>283	AssignmentExpr	nzmax += spAlpha [ i ] . nzmax ( )
>284	CallExpression	spAlpha [ i ] . nzmax ( )
>285	ArgumentList	 
>286	Callee	spAlpha [ i ] . nzmax
>287	MemberAccess	spAlpha [ i ] . nzmax
>288	Identifier	nzmax
>289	ArrayIndexing	spAlpha [ i ]
>290	Identifier	i
>291	Identifier	spAlpha
>292	Identifier	nzmax
>293	UnaryExpression	 
>294	Identifier	i
>295	IncDec	++
>296	Condition	 
>297	RelationalExpression	i < Ng
>298	Identifier	Ng
>299	Identifier	i
>300	ForInit	 
>301	IdentifierDeclStatement	long i = 0 ;
>302	IdentifierDecl	i = 0
>303	AssignmentExpr	i = 0
>304	PrimaryExpression	0
>305	Identifier	i
>306	Identifier	i
>307	IdentifierDeclType	long
>308	IdentifierDeclStatement	 
>309	IdentifierDecl	nzmax = 0
>310	AssignmentExpr	nzmax = 0
>311	PrimaryExpression	0
>312	Identifier	nzmax
>313	Identifier	nzmax
>314	IdentifierDeclType	long
>315	ExpressionStatement	 
>316	CallExpression	somp ( X , D , spAlpha , Ng , L , eps , numThreads )
>317	ArgumentList	X
>318	Argument	numThreads
>319	Identifier	numThreads
>320	Argument	eps
>321	Identifier	eps
>322	Argument	L
>323	Identifier	L
>324	Argument	Ng
>325	Identifier	Ng
>326	Argument	spAlpha
>327	Identifier	spAlpha
>328	Argument	D
>329	Identifier	D
>330	Argument	X
>331	Identifier	X
>332	Callee	somp
>333	Identifier	somp
>334	IdentifierDeclStatement	 
>335	IdentifierDecl	* spAlpha = new SpMatrix < T > [ Ng ]
>336	AssignmentExpr	* spAlpha = new SpMatrix < T > [ Ng ]
>337	Identifier	Ng
>338	Identifier	Ng
>339	Identifier	spAlpha
>340	IdentifierDeclType	SpMatrix < T > *
>341	ExpressionStatement	 
>342	CallExpression	X [ Ng - 1 ] . setData ( prX + list_groups [ Ng - 1 ] * n , n , M - list_groups [ Ng - 1 ] )
>343	ArgumentList	prX + list_groups [ Ng - 1 ] * n
>344	Argument	M - list_groups [ Ng - 1 ]
>345	AdditiveExpression	M - list_groups [ Ng - 1 ]
>346	ArrayIndexing	list_groups [ Ng - 1 ]
>347	AdditiveExpression	Ng - 1
>348	PrimaryExpression	1
>349	Identifier	Ng
>350	Identifier	list_groups
>351	Identifier	M
>352	Argument	n
>353	Identifier	n
>354	Argument	prX + list_groups [ Ng - 1 ] * n
>355	AdditiveExpression	prX + list_groups [ Ng - 1 ] * n
>356	MultiplicativeExpression	list_groups [ Ng - 1 ] * n
>357	Identifier	n
>358	ArrayIndexing	list_groups [ Ng - 1 ]
>359	AdditiveExpression	Ng - 1
>360	PrimaryExpression	1
>361	Identifier	Ng
>362	Identifier	list_groups
>363	Identifier	prX
>364	Callee	X [ Ng - 1 ] . setData
>365	MemberAccess	X [ Ng - 1 ] . setData
>366	Identifier	setData
>367	ArrayIndexing	X [ Ng - 1 ]
>368	AdditiveExpression	Ng - 1
>369	PrimaryExpression	1
>370	Identifier	Ng
>371	Identifier	X
>372	ForStatement	for ( long i = 0 ; i < Ng - 1 ; ++ i )
>373	CompoundStatement	 
>374	ExpressionStatement	 
>375	CallExpression	X [ i ] . setData ( prX + list_groups [ i ] * n , n , list_groups [ i + 1 ] - list_groups [ i ] )
>376	ArgumentList	prX + list_groups [ i ] * n
>377	Argument	list_groups [ i + 1 ] - list_groups [ i ]
>378	AdditiveExpression	list_groups [ i + 1 ] - list_groups [ i ]
>379	ArrayIndexing	list_groups [ i ]
>380	Identifier	i
>381	Identifier	list_groups
>382	ArrayIndexing	list_groups [ i + 1 ]
>383	AdditiveExpression	i + 1
>384	PrimaryExpression	1
>385	Identifier	i
>386	Identifier	list_groups
>387	Argument	n
>388	Identifier	n
>389	Argument	prX + list_groups [ i ] * n
>390	AdditiveExpression	prX + list_groups [ i ] * n
>391	MultiplicativeExpression	list_groups [ i ] * n
>392	Identifier	n
>393	ArrayIndexing	list_groups [ i ]
>394	Identifier	i
>395	Identifier	list_groups
>396	Identifier	prX
>397	Callee	X [ i ] . setData
>398	MemberAccess	X [ i ] . setData
>399	Identifier	setData
>400	ArrayIndexing	X [ i ]
>401	Identifier	i
>402	Identifier	X
>403	IfStatement	if ( list_groups [ i ] >= list_groups [ i + 1 ] )
>404	ExpressionStatement	 
>405	CallExpression	mexErrMsgTxt ( \"Group indices should be a strictly non-decreasing sequence\" )
>406	ArgumentList	\"Group indices should be a strictly non-decreasing sequence\"
>407	Argument	\"Group indices should be a strictly non-decreasing sequence\"
>408	PrimaryExpression	\"Group indices should be a strictly non-decreasing sequence\"
>409	Callee	mexErrMsgTxt
>410	Identifier	mexErrMsgTxt
>411	Condition	 
>412	RelationalExpression	list_groups [ i ] >= list_groups [ i + 1 ]
>413	ArrayIndexing	list_groups [ i + 1 ]
>414	AdditiveExpression	i + 1
>415	PrimaryExpression	1
>416	Identifier	i
>417	Identifier	list_groups
>418	ArrayIndexing	list_groups [ i ]
>419	Identifier	i
>420	Identifier	list_groups
>421	IfStatement	if ( list_groups [ i ] >= M )
>422	ExpressionStatement	 
>423	CallExpression	mexErrMsgTxt ( \"Size of groups is not consistent\" )
>424	ArgumentList	\"Size of groups is not consistent\"
>425	Argument	\"Size of groups is not consistent\"
>426	PrimaryExpression	\"Size of groups is not consistent\"
>427	Callee	mexErrMsgTxt
>428	Identifier	mexErrMsgTxt
>429	Condition	 
>430	RelationalExpression	list_groups [ i ] >= M
>431	Identifier	M
>432	ArrayIndexing	list_groups [ i ]
>433	Identifier	i
>434	Identifier	list_groups
>435	UnaryExpression	 
>436	Identifier	i
>437	IncDec	++
>438	Condition	 
>439	RelationalExpression	i < Ng - 1
>440	AdditiveExpression	Ng - 1
>441	PrimaryExpression	1
>442	Identifier	Ng
>443	Identifier	i
>444	ForInit	 
>445	IdentifierDeclStatement	long i = 0 ;
>446	IdentifierDecl	i = 0
>447	AssignmentExpr	i = 0
>448	PrimaryExpression	0
>449	Identifier	i
>450	Identifier	i
>451	IdentifierDeclType	long
>452	IfStatement	if ( list_groups [ 0 ] != 0 )
>453	ExpressionStatement	 
>454	CallExpression	mexErrMsgTxt ( \"First group index should be zero\" )
>455	ArgumentList	\"First group index should be zero\"
>456	Argument	\"First group index should be zero\"
>457	PrimaryExpression	\"First group index should be zero\"
>458	Callee	mexErrMsgTxt
>459	Identifier	mexErrMsgTxt
>460	Condition	 
>461	EqualityExpression	list_groups [ 0 ] != 0
>462	PrimaryExpression	0
>463	ArrayIndexing	list_groups [ 0 ]
>464	PrimaryExpression	0
>465	Identifier	list_groups
>466	IdentifierDeclStatement	 
>467	IdentifierDecl	* X = new Matrix < T > [ Ng ]
>468	AssignmentExpr	* X = new Matrix < T > [ Ng ]
>469	Identifier	Ng
>470	Identifier	Ng
>471	Identifier	X
>472	IdentifierDeclType	Matrix < T > *
>473	IdentifierDeclStatement	 
>474	IdentifierDecl	D ( prD , n , K )
>475	Expression	prD , n , K
>476	Expression	n , K
>477	Identifier	K
>478	Identifier	n
>479	Identifier	prD
>480	Identifier	D
>481	IdentifierDeclType	Matrix < T >
>482	ExpressionStatement	 
>483	Expression	prhs [ 3 ] , \"numThreads\" , - 1
>484	Expression	\"numThreads\" , - 1
>485	UnaryOp	- 1
>486	PrimaryExpression	1
>487	UnaryOperator	-
>488	PrimaryExpression	\"numThreads\"
>489	ArrayIndexing	prhs [ 3 ]
>490	PrimaryExpression	3
>491	Identifier	prhs
>492	Statement	 
>493	Statement	 
>494	Statement	 
>495	Statement	 
>496	Statement	 
>497	Statement	 
>498	Statement	 
>499	IdentifierDeclStatement	 
>500	IdentifierDecl	eps = getScalarStructDef < T > ( prhs [ 3 ] , \"eps\" , 0 )
>501	AssignmentExpr	eps = getScalarStructDef < T > ( prhs [ 3 ] , \"eps\" , 0 )
>502	RelationalExpression	getScalarStructDef < T > ( prhs [ 3 ] , \"eps\" , 0 )
>503	RelationalExpression	T > ( prhs [ 3 ] , \"eps\" , 0 )
>504	Expression	prhs [ 3 ] , \"eps\" , 0
>505	Expression	\"eps\" , 0
>506	PrimaryExpression	0
>507	PrimaryExpression	\"eps\"
>508	ArrayIndexing	prhs [ 3 ]
>509	PrimaryExpression	3
>510	Identifier	prhs
>511	Identifier	T
>512	Identifier	getScalarStructDef
>513	Identifier	eps
>514	Identifier	eps
>515	IdentifierDeclType	T
>516	ExpressionStatement	 
>517	Expression	prhs [ 3 ] , \"L\"
>518	PrimaryExpression	\"L\"
>519	ArrayIndexing	prhs [ 3 ]
>520	PrimaryExpression	3
>521	Identifier	prhs
>522	Statement	 
>523	Statement	 
>524	Statement	 
>525	Statement	 
>526	Statement	 
>527	Statement	 
>528	Statement	 
>529	ExpressionStatement	 
>530	CallExpression	mxGetPr ( prhs [ 2 ] )
>531	ArgumentList	prhs [ 2 ]
>532	Argument	prhs [ 2 ]
>533	ArrayIndexing	prhs [ 2 ]
>534	PrimaryExpression	2
>535	Identifier	prhs
>536	Callee	mxGetPr
>537	Identifier	mxGetPr
>538	Statement	 
>539	Statement	 
>540	Statement	 
>541	Statement	 
>542	Statement	 
>543	Statement	 
>544	Statement	 
>545	Statement	 
>546	Statement	 
>547	ExpressionStatement	 
>548	MultiplicativeExpression	dimsList [ 0 ] * dimsList [ 1 ]
>549	ArrayIndexing	dimsList [ 1 ]
>550	PrimaryExpression	1
>551	Identifier	dimsList
>552	ArrayIndexing	dimsList [ 0 ]
>553	PrimaryExpression	0
>554	Identifier	dimsList
>555	Statement	 
>556	Statement	 
>557	Statement	 
>558	Statement	 
>559	Statement	 
>560	Statement	 
>561	Statement	 
>562	IdentifierDeclStatement	 
>563	IdentifierDecl	* dimsList = mxGetDimensions ( prhs [ 2 ] )
>564	AssignmentExpr	* dimsList = mxGetDimensions ( prhs [ 2 ] )
>565	CallExpression	mxGetDimensions ( prhs [ 2 ] )
>566	ArgumentList	prhs [ 2 ]
>567	Argument	prhs [ 2 ]
>568	ArrayIndexing	prhs [ 2 ]
>569	PrimaryExpression	2
>570	Identifier	prhs
>571	Callee	mxGetDimensions
>572	Identifier	mxGetDimensions
>573	Identifier	dimsList
>574	Identifier	dimsList
>575	IdentifierDeclType	const mwSize *
>576	ExpressionStatement	 
>577	ArrayIndexing	dimsD [ 1 ]
>578	PrimaryExpression	1
>579	Identifier	dimsD
>580	Statement	 
>581	Statement	 
>582	Statement	 
>583	Statement	 
>584	Statement	 
>585	Statement	 
>586	Statement	 
>587	IfStatement	if ( nD != n )
>588	ExpressionStatement	 
>589	CallExpression	mexErrMsgTxt ( \"wrong size for argument 2\" )
>590	ArgumentList	\"wrong size for argument 2\"
>591	Argument	\"wrong size for argument 2\"
>592	PrimaryExpression	\"wrong size for argument 2\"
>593	Callee	mexErrMsgTxt
>594	Identifier	mexErrMsgTxt
>595	Condition	 
>596	EqualityExpression	nD != n
>597	Identifier	n
>598	Identifier	nD
>599	ExpressionStatement	 
>600	ArrayIndexing	dimsD [ 0 ]
>601	PrimaryExpression	0
>602	Identifier	dimsD
>603	Statement	 
>604	Statement	 
>605	Statement	 
>606	Statement	 
>607	Statement	 
>608	Statement	 
>609	Statement	 
>610	IdentifierDeclStatement	 
>611	IdentifierDecl	* dimsD = mxGetDimensions ( prhs [ 1 ] )
>612	AssignmentExpr	* dimsD = mxGetDimensions ( prhs [ 1 ] )
>613	CallExpression	mxGetDimensions ( prhs [ 1 ] )
>614	ArgumentList	prhs [ 1 ]
>615	Argument	prhs [ 1 ]
>616	ArrayIndexing	prhs [ 1 ]
>617	PrimaryExpression	1
>618	Identifier	prhs
>619	Callee	mxGetDimensions
>620	Identifier	mxGetDimensions
>621	Identifier	dimsD
>622	Identifier	dimsD
>623	IdentifierDeclType	const mwSize *
>624	ExpressionStatement	 
>625	CallExpression	mxGetPr ( prhs [ 1 ] )
>626	ArgumentList	prhs [ 1 ]
>627	Argument	prhs [ 1 ]
>628	ArrayIndexing	prhs [ 1 ]
>629	PrimaryExpression	1
>630	Identifier	prhs
>631	Callee	mxGetPr
>632	Identifier	mxGetPr
>633	Statement	 
>634	Statement	 
>635	Statement	 
>636	Statement	 
>637	Statement	 
>638	Statement	 
>639	Statement	 
>640	Statement	 
>641	Statement	 
>642	ExpressionStatement	 
>643	ArrayIndexing	dims [ 1 ]
>644	PrimaryExpression	1
>645	Identifier	dims
>646	Statement	 
>647	Statement	 
>648	Statement	 
>649	Statement	 
>650	Statement	 
>651	Statement	 
>652	Statement	 
>653	ExpressionStatement	 
>654	ArrayIndexing	dims [ 0 ]
>655	PrimaryExpression	0
>656	Identifier	dims
>657	Statement	 
>658	Statement	 
>659	Statement	 
>660	Statement	 
>661	Statement	 
>662	Statement	 
>663	Statement	 
>664	IdentifierDeclStatement	 
>665	IdentifierDecl	* dims = mxGetDimensions ( prhs [ 0 ] )
>666	AssignmentExpr	* dims = mxGetDimensions ( prhs [ 0 ] )
>667	CallExpression	mxGetDimensions ( prhs [ 0 ] )
>668	ArgumentList	prhs [ 0 ]
>669	Argument	prhs [ 0 ]
>670	ArrayIndexing	prhs [ 0 ]
>671	PrimaryExpression	0
>672	Identifier	prhs
>673	Callee	mxGetDimensions
>674	Identifier	mxGetDimensions
>675	Identifier	dims
>676	Identifier	dims
>677	IdentifierDeclType	const mwSize *
>678	ExpressionStatement	 
>679	CallExpression	mxGetPr ( prhs [ 0 ] )
>680	ArgumentList	prhs [ 0 ]
>681	Argument	prhs [ 0 ]
>682	ArrayIndexing	prhs [ 0 ]
>683	PrimaryExpression	0
>684	Identifier	prhs
>685	Callee	mxGetPr
>686	Identifier	mxGetPr
>687	Statement	 
>688	Statement	 
>689	Statement	 
>690	Statement	 
>691	Statement	 
>692	Statement	 
>693	Statement	 
>694	Statement	 
>695	Statement	 
>696	IfStatement	if ( ! mxIsStruct ( prhs [ 3 ] ) )
>697	ExpressionStatement	 
>698	CallExpression	mexErrMsgTxt ( \"argument 4 should be struct\" )
>699	ArgumentList	\"argument 4 should be struct\"
>700	Argument	\"argument 4 should be struct\"
>701	PrimaryExpression	\"argument 4 should be struct\"
>702	Callee	mexErrMsgTxt
>703	Identifier	mexErrMsgTxt
>704	Condition	 
>705	UnaryOp	! mxIsStruct ( prhs [ 3 ] )
>706	CallExpression	mxIsStruct ( prhs [ 3 ] )
>707	ArgumentList	prhs [ 3 ]
>708	Argument	prhs [ 3 ]
>709	ArrayIndexing	prhs [ 3 ]
>710	PrimaryExpression	3
>711	Identifier	prhs
>712	Callee	mxIsStruct
>713	Identifier	mxIsStruct
>714	UnaryOperator	!
>715	ExpressionStatement	 
>716	CallExpression	mexErrMsgTxt ( \"type of argument 3 is not consistent\" )
>717	ArgumentList	\"type of argument 3 is not consistent\"
>718	Argument	\"type of argument 3 is not consistent\"
>719	PrimaryExpression	\"type of argument 3 is not consistent\"
>720	Callee	mexErrMsgTxt
>721	Identifier	mexErrMsgTxt
>722	Statement	 
>723	Statement	 
>724	Statement	 
>725	Statement	 
>726	Statement	 
>727	Statement	 
>728	Statement	 
>729	Statement	 
>730	Statement	 
>731	Statement	 
>732	Statement	 
>733	Statement	 
>734	Statement	 
>735	Statement	 
>736	IfStatement	if ( mxIsSparse ( prhs [ 2 ] ) )
>737	ExpressionStatement	 
>738	CallExpression	mexErrMsgTxt ( \"argument 3 should be full\" )
>739	ArgumentList	\"argument 3 should be full\"
>740	Argument	\"argument 3 should be full\"
>741	PrimaryExpression	\"argument 3 should be full\"
>742	Callee	mexErrMsgTxt
>743	Identifier	mexErrMsgTxt
>744	Condition	 
>745	CallExpression	mxIsSparse ( prhs [ 2 ] )
>746	ArgumentList	prhs [ 2 ]
>747	Argument	prhs [ 2 ]
>748	ArrayIndexing	prhs [ 2 ]
>749	PrimaryExpression	2
>750	Identifier	prhs
>751	Callee	mxIsSparse
>752	Identifier	mxIsSparse
>753	IfStatement	if ( mxIsSparse ( prhs [ 1 ] ) )
>754	ExpressionStatement	 
>755	CallExpression	mexErrMsgTxt ( \"argument 2 should be full\" )
>756	ArgumentList	\"argument 2 should be full\"
>757	Argument	\"argument 2 should be full\"
>758	PrimaryExpression	\"argument 2 should be full\"
>759	Callee	mexErrMsgTxt
>760	Identifier	mexErrMsgTxt
>761	Condition	 
>762	CallExpression	mxIsSparse ( prhs [ 1 ] )
>763	ArgumentList	prhs [ 1 ]
>764	Argument	prhs [ 1 ]
>765	ArrayIndexing	prhs [ 1 ]
>766	PrimaryExpression	1
>767	Identifier	prhs
>768	Callee	mxIsSparse
>769	Identifier	mxIsSparse
>770	IfStatement	if ( ! mexCheckType < T > ( prhs [ 1 ] ) )
>771	ExpressionStatement	 
>772	CallExpression	mexErrMsgTxt ( \"type of argument 2 is not consistent\" )
>773	ArgumentList	\"type of argument 2 is not consistent\"
>774	Argument	\"type of argument 2 is not consistent\"
>775	PrimaryExpression	\"type of argument 2 is not consistent\"
>776	Callee	mexErrMsgTxt
>777	Identifier	mexErrMsgTxt
>778	Condition	 
>779	RelationalExpression	! mexCheckType < T > ( prhs [ 1 ] )
>780	RelationalExpression	T > ( prhs [ 1 ] )
>781	ArrayIndexing	prhs [ 1 ]
>782	PrimaryExpression	1
>783	Identifier	prhs
>784	Identifier	T
>785	UnaryOp	! mexCheckType
>786	Identifier	mexCheckType
>787	UnaryOperator	!
>788	IfStatement	if ( mxIsSparse ( prhs [ 0 ] ) )
>789	ExpressionStatement	 
>790	CallExpression	mexErrMsgTxt ( \"argument 1 should be full\" )
>791	ArgumentList	\"argument 1 should be full\"
>792	Argument	\"argument 1 should be full\"
>793	PrimaryExpression	\"argument 1 should be full\"
>794	Callee	mexErrMsgTxt
>795	Identifier	mexErrMsgTxt
>796	Condition	 
>797	CallExpression	mxIsSparse ( prhs [ 0 ] )
>798	ArgumentList	prhs [ 0 ]
>799	Argument	prhs [ 0 ]
>800	ArrayIndexing	prhs [ 0 ]
>801	PrimaryExpression	0
>802	Identifier	prhs
>803	Callee	mxIsSparse
>804	Identifier	mxIsSparse
>805	IfStatement	if ( ! mexCheckType < T > ( prhs [ 0 ] ) )
>806	ExpressionStatement	 
>807	CallExpression	mexErrMsgTxt ( \"type of argument 1 is not consistent\" )
>808	ArgumentList	\"type of argument 1 is not consistent\"
>809	Argument	\"type of argument 1 is not consistent\"
>810	PrimaryExpression	\"type of argument 1 is not consistent\"
>811	Callee	mexErrMsgTxt
>812	Identifier	mexErrMsgTxt
>813	Condition	 
>814	RelationalExpression	! mexCheckType < T > ( prhs [ 0 ] )
>815	RelationalExpression	T > ( prhs [ 0 ] )
>816	ArrayIndexing	prhs [ 0 ]
>817	PrimaryExpression	0
>818	Identifier	prhs
>819	Identifier	T
>820	UnaryOp	! mexCheckType
>821	Identifier	mexCheckType
>822	UnaryOperator	!
>893	FunctionDef	mexFunction (int nlhs , mxArray * plhs [ ] , int nrhs , const mxArray * prhs [ ])
>894	ParameterList	int nlhs , mxArray * plhs [ ] , int nrhs , const mxArray * prhs [ ]
>895	Parameter	 
>896	Identifier	prhs
>897	ParameterType	const mxArray * [ ]
>898	Parameter	 
>899	Identifier	nrhs
>900	ParameterType	int
>901	Parameter	 
>902	Identifier	plhs
>903	ParameterType	mxArray * [ ]
>904	Parameter	 
>905	Identifier	nlhs
>906	ParameterType	int
>907	ReturnType	void
>908	CompoundStatement	 
>909	IfStatement	if ( mxGetClassID ( prhs [ 0 ] ) == mxDOUBLE_CLASS )
>910	ElseStatement	else
>911	CompoundStatement	 
>912	ExpressionStatement	 
>913	RelationalExpression	callFunction < float > ( plhs , prhs )
>914	RelationalExpression	float > ( plhs , prhs )
>915	Expression	plhs , prhs
>916	Identifier	prhs
>917	Identifier	plhs
>918	Identifier	float
>919	Identifier	callFunction
>920	CompoundStatement	 
>921	ExpressionStatement	 
>922	RelationalExpression	callFunction < double > ( plhs , prhs )
>923	RelationalExpression	double > ( plhs , prhs )
>924	Expression	plhs , prhs
>925	Identifier	prhs
>926	Identifier	plhs
>927	Identifier	double
>928	Identifier	callFunction
>929	Condition	 
>930	EqualityExpression	mxGetClassID ( prhs [ 0 ] ) == mxDOUBLE_CLASS
>931	Identifier	mxDOUBLE_CLASS
>932	CallExpression	mxGetClassID ( prhs [ 0 ] )
>933	ArgumentList	prhs [ 0 ]
>934	Argument	prhs [ 0 ]
>935	ArrayIndexing	prhs [ 0 ]
>936	PrimaryExpression	0
>937	Identifier	prhs
>938	Callee	mxGetClassID
>939	Identifier	mxGetClassID
>940	IfStatement	if ( nlhs != 1 )
>941	ExpressionStatement	 
>942	CallExpression	mexErrMsgTxt ( \"Bad number of output arguments\" )
>943	ArgumentList	\"Bad number of output arguments\"
>944	Argument	\"Bad number of output arguments\"
>945	PrimaryExpression	\"Bad number of output arguments\"
>946	Callee	mexErrMsgTxt
>947	Identifier	mexErrMsgTxt
>948	Condition	 
>949	EqualityExpression	nlhs != 1
>950	PrimaryExpression	1
>951	Identifier	nlhs
>952	IfStatement	if ( nrhs != 4 )
>953	ExpressionStatement	 
>954	CallExpression	mexErrMsgTxt ( \"Bad number of inputs arguments\" )
>955	ArgumentList	\"Bad number of inputs arguments\"
>956	Argument	\"Bad number of inputs arguments\"
>957	PrimaryExpression	\"Bad number of inputs arguments\"
>958	Callee	mexErrMsgTxt
>959	Identifier	mexErrMsgTxt
>960	Condition	 
>961	EqualityExpression	nrhs != 4
>962	PrimaryExpression	4
>963	Identifier	nrhs
<3=12,11,4
<4=8,5
<5=7,6
<8=10,9
<12=805,788,770,753,736,735,734,733,732,731,730,729,728,727,726,725,724,723,722,715,696,695,694,693,692,691,690,689,688,687,678,664,663,662,661,660,659,658,657,653,652,651,650,649,648,647,646,642,641,640,639,638,637,636,635,634,633,624,610,609,608,607,606,605,604,603,599,587,586,585,584,583,582,581,580,576,562,561,560,559,558,557,556,555,547,546,545,13,15,16,17,18,20,21,22,23,200,207,214,221,235,249,263,280,308,315,334,341,372,452,466,473,482,492,493,494,495,496,497,498,499,516,522,523,524,525,526,527,528,529,538,539,540,541,542,543,544
<13=14
<18=19
<23=192,188,185,24
<24=171,157,143,129,118,25
<25=114,26
<26=69,37,33,27
<27=28
<28=32,29
<29=31,30
<33=34
<34=36,35
<37=61,57,54,38
<38=39
<39=49,40
<40=48,41
<41=47,42
<42=46,43
<43=45,44
<49=53,50
<50=52,51
<54=56,55
<57=58
<58=60,59
<61=62
<62=63
<63=68,67,64
<64=66,65
<69=106,100,97,70
<70=85,71
<71=72
<72=80,73
<73=79,74
<74=78,75
<75=77,76
<80=84,81
<81=83,82
<85=86
<86=94,87
<87=93,88
<88=92,89
<89=91,90
<94=96,95
<97=99,98
<100=101
<101=105,102
<102=104,103
<106=107
<107=108
<108=113,112,109
<109=111,110
<114=115
<115=117,116
<118=119
<119=128,120
<120=122,121
<122=123
<123=125,124
<125=127,126
<129=130
<130=142,141,131
<131=140,132
<132=134,133
<134=135
<135=137,136
<137=139,138
<143=144
<144=156,155,145
<145=154,146
<146=148,147
<148=149
<149=151,150
<151=153,152
<157=158
<158=170,169,159
<159=168,160
<160=162,161
<162=163
<163=165,164
<165=167,166
<171=172
<172=184,183,173
<173=182,174
<174=176,175
<176=177
<177=179,178
<179=181,180
<185=187,186
<188=189
<189=191,190
<192=193
<193=194
<194=199,198,195
<195=197,196
<200=201
<201=206,205,202
<202=204,203
<207=208
<208=213,212,209
<209=211,210
<214=215
<215=220,219,216
<216=218,217
<221=222
<222=234,233,223
<223=232,224
<224=230,225
<225=226
<226=227
<227=229,228
<230=231
<235=236
<236=248,247,237
<237=246,238
<238=244,239
<239=240
<240=241
<241=243,242
<244=245
<249=250
<250=262,261,251
<251=260,252
<252=258,253
<253=254
<254=255
<255=257,256
<258=259
<263=264
<264=277,265
<265=275,266
<266=273,271,269,267
<267=268
<269=270
<271=272
<273=274
<275=276
<277=279,278
<280=300,296,293,281
<281=282
<282=283
<283=292,284
<284=286,285
<286=287
<287=289,288
<289=291,290
<293=295,294
<296=297
<297=299,298
<300=301
<301=302
<302=307,306,303
<303=305,304
<308=309
<309=314,313,310
<310=312,311
<315=316
<316=332,317
<317=330,328,326,324,322,320,318
<318=319
<320=321
<322=323
<324=325
<326=327
<328=329
<330=331
<332=333
<334=335
<335=340,339,336
<336=338,337
<341=342
<342=364,343
<343=354,352,344
<344=345
<345=351,346
<346=350,347
<347=349,348
<352=353
<354=355
<355=363,356
<356=358,357
<358=362,359
<359=361,360
<364=365
<365=367,366
<367=371,368
<368=370,369
<372=444,438,435,373
<373=421,403,374
<374=375
<375=397,376
<376=389,387,377
<377=378
<378=382,379
<379=381,380
<382=386,383
<383=385,384
<387=388
<389=390
<390=396,391
<391=393,392
<393=395,394
<397=398
<398=400,399
<400=402,401
<403=411,404
<404=405
<405=409,406
<406=407
<407=408
<409=410
<411=412
<412=418,413
<413=417,414
<414=416,415
<418=420,419
<421=429,422
<422=423
<423=427,424
<424=425
<425=426
<427=428
<429=430
<430=432,431
<432=434,433
<435=437,436
<438=439
<439=443,440
<440=442,441
<444=445
<445=446
<446=451,450,447
<447=449,448
<452=460,453
<453=454
<454=458,455
<455=456
<456=457
<458=459
<460=461
<461=463,462
<463=465,464
<466=467
<467=472,471,468
<468=470,469
<473=474
<474=481,480,475
<475=479,476
<476=478,477
<482=483
<483=489,484
<484=488,485
<485=487,486
<489=491,490
<499=500
<500=515,514,501
<501=513,502
<502=512,503
<503=511,504
<504=508,505
<505=507,506
<508=510,509
<516=517
<517=519,518
<519=521,520
<529=530
<530=536,531
<531=532
<532=533
<533=535,534
<536=537
<547=548
<548=552,549
<549=551,550
<552=554,553
<562=563
<563=575,574,564
<564=573,565
<565=571,566
<566=567
<567=568
<568=570,569
<571=572
<576=577
<577=579,578
<587=595,588
<588=589
<589=593,590
<590=591
<591=592
<593=594
<595=596
<596=598,597
<599=600
<600=602,601
<610=611
<611=623,622,612
<612=621,613
<613=619,614
<614=615
<615=616
<616=618,617
<619=620
<624=625
<625=631,626
<626=627
<627=628
<628=630,629
<631=632
<642=643
<643=645,644
<653=654
<654=656,655
<664=665
<665=677,676,666
<666=675,667
<667=673,668
<668=669
<669=670
<670=672,671
<673=674
<678=679
<679=685,680
<680=681
<681=682
<682=684,683
<685=686
<696=704,697
<697=698
<698=702,699
<699=700
<700=701
<702=703
<704=705
<705=714,706
<706=712,707
<707=708
<708=709
<709=711,710
<712=713
<715=716
<716=720,717
<717=718
<718=719
<720=721
<736=744,737
<737=738
<738=742,739
<739=740
<740=741
<742=743
<744=745
<745=751,746
<746=747
<747=748
<748=750,749
<751=752
<753=761,754
<754=755
<755=759,756
<756=757
<757=758
<759=760
<761=762
<762=768,763
<763=764
<764=765
<765=767,766
<768=769
<770=778,771
<771=772
<772=776,773
<773=774
<774=775
<776=777
<778=779
<779=785,780
<780=784,781
<781=783,782
<785=787,786
<788=796,789
<789=790
<790=794,791
<791=792
<792=793
<794=795
<796=797
<797=803,798
<798=799
<799=800
<800=802,801
<803=804
<805=813,806
<806=807
<807=811,808
<808=809
<809=810
<811=812
<813=814
<814=820,815
<815=819,816
<816=818,817
<820=822,821
<893=908,907,894
<894=904,901,898,895
<895=897,896
<898=900,899
<901=903,902
<904=906,905
<908=952,940,909
<909=929,920,910
<910=911
<911=912
<912=913
<913=919,914
<914=918,915
<915=917,916
<920=921
<921=922
<922=928,923
<923=927,924
<924=926,925
<929=930
<930=932,931
<932=938,933
<933=934
<934=935
<935=937,936
<938=939
<940=948,941
<941=942
<942=946,943
<943=944
<944=945
<946=947
<948=949
<949=951,950
<952=960,953
<953=954
<954=958,955
<955=956
<956=957
<958=959
<960=961
<961=963,962
