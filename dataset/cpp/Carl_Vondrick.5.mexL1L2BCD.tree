>3	FunctionDef	callFunction (mxArray * plhs [ ] , const mxArray * prhs [ ])
>4	ParameterList	mxArray * plhs [ ] , const mxArray * prhs [ ]
>5	Parameter	 
>6	Identifier	prhs
>7	ParameterType	const mxArray * [ ]
>8	Parameter	 
>9	Identifier	plhs
>10	ParameterType	mxArray * [ ]
>11	ReturnType	inline void
>12	CompoundStatement	 
>13	ExpressionStatement	 
>14	Identifier	alpha
>15	Statement	 
>16	Statement	 
>17	Statement	 
>18	ExpressionStatement	 
>19	Identifier	X
>20	Statement	 
>21	Statement	 
>22	Statement	 
>23	ExpressionStatement	 
>24	RelationalExpression	ist_groupLasso < T > ( X , D , alpha , Ng , lambda , mode , itermax , tol , numThreads )
>25	RelationalExpression	T > ( X , D , alpha , Ng , lambda , mode , itermax , tol , numThreads )
>26	Expression	X , D , alpha , Ng , lambda , mode , itermax , tol , numThreads
>27	Expression	D , alpha , Ng , lambda , mode , itermax , tol , numThreads
>28	Expression	alpha , Ng , lambda , mode , itermax , tol , numThreads
>29	Expression	Ng , lambda , mode , itermax , tol , numThreads
>30	Expression	lambda , mode , itermax , tol , numThreads
>31	Expression	mode , itermax , tol , numThreads
>32	Expression	itermax , tol , numThreads
>33	Expression	tol , numThreads
>34	Identifier	numThreads
>35	Identifier	tol
>36	Identifier	itermax
>37	Identifier	mode
>38	Identifier	lambda
>39	Identifier	Ng
>40	Identifier	alpha
>41	Identifier	D
>42	Identifier	X
>43	Identifier	T
>44	Identifier	ist_groupLasso
>45	ExpressionStatement	 
>46	CallExpression	alpha [ Ng - 1 ] . setData ( pr_alpha + list_groups [ Ng - 1 ] * K , K , M - list_groups [ Ng - 1 ] )
>47	ArgumentList	pr_alpha + list_groups [ Ng - 1 ] * K
>48	Argument	M - list_groups [ Ng - 1 ]
>49	AdditiveExpression	M - list_groups [ Ng - 1 ]
>50	ArrayIndexing	list_groups [ Ng - 1 ]
>51	AdditiveExpression	Ng - 1
>52	PrimaryExpression	1
>53	Identifier	Ng
>54	Identifier	list_groups
>55	Identifier	M
>56	Argument	K
>57	Identifier	K
>58	Argument	pr_alpha + list_groups [ Ng - 1 ] * K
>59	AdditiveExpression	pr_alpha + list_groups [ Ng - 1 ] * K
>60	MultiplicativeExpression	list_groups [ Ng - 1 ] * K
>61	Identifier	K
>62	ArrayIndexing	list_groups [ Ng - 1 ]
>63	AdditiveExpression	Ng - 1
>64	PrimaryExpression	1
>65	Identifier	Ng
>66	Identifier	list_groups
>67	Identifier	pr_alpha
>68	Callee	alpha [ Ng - 1 ] . setData
>69	MemberAccess	alpha [ Ng - 1 ] . setData
>70	Identifier	setData
>71	ArrayIndexing	alpha [ Ng - 1 ]
>72	AdditiveExpression	Ng - 1
>73	PrimaryExpression	1
>74	Identifier	Ng
>75	Identifier	alpha
>76	ExpressionStatement	 
>77	CallExpression	X [ Ng - 1 ] . setData ( prX + list_groups [ Ng - 1 ] * n , n , M - list_groups [ Ng - 1 ] )
>78	ArgumentList	prX + list_groups [ Ng - 1 ] * n
>79	Argument	M - list_groups [ Ng - 1 ]
>80	AdditiveExpression	M - list_groups [ Ng - 1 ]
>81	ArrayIndexing	list_groups [ Ng - 1 ]
>82	AdditiveExpression	Ng - 1
>83	PrimaryExpression	1
>84	Identifier	Ng
>85	Identifier	list_groups
>86	Identifier	M
>87	Argument	n
>88	Identifier	n
>89	Argument	prX + list_groups [ Ng - 1 ] * n
>90	AdditiveExpression	prX + list_groups [ Ng - 1 ] * n
>91	MultiplicativeExpression	list_groups [ Ng - 1 ] * n
>92	Identifier	n
>93	ArrayIndexing	list_groups [ Ng - 1 ]
>94	AdditiveExpression	Ng - 1
>95	PrimaryExpression	1
>96	Identifier	Ng
>97	Identifier	list_groups
>98	Identifier	prX
>99	Callee	X [ Ng - 1 ] . setData
>100	MemberAccess	X [ Ng - 1 ] . setData
>101	Identifier	setData
>102	ArrayIndexing	X [ Ng - 1 ]
>103	AdditiveExpression	Ng - 1
>104	PrimaryExpression	1
>105	Identifier	Ng
>106	Identifier	X
>107	ForStatement	for ( long i = 0 ; i < Ng - 1 ; ++ i )
>108	CompoundStatement	 
>109	ExpressionStatement	 
>110	CallExpression	alpha [ i ] . setData ( pr_alpha + list_groups [ i ] * K , K , list_groups [ i + 1 ] - list_groups [ i ] )
>111	ArgumentList	pr_alpha + list_groups [ i ] * K
>112	Argument	list_groups [ i + 1 ] - list_groups [ i ]
>113	AdditiveExpression	list_groups [ i + 1 ] - list_groups [ i ]
>114	ArrayIndexing	list_groups [ i ]
>115	Identifier	i
>116	Identifier	list_groups
>117	ArrayIndexing	list_groups [ i + 1 ]
>118	AdditiveExpression	i + 1
>119	PrimaryExpression	1
>120	Identifier	i
>121	Identifier	list_groups
>122	Argument	K
>123	Identifier	K
>124	Argument	pr_alpha + list_groups [ i ] * K
>125	AdditiveExpression	pr_alpha + list_groups [ i ] * K
>126	MultiplicativeExpression	list_groups [ i ] * K
>127	Identifier	K
>128	ArrayIndexing	list_groups [ i ]
>129	Identifier	i
>130	Identifier	list_groups
>131	Identifier	pr_alpha
>132	Callee	alpha [ i ] . setData
>133	MemberAccess	alpha [ i ] . setData
>134	Identifier	setData
>135	ArrayIndexing	alpha [ i ]
>136	Identifier	i
>137	Identifier	alpha
>138	ExpressionStatement	 
>139	CallExpression	X [ i ] . setData ( prX + list_groups [ i ] * n , n , list_groups [ i + 1 ] - list_groups [ i ] )
>140	ArgumentList	prX + list_groups [ i ] * n
>141	Argument	list_groups [ i + 1 ] - list_groups [ i ]
>142	AdditiveExpression	list_groups [ i + 1 ] - list_groups [ i ]
>143	ArrayIndexing	list_groups [ i ]
>144	Identifier	i
>145	Identifier	list_groups
>146	ArrayIndexing	list_groups [ i + 1 ]
>147	AdditiveExpression	i + 1
>148	PrimaryExpression	1
>149	Identifier	i
>150	Identifier	list_groups
>151	Argument	n
>152	Identifier	n
>153	Argument	prX + list_groups [ i ] * n
>154	AdditiveExpression	prX + list_groups [ i ] * n
>155	MultiplicativeExpression	list_groups [ i ] * n
>156	Identifier	n
>157	ArrayIndexing	list_groups [ i ]
>158	Identifier	i
>159	Identifier	list_groups
>160	Identifier	prX
>161	Callee	X [ i ] . setData
>162	MemberAccess	X [ i ] . setData
>163	Identifier	setData
>164	ArrayIndexing	X [ i ]
>165	Identifier	i
>166	Identifier	X
>167	IfStatement	if ( list_groups [ i ] >= list_groups [ i + 1 ] )
>168	ExpressionStatement	 
>169	CallExpression	mexErrMsgTxt ( \"Group indices should be a strictly non-decreasing sequence\" )
>170	ArgumentList	\"Group indices should be a strictly non-decreasing sequence\"
>171	Argument	\"Group indices should be a strictly non-decreasing sequence\"
>172	PrimaryExpression	\"Group indices should be a strictly non-decreasing sequence\"
>173	Callee	mexErrMsgTxt
>174	Identifier	mexErrMsgTxt
>175	Condition	 
>176	RelationalExpression	list_groups [ i ] >= list_groups [ i + 1 ]
>177	ArrayIndexing	list_groups [ i + 1 ]
>178	AdditiveExpression	i + 1
>179	PrimaryExpression	1
>180	Identifier	i
>181	Identifier	list_groups
>182	ArrayIndexing	list_groups [ i ]
>183	Identifier	i
>184	Identifier	list_groups
>185	IfStatement	if ( list_groups [ i ] >= M )
>186	ExpressionStatement	 
>187	CallExpression	mexErrMsgTxt ( \"Size of groups is not consistent\" )
>188	ArgumentList	\"Size of groups is not consistent\"
>189	Argument	\"Size of groups is not consistent\"
>190	PrimaryExpression	\"Size of groups is not consistent\"
>191	Callee	mexErrMsgTxt
>192	Identifier	mexErrMsgTxt
>193	Condition	 
>194	RelationalExpression	list_groups [ i ] >= M
>195	Identifier	M
>196	ArrayIndexing	list_groups [ i ]
>197	Identifier	i
>198	Identifier	list_groups
>199	UnaryExpression	 
>200	Identifier	i
>201	IncDec	++
>202	Condition	 
>203	RelationalExpression	i < Ng - 1
>204	AdditiveExpression	Ng - 1
>205	PrimaryExpression	1
>206	Identifier	Ng
>207	Identifier	i
>208	ForInit	 
>209	IdentifierDeclStatement	long i = 0 ;
>210	IdentifierDecl	i = 0
>211	AssignmentExpr	i = 0
>212	PrimaryExpression	0
>213	Identifier	i
>214	Identifier	i
>215	IdentifierDeclType	long
>216	IfStatement	if ( list_groups [ 0 ] != 0 )
>217	ExpressionStatement	 
>218	CallExpression	mexErrMsgTxt ( \"First group index should be zero\" )
>219	ArgumentList	\"First group index should be zero\"
>220	Argument	\"First group index should be zero\"
>221	PrimaryExpression	\"First group index should be zero\"
>222	Callee	mexErrMsgTxt
>223	Identifier	mexErrMsgTxt
>224	Condition	 
>225	EqualityExpression	list_groups [ 0 ] != 0
>226	PrimaryExpression	0
>227	ArrayIndexing	list_groups [ 0 ]
>228	PrimaryExpression	0
>229	Identifier	list_groups
>230	IdentifierDeclStatement	 
>231	IdentifierDecl	* alpha = new Matrix < T > [ Ng ]
>232	AssignmentExpr	* alpha = new Matrix < T > [ Ng ]
>233	Identifier	Ng
>234	Identifier	Ng
>235	Identifier	alpha
>236	IdentifierDeclType	Matrix < T > *
>237	IdentifierDeclStatement	 
>238	IdentifierDecl	* X = new Matrix < T > [ Ng ]
>239	AssignmentExpr	* X = new Matrix < T > [ Ng ]
>240	Identifier	Ng
>241	Identifier	Ng
>242	Identifier	X
>243	IdentifierDeclType	Matrix < T > *
>244	IdentifierDeclStatement	 
>245	IdentifierDecl	D ( prD , n , K )
>246	Expression	prD , n , K
>247	Expression	n , K
>248	Identifier	K
>249	Identifier	n
>250	Identifier	prD
>251	Identifier	D
>252	IdentifierDeclType	Matrix < T >
>253	ExpressionStatement	 
>254	Expression	prhs [ 4 ] , \"mode\" , PENALTY
>255	Expression	\"mode\" , PENALTY
>256	Identifier	PENALTY
>257	PrimaryExpression	\"mode\"
>258	ArrayIndexing	prhs [ 4 ]
>259	PrimaryExpression	4
>260	Identifier	prhs
>261	Statement	 
>262	Statement	 
>263	Statement	 
>264	Statement	 
>265	Statement	 
>266	Statement	 
>267	Statement	 
>268	Statement	 
>269	Statement	 
>270	Statement	 
>271	ExpressionStatement	 
>272	Expression	prhs [ 4 ] , \"numThreads\" , - 1
>273	Expression	\"numThreads\" , - 1
>274	UnaryOp	- 1
>275	PrimaryExpression	1
>276	UnaryOperator	-
>277	PrimaryExpression	\"numThreads\"
>278	ArrayIndexing	prhs [ 4 ]
>279	PrimaryExpression	4
>280	Identifier	prhs
>281	Statement	 
>282	Statement	 
>283	Statement	 
>284	Statement	 
>285	Statement	 
>286	Statement	 
>287	Statement	 
>288	ExpressionStatement	 
>289	Expression	prhs [ 4 ] , \"itermax\" , 100
>290	Expression	\"itermax\" , 100
>291	PrimaryExpression	100
>292	PrimaryExpression	\"itermax\"
>293	ArrayIndexing	prhs [ 4 ]
>294	PrimaryExpression	4
>295	Identifier	prhs
>296	Statement	 
>297	Statement	 
>298	Statement	 
>299	Statement	 
>300	Statement	 
>301	Statement	 
>302	Statement	 
>303	IdentifierDeclStatement	 
>304	IdentifierDecl	tol = getScalarStructDef < T > ( prhs [ 4 ] , \"tol\" , 1e-3 )
>305	AssignmentExpr	tol = getScalarStructDef < T > ( prhs [ 4 ] , \"tol\" , 1e-3 )
>306	RelationalExpression	getScalarStructDef < T > ( prhs [ 4 ] , \"tol\" , 1e-3 )
>307	RelationalExpression	T > ( prhs [ 4 ] , \"tol\" , 1e-3 )
>308	Expression	prhs [ 4 ] , \"tol\" , 1e-3
>309	Expression	\"tol\" , 1e-3
>310	PrimaryExpression	1e-3
>311	PrimaryExpression	\"tol\"
>312	ArrayIndexing	prhs [ 4 ]
>313	PrimaryExpression	4
>314	Identifier	prhs
>315	Identifier	T
>316	Identifier	getScalarStructDef
>317	Identifier	tol
>318	Identifier	tol
>319	IdentifierDeclType	T
>320	IdentifierDeclStatement	 
>321	IdentifierDecl	lambda = getScalarStruct < T > ( prhs [ 4 ] , \"lambda\" )
>322	AssignmentExpr	lambda = getScalarStruct < T > ( prhs [ 4 ] , \"lambda\" )
>323	RelationalExpression	getScalarStruct < T > ( prhs [ 4 ] , \"lambda\" )
>324	RelationalExpression	T > ( prhs [ 4 ] , \"lambda\" )
>325	Expression	prhs [ 4 ] , \"lambda\"
>326	PrimaryExpression	\"lambda\"
>327	ArrayIndexing	prhs [ 4 ]
>328	PrimaryExpression	4
>329	Identifier	prhs
>330	Identifier	T
>331	Identifier	getScalarStruct
>332	Identifier	lambda
>333	Identifier	lambda
>334	IdentifierDeclType	T
>335	ExpressionStatement	 
>336	CallExpression	mxGetPr ( prhs [ 3 ] )
>337	ArgumentList	prhs [ 3 ]
>338	Argument	prhs [ 3 ]
>339	ArrayIndexing	prhs [ 3 ]
>340	PrimaryExpression	3
>341	Identifier	prhs
>342	Callee	mxGetPr
>343	Identifier	mxGetPr
>344	Statement	 
>345	Statement	 
>346	Statement	 
>347	Statement	 
>348	Statement	 
>349	Statement	 
>350	Statement	 
>351	Statement	 
>352	Statement	 
>353	ExpressionStatement	 
>354	MultiplicativeExpression	dimsList [ 0 ] * dimsList [ 1 ]
>355	ArrayIndexing	dimsList [ 1 ]
>356	PrimaryExpression	1
>357	Identifier	dimsList
>358	ArrayIndexing	dimsList [ 0 ]
>359	PrimaryExpression	0
>360	Identifier	dimsList
>361	Statement	 
>362	Statement	 
>363	Statement	 
>364	Statement	 
>365	Statement	 
>366	Statement	 
>367	Statement	 
>368	IdentifierDeclStatement	 
>369	IdentifierDecl	* dimsList = mxGetDimensions ( prhs [ 3 ] )
>370	AssignmentExpr	* dimsList = mxGetDimensions ( prhs [ 3 ] )
>371	CallExpression	mxGetDimensions ( prhs [ 3 ] )
>372	ArgumentList	prhs [ 3 ]
>373	Argument	prhs [ 3 ]
>374	ArrayIndexing	prhs [ 3 ]
>375	PrimaryExpression	3
>376	Identifier	prhs
>377	Callee	mxGetDimensions
>378	Identifier	mxGetDimensions
>379	Identifier	dimsList
>380	Identifier	dimsList
>381	IdentifierDeclType	const mwSize *
>382	ExpressionStatement	 
>383	CallExpression	mxGetPr ( plhs [ 0 ] )
>384	ArgumentList	plhs [ 0 ]
>385	Argument	plhs [ 0 ]
>386	ArrayIndexing	plhs [ 0 ]
>387	PrimaryExpression	0
>388	Identifier	plhs
>389	Callee	mxGetPr
>390	Identifier	mxGetPr
>391	Statement	 
>392	Statement	 
>393	Statement	 
>394	Statement	 
>395	Statement	 
>396	Statement	 
>397	Statement	 
>398	Statement	 
>399	Statement	 
>400	ExpressionStatement	 
>401	AssignmentExpr	plhs [ 0 ] = mxDuplicateArray ( prhs [ 2 ] )
>402	CallExpression	mxDuplicateArray ( prhs [ 2 ] )
>403	ArgumentList	prhs [ 2 ]
>404	Argument	prhs [ 2 ]
>405	ArrayIndexing	prhs [ 2 ]
>406	PrimaryExpression	2
>407	Identifier	prhs
>408	Callee	mxDuplicateArray
>409	Identifier	mxDuplicateArray
>410	ArrayIndexing	plhs [ 0 ]
>411	PrimaryExpression	0
>412	Identifier	plhs
>413	IfStatement	if ( Ma != M || Ka != K )
>414	ExpressionStatement	 
>415	CallExpression	mexErrMsgTxt ( \"wrong size for argument 3\" )
>416	ArgumentList	\"wrong size for argument 3\"
>417	Argument	\"wrong size for argument 3\"
>418	PrimaryExpression	\"wrong size for argument 3\"
>419	Callee	mexErrMsgTxt
>420	Identifier	mexErrMsgTxt
>421	Condition	 
>422	OrExpression	Ma != M || Ka != K
>423	EqualityExpression	Ka != K
>424	Identifier	K
>425	Identifier	Ka
>426	EqualityExpression	Ma != M
>427	Identifier	M
>428	Identifier	Ma
>429	ExpressionStatement	 
>430	ArrayIndexing	dimsA [ 1 ]
>431	PrimaryExpression	1
>432	Identifier	dimsA
>433	Statement	 
>434	Statement	 
>435	Statement	 
>436	Statement	 
>437	Statement	 
>438	Statement	 
>439	Statement	 
>440	ExpressionStatement	 
>441	ArrayIndexing	dimsA [ 0 ]
>442	PrimaryExpression	0
>443	Identifier	dimsA
>444	Statement	 
>445	Statement	 
>446	Statement	 
>447	Statement	 
>448	Statement	 
>449	Statement	 
>450	Statement	 
>451	IdentifierDeclStatement	 
>452	IdentifierDecl	* dimsA = mxGetDimensions ( prhs [ 2 ] )
>453	AssignmentExpr	* dimsA = mxGetDimensions ( prhs [ 2 ] )
>454	CallExpression	mxGetDimensions ( prhs [ 2 ] )
>455	ArgumentList	prhs [ 2 ]
>456	Argument	prhs [ 2 ]
>457	ArrayIndexing	prhs [ 2 ]
>458	PrimaryExpression	2
>459	Identifier	prhs
>460	Callee	mxGetDimensions
>461	Identifier	mxGetDimensions
>462	Identifier	dimsA
>463	Identifier	dimsA
>464	IdentifierDeclType	const mwSize *
>465	ExpressionStatement	 
>466	ArrayIndexing	dimsD [ 1 ]
>467	PrimaryExpression	1
>468	Identifier	dimsD
>469	Statement	 
>470	Statement	 
>471	Statement	 
>472	Statement	 
>473	Statement	 
>474	Statement	 
>475	Statement	 
>476	IfStatement	if ( nD != n )
>477	ExpressionStatement	 
>478	CallExpression	mexErrMsgTxt ( \"wrong size for argument 2\" )
>479	ArgumentList	\"wrong size for argument 2\"
>480	Argument	\"wrong size for argument 2\"
>481	PrimaryExpression	\"wrong size for argument 2\"
>482	Callee	mexErrMsgTxt
>483	Identifier	mexErrMsgTxt
>484	Condition	 
>485	EqualityExpression	nD != n
>486	Identifier	n
>487	Identifier	nD
>488	ExpressionStatement	 
>489	ArrayIndexing	dimsD [ 0 ]
>490	PrimaryExpression	0
>491	Identifier	dimsD
>492	Statement	 
>493	Statement	 
>494	Statement	 
>495	Statement	 
>496	Statement	 
>497	Statement	 
>498	Statement	 
>499	IdentifierDeclStatement	 
>500	IdentifierDecl	* dimsD = mxGetDimensions ( prhs [ 1 ] )
>501	AssignmentExpr	* dimsD = mxGetDimensions ( prhs [ 1 ] )
>502	CallExpression	mxGetDimensions ( prhs [ 1 ] )
>503	ArgumentList	prhs [ 1 ]
>504	Argument	prhs [ 1 ]
>505	ArrayIndexing	prhs [ 1 ]
>506	PrimaryExpression	1
>507	Identifier	prhs
>508	Callee	mxGetDimensions
>509	Identifier	mxGetDimensions
>510	Identifier	dimsD
>511	Identifier	dimsD
>512	IdentifierDeclType	const mwSize *
>513	ExpressionStatement	 
>514	CallExpression	mxGetPr ( prhs [ 1 ] )
>515	ArgumentList	prhs [ 1 ]
>516	Argument	prhs [ 1 ]
>517	ArrayIndexing	prhs [ 1 ]
>518	PrimaryExpression	1
>519	Identifier	prhs
>520	Callee	mxGetPr
>521	Identifier	mxGetPr
>522	Statement	 
>523	Statement	 
>524	Statement	 
>525	Statement	 
>526	Statement	 
>527	Statement	 
>528	Statement	 
>529	Statement	 
>530	Statement	 
>531	ExpressionStatement	 
>532	ArrayIndexing	dims [ 1 ]
>533	PrimaryExpression	1
>534	Identifier	dims
>535	Statement	 
>536	Statement	 
>537	Statement	 
>538	Statement	 
>539	Statement	 
>540	Statement	 
>541	Statement	 
>542	ExpressionStatement	 
>543	ArrayIndexing	dims [ 0 ]
>544	PrimaryExpression	0
>545	Identifier	dims
>546	Statement	 
>547	Statement	 
>548	Statement	 
>549	Statement	 
>550	Statement	 
>551	Statement	 
>552	Statement	 
>553	IdentifierDeclStatement	 
>554	IdentifierDecl	* dims = mxGetDimensions ( prhs [ 0 ] )
>555	AssignmentExpr	* dims = mxGetDimensions ( prhs [ 0 ] )
>556	CallExpression	mxGetDimensions ( prhs [ 0 ] )
>557	ArgumentList	prhs [ 0 ]
>558	Argument	prhs [ 0 ]
>559	ArrayIndexing	prhs [ 0 ]
>560	PrimaryExpression	0
>561	Identifier	prhs
>562	Callee	mxGetDimensions
>563	Identifier	mxGetDimensions
>564	Identifier	dims
>565	Identifier	dims
>566	IdentifierDeclType	const mwSize *
>567	ExpressionStatement	 
>568	CallExpression	mxGetPr ( prhs [ 0 ] )
>569	ArgumentList	prhs [ 0 ]
>570	Argument	prhs [ 0 ]
>571	ArrayIndexing	prhs [ 0 ]
>572	PrimaryExpression	0
>573	Identifier	prhs
>574	Callee	mxGetPr
>575	Identifier	mxGetPr
>576	Statement	 
>577	Statement	 
>578	Statement	 
>579	Statement	 
>580	Statement	 
>581	Statement	 
>582	Statement	 
>583	Statement	 
>584	Statement	 
>585	IfStatement	if ( ! mxIsStruct ( prhs [ 4 ] ) )
>586	ExpressionStatement	 
>587	CallExpression	mexErrMsgTxt ( \"argument 5 should be struct\" )
>588	ArgumentList	\"argument 5 should be struct\"
>589	Argument	\"argument 5 should be struct\"
>590	PrimaryExpression	\"argument 5 should be struct\"
>591	Callee	mexErrMsgTxt
>592	Identifier	mexErrMsgTxt
>593	Condition	 
>594	UnaryOp	! mxIsStruct ( prhs [ 4 ] )
>595	CallExpression	mxIsStruct ( prhs [ 4 ] )
>596	ArgumentList	prhs [ 4 ]
>597	Argument	prhs [ 4 ]
>598	ArrayIndexing	prhs [ 4 ]
>599	PrimaryExpression	4
>600	Identifier	prhs
>601	Callee	mxIsStruct
>602	Identifier	mxIsStruct
>603	UnaryOperator	!
>604	ExpressionStatement	 
>605	CallExpression	mexErrMsgTxt ( \"type of argument 4 is not consistent\" )
>606	ArgumentList	\"type of argument 4 is not consistent\"
>607	Argument	\"type of argument 4 is not consistent\"
>608	PrimaryExpression	\"type of argument 4 is not consistent\"
>609	Callee	mexErrMsgTxt
>610	Identifier	mexErrMsgTxt
>611	Statement	 
>612	Statement	 
>613	Statement	 
>614	Statement	 
>615	Statement	 
>616	Statement	 
>617	Statement	 
>618	Statement	 
>619	Statement	 
>620	Statement	 
>621	Statement	 
>622	Statement	 
>623	Statement	 
>624	Statement	 
>625	IfStatement	if ( mxIsSparse ( prhs [ 2 ] ) )
>626	ExpressionStatement	 
>627	CallExpression	mexErrMsgTxt ( \"argument 3 should be full\" )
>628	ArgumentList	\"argument 3 should be full\"
>629	Argument	\"argument 3 should be full\"
>630	PrimaryExpression	\"argument 3 should be full\"
>631	Callee	mexErrMsgTxt
>632	Identifier	mexErrMsgTxt
>633	Condition	 
>634	CallExpression	mxIsSparse ( prhs [ 2 ] )
>635	ArgumentList	prhs [ 2 ]
>636	Argument	prhs [ 2 ]
>637	ArrayIndexing	prhs [ 2 ]
>638	PrimaryExpression	2
>639	Identifier	prhs
>640	Callee	mxIsSparse
>641	Identifier	mxIsSparse
>642	IfStatement	if ( mxIsSparse ( prhs [ 1 ] ) )
>643	ExpressionStatement	 
>644	CallExpression	mexErrMsgTxt ( \"argument 2 should be full\" )
>645	ArgumentList	\"argument 2 should be full\"
>646	Argument	\"argument 2 should be full\"
>647	PrimaryExpression	\"argument 2 should be full\"
>648	Callee	mexErrMsgTxt
>649	Identifier	mexErrMsgTxt
>650	Condition	 
>651	CallExpression	mxIsSparse ( prhs [ 1 ] )
>652	ArgumentList	prhs [ 1 ]
>653	Argument	prhs [ 1 ]
>654	ArrayIndexing	prhs [ 1 ]
>655	PrimaryExpression	1
>656	Identifier	prhs
>657	Callee	mxIsSparse
>658	Identifier	mxIsSparse
>659	IfStatement	if ( ! mexCheckType < T > ( prhs [ 1 ] ) )
>660	ExpressionStatement	 
>661	CallExpression	mexErrMsgTxt ( \"type of argument 2 is not consistent\" )
>662	ArgumentList	\"type of argument 2 is not consistent\"
>663	Argument	\"type of argument 2 is not consistent\"
>664	PrimaryExpression	\"type of argument 2 is not consistent\"
>665	Callee	mexErrMsgTxt
>666	Identifier	mexErrMsgTxt
>667	Condition	 
>668	RelationalExpression	! mexCheckType < T > ( prhs [ 1 ] )
>669	RelationalExpression	T > ( prhs [ 1 ] )
>670	ArrayIndexing	prhs [ 1 ]
>671	PrimaryExpression	1
>672	Identifier	prhs
>673	Identifier	T
>674	UnaryOp	! mexCheckType
>675	Identifier	mexCheckType
>676	UnaryOperator	!
>677	IfStatement	if ( mxIsSparse ( prhs [ 0 ] ) )
>678	ExpressionStatement	 
>679	CallExpression	mexErrMsgTxt ( \"argument 1 should be full\" )
>680	ArgumentList	\"argument 1 should be full\"
>681	Argument	\"argument 1 should be full\"
>682	PrimaryExpression	\"argument 1 should be full\"
>683	Callee	mexErrMsgTxt
>684	Identifier	mexErrMsgTxt
>685	Condition	 
>686	CallExpression	mxIsSparse ( prhs [ 0 ] )
>687	ArgumentList	prhs [ 0 ]
>688	Argument	prhs [ 0 ]
>689	ArrayIndexing	prhs [ 0 ]
>690	PrimaryExpression	0
>691	Identifier	prhs
>692	Callee	mxIsSparse
>693	Identifier	mxIsSparse
>694	IfStatement	if ( ! mexCheckType < T > ( prhs [ 0 ] ) )
>695	ExpressionStatement	 
>696	CallExpression	mexErrMsgTxt ( \"type of argument 1 is not consistent\" )
>697	ArgumentList	\"type of argument 1 is not consistent\"
>698	Argument	\"type of argument 1 is not consistent\"
>699	PrimaryExpression	\"type of argument 1 is not consistent\"
>700	Callee	mexErrMsgTxt
>701	Identifier	mexErrMsgTxt
>702	Condition	 
>703	RelationalExpression	! mexCheckType < T > ( prhs [ 0 ] )
>704	RelationalExpression	T > ( prhs [ 0 ] )
>705	ArrayIndexing	prhs [ 0 ]
>706	PrimaryExpression	0
>707	Identifier	prhs
>708	Identifier	T
>709	UnaryOp	! mexCheckType
>710	Identifier	mexCheckType
>711	UnaryOperator	!
>752	FunctionDef	mexFunction (int nlhs , mxArray * plhs [ ] , int nrhs , const mxArray * prhs [ ])
>753	ParameterList	int nlhs , mxArray * plhs [ ] , int nrhs , const mxArray * prhs [ ]
>754	Parameter	 
>755	Identifier	prhs
>756	ParameterType	const mxArray * [ ]
>757	Parameter	 
>758	Identifier	nrhs
>759	ParameterType	int
>760	Parameter	 
>761	Identifier	plhs
>762	ParameterType	mxArray * [ ]
>763	Parameter	 
>764	Identifier	nlhs
>765	ParameterType	int
>766	ReturnType	void
>767	CompoundStatement	 
>768	IfStatement	if ( mxGetClassID ( prhs [ 0 ] ) == mxDOUBLE_CLASS )
>769	ElseStatement	else
>770	CompoundStatement	 
>771	ExpressionStatement	 
>772	RelationalExpression	callFunction < float > ( plhs , prhs )
>773	RelationalExpression	float > ( plhs , prhs )
>774	Expression	plhs , prhs
>775	Identifier	prhs
>776	Identifier	plhs
>777	Identifier	float
>778	Identifier	callFunction
>779	CompoundStatement	 
>780	ExpressionStatement	 
>781	RelationalExpression	callFunction < double > ( plhs , prhs )
>782	RelationalExpression	double > ( plhs , prhs )
>783	Expression	plhs , prhs
>784	Identifier	prhs
>785	Identifier	plhs
>786	Identifier	double
>787	Identifier	callFunction
>788	Condition	 
>789	EqualityExpression	mxGetClassID ( prhs [ 0 ] ) == mxDOUBLE_CLASS
>790	Identifier	mxDOUBLE_CLASS
>791	CallExpression	mxGetClassID ( prhs [ 0 ] )
>792	ArgumentList	prhs [ 0 ]
>793	Argument	prhs [ 0 ]
>794	ArrayIndexing	prhs [ 0 ]
>795	PrimaryExpression	0
>796	Identifier	prhs
>797	Callee	mxGetClassID
>798	Identifier	mxGetClassID
>799	IfStatement	if ( nlhs != 1 )
>800	ExpressionStatement	 
>801	CallExpression	mexErrMsgTxt ( \"Bad number of output arguments\" )
>802	ArgumentList	\"Bad number of output arguments\"
>803	Argument	\"Bad number of output arguments\"
>804	PrimaryExpression	\"Bad number of output arguments\"
>805	Callee	mexErrMsgTxt
>806	Identifier	mexErrMsgTxt
>807	Condition	 
>808	EqualityExpression	nlhs != 1
>809	PrimaryExpression	1
>810	Identifier	nlhs
>811	IfStatement	if ( nrhs != 5 )
>812	ExpressionStatement	 
>813	CallExpression	mexErrMsgTxt ( \"Bad number of inputs arguments\" )
>814	ArgumentList	\"Bad number of inputs arguments\"
>815	Argument	\"Bad number of inputs arguments\"
>816	PrimaryExpression	\"Bad number of inputs arguments\"
>817	Callee	mexErrMsgTxt
>818	Identifier	mexErrMsgTxt
>819	Condition	 
>820	EqualityExpression	nrhs != 5
>821	PrimaryExpression	5
>822	Identifier	nrhs
<3=12,11,4
<4=8,5
<5=7,6
<8=10,9
<12=694,677,659,642,625,624,623,622,621,620,619,618,617,616,615,614,613,612,611,604,585,584,583,582,581,580,579,578,577,576,567,553,552,551,550,549,548,547,546,542,541,540,539,538,537,536,535,531,530,529,528,527,526,525,524,523,522,513,499,498,497,496,495,494,493,492,488,476,475,474,473,472,471,470,469,465,451,450,449,448,447,446,445,444,440,439,438,437,436,435,434,433,429,413,400,399,398,397,396,395,394,393,392,391,382,368,367,366,365,364,363,362,361,353,352,351,350,349,348,13,15,16,17,18,20,21,22,23,45,76,107,216,230,237,244,253,261,262,263,264,265,266,267,268,269,270,271,281,282,283,284,285,286,287,288,296,297,298,299,300,301,302,303,320,335,344,345,346,347
<13=14
<18=19
<23=24
<24=44,25
<25=43,26
<26=42,27
<27=41,28
<28=40,29
<29=39,30
<30=38,31
<31=37,32
<32=36,33
<33=35,34
<45=46
<46=68,47
<47=58,56,48
<48=49
<49=55,50
<50=54,51
<51=53,52
<56=57
<58=59
<59=67,60
<60=62,61
<62=66,63
<63=65,64
<68=69
<69=71,70
<71=75,72
<72=74,73
<76=77
<77=99,78
<78=89,87,79
<79=80
<80=86,81
<81=85,82
<82=84,83
<87=88
<89=90
<90=98,91
<91=93,92
<93=97,94
<94=96,95
<99=100
<100=102,101
<102=106,103
<103=105,104
<107=208,202,199,108
<108=185,167,138,109
<109=110
<110=132,111
<111=124,122,112
<112=113
<113=117,114
<114=116,115
<117=121,118
<118=120,119
<122=123
<124=125
<125=131,126
<126=128,127
<128=130,129
<132=133
<133=135,134
<135=137,136
<138=139
<139=161,140
<140=153,151,141
<141=142
<142=146,143
<143=145,144
<146=150,147
<147=149,148
<151=152
<153=154
<154=160,155
<155=157,156
<157=159,158
<161=162
<162=164,163
<164=166,165
<167=175,168
<168=169
<169=173,170
<170=171
<171=172
<173=174
<175=176
<176=182,177
<177=181,178
<178=180,179
<182=184,183
<185=193,186
<186=187
<187=191,188
<188=189
<189=190
<191=192
<193=194
<194=196,195
<196=198,197
<199=201,200
<202=203
<203=207,204
<204=206,205
<208=209
<209=210
<210=215,214,211
<211=213,212
<216=224,217
<217=218
<218=222,219
<219=220
<220=221
<222=223
<224=225
<225=227,226
<227=229,228
<230=231
<231=236,235,232
<232=234,233
<237=238
<238=243,242,239
<239=241,240
<244=245
<245=252,251,246
<246=250,247
<247=249,248
<253=254
<254=258,255
<255=257,256
<258=260,259
<271=272
<272=278,273
<273=277,274
<274=276,275
<278=280,279
<288=289
<289=293,290
<290=292,291
<293=295,294
<303=304
<304=319,318,305
<305=317,306
<306=316,307
<307=315,308
<308=312,309
<309=311,310
<312=314,313
<320=321
<321=334,333,322
<322=332,323
<323=331,324
<324=330,325
<325=327,326
<327=329,328
<335=336
<336=342,337
<337=338
<338=339
<339=341,340
<342=343
<353=354
<354=358,355
<355=357,356
<358=360,359
<368=369
<369=381,380,370
<370=379,371
<371=377,372
<372=373
<373=374
<374=376,375
<377=378
<382=383
<383=389,384
<384=385
<385=386
<386=388,387
<389=390
<400=401
<401=410,402
<402=408,403
<403=404
<404=405
<405=407,406
<408=409
<410=412,411
<413=421,414
<414=415
<415=419,416
<416=417
<417=418
<419=420
<421=422
<422=426,423
<423=425,424
<426=428,427
<429=430
<430=432,431
<440=441
<441=443,442
<451=452
<452=464,463,453
<453=462,454
<454=460,455
<455=456
<456=457
<457=459,458
<460=461
<465=466
<466=468,467
<476=484,477
<477=478
<478=482,479
<479=480
<480=481
<482=483
<484=485
<485=487,486
<488=489
<489=491,490
<499=500
<500=512,511,501
<501=510,502
<502=508,503
<503=504
<504=505
<505=507,506
<508=509
<513=514
<514=520,515
<515=516
<516=517
<517=519,518
<520=521
<531=532
<532=534,533
<542=543
<543=545,544
<553=554
<554=566,565,555
<555=564,556
<556=562,557
<557=558
<558=559
<559=561,560
<562=563
<567=568
<568=574,569
<569=570
<570=571
<571=573,572
<574=575
<585=593,586
<586=587
<587=591,588
<588=589
<589=590
<591=592
<593=594
<594=603,595
<595=601,596
<596=597
<597=598
<598=600,599
<601=602
<604=605
<605=609,606
<606=607
<607=608
<609=610
<625=633,626
<626=627
<627=631,628
<628=629
<629=630
<631=632
<633=634
<634=640,635
<635=636
<636=637
<637=639,638
<640=641
<642=650,643
<643=644
<644=648,645
<645=646
<646=647
<648=649
<650=651
<651=657,652
<652=653
<653=654
<654=656,655
<657=658
<659=667,660
<660=661
<661=665,662
<662=663
<663=664
<665=666
<667=668
<668=674,669
<669=673,670
<670=672,671
<674=676,675
<677=685,678
<678=679
<679=683,680
<680=681
<681=682
<683=684
<685=686
<686=692,687
<687=688
<688=689
<689=691,690
<692=693
<694=702,695
<695=696
<696=700,697
<697=698
<698=699
<700=701
<702=703
<703=709,704
<704=708,705
<705=707,706
<709=711,710
<752=767,766,753
<753=763,760,757,754
<754=756,755
<757=759,758
<760=762,761
<763=765,764
<767=811,799,768
<768=788,779,769
<769=770
<770=771
<771=772
<772=778,773
<773=777,774
<774=776,775
<779=780
<780=781
<781=787,782
<782=786,783
<783=785,784
<788=789
<789=791,790
<791=797,792
<792=793
<793=794
<794=796,795
<797=798
<799=807,800
<800=801
<801=805,802
<802=803
<803=804
<805=806
<807=808
<808=810,809
<811=819,812
<812=813
<813=817,814
<814=815
<815=816
<817=818
<819=820
<820=822,821
