>3	FunctionDef	swap (T & x , T & y)
>4	ParameterList	T & x , T & y
>5	Parameter	 
>6	Identifier	y
>7	ParameterType	T &
>8	Parameter	 
>9	Identifier	x
>10	ParameterType	T &
>11	ReturnType	inline void
>12	CompoundStatement	 
>13	ExpressionStatement	 
>14	AssignmentExpr	y = t
>15	Identifier	t
>16	Identifier	y
>17	ExpressionStatement	 
>18	AssignmentExpr	x = y
>19	Identifier	y
>20	Identifier	x
>21	IdentifierDeclStatement	 
>22	IdentifierDecl	t = x
>23	AssignmentExpr	t = x
>24	Identifier	x
>25	Identifier	x
>26	Identifier	t
>27	IdentifierDeclType	T
>34	FunctionDef	min (T x , T y)
>35	ParameterList	T x , T y
>36	Parameter	 
>37	Identifier	y
>38	ParameterType	T
>39	Parameter	 
>40	Identifier	x
>41	ParameterType	T
>42	ReturnType	inline T
>43	CompoundStatement	 
>44	ReturnStatement	 
>45	ConditionalExpression	( x < y ) ? x 
>46	Identifier	y
>47	Identifier	x
>48	Condition	x < y
>49	RelationalExpression	x < y
>50	Identifier	y
>51	Identifier	x
>57	FunctionDef	max (T x , T y)
>58	ParameterList	T x , T y
>59	Parameter	 
>60	Identifier	y
>61	ParameterType	T
>62	Parameter	 
>63	Identifier	x
>64	ParameterType	T
>65	ReturnType	inline T
>66	CompoundStatement	 
>67	ReturnStatement	 
>68	ConditionalExpression	( x > y ) ? x 
>69	Identifier	y
>70	Identifier	x
>71	Condition	x > y
>72	RelationalExpression	x > y
>73	Identifier	y
>74	Identifier	x
>80	FunctionDef	dnrm2_ (int * n , float * x , int * incx)
>81	ParameterList	int * n , float * x , int * incx
>82	Parameter	 
>83	Identifier	incx
>84	ParameterType	int *
>85	Parameter	 
>86	Identifier	x
>87	ParameterType	float *
>88	Parameter	 
>89	Identifier	n
>90	ParameterType	int *
>91	ReturnType	float
>92	CompoundStatement	 
>93	ReturnStatement	 
>94	Identifier	norm
>95	IfStatement	if ( nn > 0 && iincx > 0 )
>96	ElseStatement	else
>97	ExpressionStatement	 
>98	AssignmentExpr	norm = 0.0f
>99	PrimaryExpression	0.0f
>100	Identifier	norm
>101	CompoundStatement	 
>102	IfStatement	if ( nn == 1 )
>103	ElseStatement	else
>104	CompoundStatement	 
>105	ExpressionStatement	 
>106	AssignmentExpr	norm = scale * sqrt ( ssq )
>107	MultiplicativeExpression	scale * sqrt ( ssq )
>108	CallExpression	sqrt ( ssq )
>109	ArgumentList	ssq
>110	Argument	ssq
>111	Identifier	ssq
>112	Callee	sqrt
>113	Identifier	sqrt
>114	Identifier	scale
>115	Identifier	norm
>116	ForStatement	for ( ix = ( nn - 1 ) * iincx ; ix >= 0 ; ix -= iincx )
>117	CompoundStatement	 
>118	IfStatement	if ( x [ ix ] != 0.0f )
>119	CompoundStatement	 
>120	IfStatement	if ( scale < absxi )
>121	ElseStatement	else
>122	CompoundStatement	 
>123	ExpressionStatement	 
>124	AssignmentExpr	ssq += temp * temp
>125	MultiplicativeExpression	temp * temp
>126	Identifier	temp
>127	Identifier	temp
>128	Identifier	ssq
>129	ExpressionStatement	 
>130	AssignmentExpr	temp = absxi / scale
>131	MultiplicativeExpression	absxi / scale
>132	Identifier	scale
>133	Identifier	absxi
>134	Identifier	temp
>135	CompoundStatement	 
>136	ExpressionStatement	 
>137	AssignmentExpr	scale = absxi
>138	Identifier	absxi
>139	Identifier	scale
>140	ExpressionStatement	 
>141	AssignmentExpr	ssq = ssq * ( temp * temp ) + 1.0f
>142	AdditiveExpression	ssq * ( temp * temp ) + 1.0f
>143	PrimaryExpression	1.0f
>144	MultiplicativeExpression	ssq * ( temp * temp )
>145	MultiplicativeExpression	temp * temp
>146	Identifier	temp
>147	Identifier	temp
>148	Identifier	ssq
>149	Identifier	ssq
>150	ExpressionStatement	 
>151	AssignmentExpr	temp = scale / absxi
>152	MultiplicativeExpression	scale / absxi
>153	Identifier	absxi
>154	Identifier	scale
>155	Identifier	temp
>156	Condition	 
>157	RelationalExpression	scale < absxi
>158	Identifier	absxi
>159	Identifier	scale
>160	ExpressionStatement	 
>161	AssignmentExpr	absxi = fabs ( x [ ix ] )
>162	CallExpression	fabs ( x [ ix ] )
>163	ArgumentList	x [ ix ]
>164	Argument	x [ ix ]
>165	ArrayIndexing	x [ ix ]
>166	Identifier	ix
>167	Identifier	x
>168	Callee	fabs
>169	Identifier	fabs
>170	Identifier	absxi
>171	Condition	 
>172	EqualityExpression	x [ ix ] != 0.0f
>173	PrimaryExpression	0.0f
>174	ArrayIndexing	x [ ix ]
>175	Identifier	ix
>176	Identifier	x
>177	AssignmentExpr	 
>178	Identifier	iincx
>179	Identifier	ix
>180	Condition	 
>181	RelationalExpression	ix >= 0
>182	PrimaryExpression	0
>183	Identifier	ix
>184	ForInit	 
>185	AssignmentExpr	ix = ( nn - 1 ) * iincx
>186	MultiplicativeExpression	( nn - 1 ) * iincx
>187	Identifier	iincx
>188	AdditiveExpression	nn - 1
>189	PrimaryExpression	1
>190	Identifier	nn
>191	Identifier	ix
>192	ExpressionStatement	 
>193	AssignmentExpr	ssq = 1.0f
>194	PrimaryExpression	1.0f
>195	Identifier	ssq
>196	ExpressionStatement	 
>197	AssignmentExpr	scale = 0.0f
>198	PrimaryExpression	0.0f
>199	Identifier	scale
>200	CompoundStatement	 
>201	ExpressionStatement	 
>202	AssignmentExpr	norm = fabs ( x [ 0 ] )
>203	CallExpression	fabs ( x [ 0 ] )
>204	ArgumentList	x [ 0 ]
>205	Argument	x [ 0 ]
>206	ArrayIndexing	x [ 0 ]
>207	PrimaryExpression	0
>208	Identifier	x
>209	Callee	fabs
>210	Identifier	fabs
>211	Identifier	norm
>212	Condition	 
>213	EqualityExpression	nn == 1
>214	PrimaryExpression	1
>215	Identifier	nn
>216	Condition	 
>217	AndExpression	nn > 0 && iincx > 0
>218	RelationalExpression	iincx > 0
>219	PrimaryExpression	0
>220	Identifier	iincx
>221	RelationalExpression	nn > 0
>222	PrimaryExpression	0
>223	Identifier	nn
>224	IdentifierDeclStatement	 
>225	IdentifierDecl	temp
>226	Identifier	temp
>227	IdentifierDeclType	float
>228	IdentifierDecl	ssq
>229	Identifier	ssq
>230	IdentifierDeclType	float
>231	IdentifierDecl	absxi
>232	Identifier	absxi
>233	IdentifierDeclType	float
>234	IdentifierDecl	scale
>235	Identifier	scale
>236	IdentifierDeclType	float
>237	IdentifierDecl	norm
>238	Identifier	norm
>239	IdentifierDeclType	float
>240	IdentifierDeclStatement	 
>241	IdentifierDecl	iincx = * incx
>242	AssignmentExpr	iincx = * incx
>243	UnaryOp	* incx
>244	Identifier	incx
>245	UnaryOperator	*
>246	Identifier	iincx
>247	Identifier	iincx
>248	IdentifierDeclType	long
>249	IdentifierDecl	nn = * n
>250	AssignmentExpr	nn = * n
>251	UnaryOp	* n
>252	Identifier	n
>253	UnaryOperator	*
>254	Identifier	nn
>255	Identifier	nn
>256	IdentifierDeclType	long
>257	IdentifierDecl	ix
>258	Identifier	ix
>259	IdentifierDeclType	long
>280	FunctionDef	ddot_ (int * n , float * sx , int * incx , float * sy , int * incy)
>281	ParameterList	int * n , float * sx , int * incx , float * sy , int * incy
>282	Parameter	 
>283	Identifier	incy
>284	ParameterType	int *
>285	Parameter	 
>286	Identifier	sy
>287	ParameterType	float *
>288	Parameter	 
>289	Identifier	incx
>290	ParameterType	int *
>291	Parameter	 
>292	Identifier	sx
>293	ParameterType	float *
>294	Parameter	 
>295	Identifier	n
>296	ParameterType	int *
>297	ReturnType	float
>298	CompoundStatement	 
>299	ReturnStatement	 
>300	Identifier	stemp
>301	IfStatement	if ( nn > 0 )
>302	CompoundStatement	 
>303	IfStatement	if ( iincx == 1 && iincy == 1 )
>304	ElseStatement	else
>305	CompoundStatement	 
>306	ForStatement	for ( i = 0 ; i < nn ; i ++ )
>307	CompoundStatement	 
>308	ExpressionStatement	 
>309	AssignmentExpr	iy += iincy
>310	Identifier	iincy
>311	Identifier	iy
>312	ExpressionStatement	 
>313	AssignmentExpr	ix += iincx
>314	Identifier	iincx
>315	Identifier	ix
>316	ExpressionStatement	 
>317	AssignmentExpr	stemp += sx [ ix ] * sy [ iy ]
>318	MultiplicativeExpression	sx [ ix ] * sy [ iy ]
>319	ArrayIndexing	sy [ iy ]
>320	Identifier	iy
>321	Identifier	sy
>322	ArrayIndexing	sx [ ix ]
>323	Identifier	ix
>324	Identifier	sx
>325	Identifier	stemp
>326	IncDecOp	 
>327	IncDec	++
>328	Identifier	i
>329	Condition	 
>330	RelationalExpression	i < nn
>331	Identifier	nn
>332	Identifier	i
>333	ForInit	 
>334	AssignmentExpr	i = 0
>335	PrimaryExpression	0
>336	Identifier	i
>337	IfStatement	if ( iincy < 0 )
>338	ExpressionStatement	 
>339	AssignmentExpr	iy = ( 1 - nn ) * iincy
>340	MultiplicativeExpression	( 1 - nn ) * iincy
>341	Identifier	iincy
>342	AdditiveExpression	1 - nn
>343	Identifier	nn
>344	PrimaryExpression	1
>345	Identifier	iy
>346	Condition	 
>347	RelationalExpression	iincy < 0
>348	PrimaryExpression	0
>349	Identifier	iincy
>350	IfStatement	if ( iincx < 0 )
>351	ExpressionStatement	 
>352	AssignmentExpr	ix = ( 1 - nn ) * iincx
>353	MultiplicativeExpression	( 1 - nn ) * iincx
>354	Identifier	iincx
>355	AdditiveExpression	1 - nn
>356	Identifier	nn
>357	PrimaryExpression	1
>358	Identifier	ix
>359	Condition	 
>360	RelationalExpression	iincx < 0
>361	PrimaryExpression	0
>362	Identifier	iincx
>363	ExpressionStatement	 
>364	AssignmentExpr	iy = 0
>365	PrimaryExpression	0
>366	Identifier	iy
>367	ExpressionStatement	 
>368	AssignmentExpr	ix = 0
>369	PrimaryExpression	0
>370	Identifier	ix
>371	CompoundStatement	 
>372	ForStatement	for ( ; i < nn ; i ++ )
>373	ExpressionStatement	 
>374	AssignmentExpr	stemp += sx [ i ] * sy [ i ]
>375	MultiplicativeExpression	sx [ i ] * sy [ i ]
>376	ArrayIndexing	sy [ i ]
>377	Identifier	i
>378	Identifier	sy
>379	ArrayIndexing	sx [ i ]
>380	Identifier	i
>381	Identifier	sx
>382	Identifier	stemp
>383	IncDecOp	 
>384	IncDec	++
>385	Identifier	i
>386	Condition	 
>387	RelationalExpression	i < nn
>388	Identifier	nn
>389	Identifier	i
>390	ForStatement	for ( i = 0 ; i < m ; i += 5 )
>391	ExpressionStatement	 
>392	AssignmentExpr	stemp += sx [ i ] * sy [ i ] + sx [ i + 1 ] * sy [ i + 1 ] + sx [ i + 2 ] * sy [ i + 2 ] + sx [ i + \
>393	AdditiveExpression	sx [ i ] * sy [ i ] + sx [ i + 1 ] * sy [ i + 1 ] + sx [ i + 2 ] * sy [ i + 2 ] + sx [ i + 3 ] * sy [ \
>394	AdditiveExpression	sx [ i + 1 ] * sy [ i + 1 ] + sx [ i + 2 ] * sy [ i + 2 ] + sx [ i + 3 ] * sy [ i + 3 ] + sx [ i + 4 ] * \
>395	AdditiveExpression	sx [ i + 2 ] * sy [ i + 2 ] + sx [ i + 3 ] * sy [ i + 3 ] + sx [ i + 4 ] * sy [ i + 4 ]
>396	AdditiveExpression	sx [ i + 3 ] * sy [ i + 3 ] + sx [ i + 4 ] * sy [ i + 4 ]
>397	MultiplicativeExpression	sx [ i + 4 ] * sy [ i + 4 ]
>398	ArrayIndexing	sy [ i + 4 ]
>399	AdditiveExpression	i + 4
>400	PrimaryExpression	4
>401	Identifier	i
>402	Identifier	sy
>403	ArrayIndexing	sx [ i + 4 ]
>404	AdditiveExpression	i + 4
>405	PrimaryExpression	4
>406	Identifier	i
>407	Identifier	sx
>408	MultiplicativeExpression	sx [ i + 3 ] * sy [ i + 3 ]
>409	ArrayIndexing	sy [ i + 3 ]
>410	AdditiveExpression	i + 3
>411	PrimaryExpression	3
>412	Identifier	i
>413	Identifier	sy
>414	ArrayIndexing	sx [ i + 3 ]
>415	AdditiveExpression	i + 3
>416	PrimaryExpression	3
>417	Identifier	i
>418	Identifier	sx
>419	MultiplicativeExpression	sx [ i + 2 ] * sy [ i + 2 ]
>420	ArrayIndexing	sy [ i + 2 ]
>421	AdditiveExpression	i + 2
>422	PrimaryExpression	2
>423	Identifier	i
>424	Identifier	sy
>425	ArrayIndexing	sx [ i + 2 ]
>426	AdditiveExpression	i + 2
>427	PrimaryExpression	2
>428	Identifier	i
>429	Identifier	sx
>430	MultiplicativeExpression	sx [ i + 1 ] * sy [ i + 1 ]
>431	ArrayIndexing	sy [ i + 1 ]
>432	AdditiveExpression	i + 1
>433	PrimaryExpression	1
>434	Identifier	i
>435	Identifier	sy
>436	ArrayIndexing	sx [ i + 1 ]
>437	AdditiveExpression	i + 1
>438	PrimaryExpression	1
>439	Identifier	i
>440	Identifier	sx
>441	MultiplicativeExpression	sx [ i ] * sy [ i ]
>442	ArrayIndexing	sy [ i ]
>443	Identifier	i
>444	Identifier	sy
>445	ArrayIndexing	sx [ i ]
>446	Identifier	i
>447	Identifier	sx
>448	Identifier	stemp
>449	AssignmentExpr	 
>450	PrimaryExpression	5
>451	Identifier	i
>452	Condition	 
>453	RelationalExpression	i < m
>454	Identifier	m
>455	Identifier	i
>456	ForInit	 
>457	AssignmentExpr	i = 0
>458	PrimaryExpression	0
>459	Identifier	i
>460	ExpressionStatement	 
>461	AssignmentExpr	m = nn - 4
>462	AdditiveExpression	nn - 4
>463	PrimaryExpression	4
>464	Identifier	nn
>465	Identifier	m
>466	Condition	 
>467	AndExpression	iincx == 1 && iincy == 1
>468	EqualityExpression	iincy == 1
>469	PrimaryExpression	1
>470	Identifier	iincy
>471	EqualityExpression	iincx == 1
>472	PrimaryExpression	1
>473	Identifier	iincx
>474	Condition	 
>475	RelationalExpression	nn > 0
>476	PrimaryExpression	0
>477	Identifier	nn
>478	IdentifierDeclStatement	 
>479	IdentifierDecl	iy
>480	Identifier	iy
>481	IdentifierDeclType	long
>482	IdentifierDecl	ix
>483	Identifier	ix
>484	IdentifierDeclType	long
>485	IdentifierDeclStatement	 
>486	IdentifierDecl	stemp = 0.0f
>487	AssignmentExpr	stemp = 0.0f
>488	PrimaryExpression	0.0f
>489	Identifier	stemp
>490	Identifier	stemp
>491	IdentifierDeclType	float
>492	IdentifierDeclStatement	 
>493	IdentifierDecl	iincy = * incy
>494	AssignmentExpr	iincy = * incy
>495	UnaryOp	* incy
>496	Identifier	incy
>497	UnaryOperator	*
>498	Identifier	iincy
>499	Identifier	iincy
>500	IdentifierDeclType	long
>501	IdentifierDecl	iincx = * incx
>502	AssignmentExpr	iincx = * incx
>503	UnaryOp	* incx
>504	Identifier	incx
>505	UnaryOperator	*
>506	Identifier	iincx
>507	Identifier	iincx
>508	IdentifierDeclType	long
>509	IdentifierDecl	nn = * n
>510	AssignmentExpr	nn = * n
>511	UnaryOp	* n
>512	Identifier	n
>513	UnaryOperator	*
>514	Identifier	nn
>515	Identifier	nn
>516	IdentifierDeclType	long
>517	IdentifierDecl	m
>518	Identifier	m
>519	IdentifierDeclType	long
>520	IdentifierDecl	i
>521	Identifier	i
>522	IdentifierDeclType	long
>547	FunctionDef	daxpy_ (int * n , float * sa , float * sx , int * incx , float * sy , int * incy)
>548	ParameterList	int * n , float * sa , float * sx , int * incx , float * sy , int * incy
>549	Parameter	 
>550	Identifier	incy
>551	ParameterType	int *
>552	Parameter	 
>553	Identifier	sy
>554	ParameterType	float *
>555	Parameter	 
>556	Identifier	incx
>557	ParameterType	int *
>558	Parameter	 
>559	Identifier	sx
>560	ParameterType	float *
>561	Parameter	 
>562	Identifier	sa
>563	ParameterType	float *
>564	Parameter	 
>565	Identifier	n
>566	ParameterType	int *
>567	ReturnType	int
>568	CompoundStatement	 
>569	ReturnStatement	 
>570	PrimaryExpression	0
>571	IfStatement	if ( nn > 0 && ssa != 0.0f )
>572	CompoundStatement	 
>573	IfStatement	if ( iincx == 1 && iincy == 1 )
>574	ElseStatement	else
>575	CompoundStatement	 
>576	ForStatement	for ( i = 0 ; i < nn ; i ++ )
>577	CompoundStatement	 
>578	ExpressionStatement	 
>579	AssignmentExpr	iy += iincy
>580	Identifier	iincy
>581	Identifier	iy
>582	ExpressionStatement	 
>583	AssignmentExpr	ix += iincx
>584	Identifier	iincx
>585	Identifier	ix
>586	ExpressionStatement	 
>587	AssignmentExpr	sy [ iy ] += ssa * sx [ ix ]
>588	MultiplicativeExpression	ssa * sx [ ix ]
>589	ArrayIndexing	sx [ ix ]
>590	Identifier	ix
>591	Identifier	sx
>592	Identifier	ssa
>593	ArrayIndexing	sy [ iy ]
>594	Identifier	iy
>595	Identifier	sy
>596	IncDecOp	 
>597	IncDec	++
>598	Identifier	i
>599	Condition	 
>600	RelationalExpression	i < nn
>601	Identifier	nn
>602	Identifier	i
>603	ForInit	 
>604	AssignmentExpr	i = 0
>605	PrimaryExpression	0
>606	Identifier	i
>607	ExpressionStatement	 
>608	AssignmentExpr	iy = iincy >= 0 ? 0 
>609	ConditionalExpression	iincy >= 0 ? 0 
>610	MultiplicativeExpression	( 1 - nn ) * iincy
>611	Identifier	iincy
>612	AdditiveExpression	1 - nn
>613	Identifier	nn
>614	PrimaryExpression	1
>615	PrimaryExpression	0
>616	Condition	iincy >= 0
>617	RelationalExpression	iincy >= 0
>618	PrimaryExpression	0
>619	Identifier	iincy
>620	Identifier	iy
>621	ExpressionStatement	 
>622	AssignmentExpr	ix = iincx >= 0 ? 0 
>623	ConditionalExpression	iincx >= 0 ? 0 
>624	MultiplicativeExpression	( 1 - nn ) * iincx
>625	Identifier	iincx
>626	AdditiveExpression	1 - nn
>627	Identifier	nn
>628	PrimaryExpression	1
>629	PrimaryExpression	0
>630	Condition	iincx >= 0
>631	RelationalExpression	iincx >= 0
>632	PrimaryExpression	0
>633	Identifier	iincx
>634	Identifier	ix
>635	CompoundStatement	 
>636	ForStatement	for ( ; i < nn ; ++ i )
>637	ExpressionStatement	 
>638	AssignmentExpr	sy [ i ] += ssa * sx [ i ]
>639	MultiplicativeExpression	ssa * sx [ i ]
>640	ArrayIndexing	sx [ i ]
>641	Identifier	i
>642	Identifier	sx
>643	Identifier	ssa
>644	ArrayIndexing	sy [ i ]
>645	Identifier	i
>646	Identifier	sy
>647	UnaryExpression	 
>648	Identifier	i
>649	IncDec	++
>650	Condition	 
>651	RelationalExpression	i < nn
>652	Identifier	nn
>653	Identifier	i
>654	ForStatement	for ( i = 0 ; i < m ; i += 4 )
>655	CompoundStatement	 
>656	ExpressionStatement	 
>657	AssignmentExpr	sy [ i + 3 ] += ssa * sx [ i + 3 ]
>658	MultiplicativeExpression	ssa * sx [ i + 3 ]
>659	ArrayIndexing	sx [ i + 3 ]
>660	AdditiveExpression	i + 3
>661	PrimaryExpression	3
>662	Identifier	i
>663	Identifier	sx
>664	Identifier	ssa
>665	ArrayIndexing	sy [ i + 3 ]
>666	AdditiveExpression	i + 3
>667	PrimaryExpression	3
>668	Identifier	i
>669	Identifier	sy
>670	ExpressionStatement	 
>671	AssignmentExpr	sy [ i + 2 ] += ssa * sx [ i + 2 ]
>672	MultiplicativeExpression	ssa * sx [ i + 2 ]
>673	ArrayIndexing	sx [ i + 2 ]
>674	AdditiveExpression	i + 2
>675	PrimaryExpression	2
>676	Identifier	i
>677	Identifier	sx
>678	Identifier	ssa
>679	ArrayIndexing	sy [ i + 2 ]
>680	AdditiveExpression	i + 2
>681	PrimaryExpression	2
>682	Identifier	i
>683	Identifier	sy
>684	ExpressionStatement	 
>685	AssignmentExpr	sy [ i + 1 ] += ssa * sx [ i + 1 ]
>686	MultiplicativeExpression	ssa * sx [ i + 1 ]
>687	ArrayIndexing	sx [ i + 1 ]
>688	AdditiveExpression	i + 1
>689	PrimaryExpression	1
>690	Identifier	i
>691	Identifier	sx
>692	Identifier	ssa
>693	ArrayIndexing	sy [ i + 1 ]
>694	AdditiveExpression	i + 1
>695	PrimaryExpression	1
>696	Identifier	i
>697	Identifier	sy
>698	ExpressionStatement	 
>699	AssignmentExpr	sy [ i ] += ssa * sx [ i ]
>700	MultiplicativeExpression	ssa * sx [ i ]
>701	ArrayIndexing	sx [ i ]
>702	Identifier	i
>703	Identifier	sx
>704	Identifier	ssa
>705	ArrayIndexing	sy [ i ]
>706	Identifier	i
>707	Identifier	sy
>708	AssignmentExpr	 
>709	PrimaryExpression	4
>710	Identifier	i
>711	Condition	 
>712	RelationalExpression	i < m
>713	Identifier	m
>714	Identifier	i
>715	ForInit	 
>716	AssignmentExpr	i = 0
>717	PrimaryExpression	0
>718	Identifier	i
>719	ExpressionStatement	 
>720	AssignmentExpr	m = nn - 3
>721	AdditiveExpression	nn - 3
>722	PrimaryExpression	3
>723	Identifier	nn
>724	Identifier	m
>725	Condition	 
>726	AndExpression	iincx == 1 && iincy == 1
>727	EqualityExpression	iincy == 1
>728	PrimaryExpression	1
>729	Identifier	iincy
>730	EqualityExpression	iincx == 1
>731	PrimaryExpression	1
>732	Identifier	iincx
>733	Condition	 
>734	AndExpression	nn > 0 && ssa != 0.0f
>735	EqualityExpression	ssa != 0.0f
>736	PrimaryExpression	0.0f
>737	Identifier	ssa
>738	RelationalExpression	nn > 0
>739	PrimaryExpression	0
>740	Identifier	nn
>741	IdentifierDeclStatement	 
>742	IdentifierDecl	ssa = * sa
>743	AssignmentExpr	ssa = * sa
>744	UnaryOp	* sa
>745	Identifier	sa
>746	UnaryOperator	*
>747	Identifier	ssa
>748	Identifier	ssa
>749	IdentifierDeclType	float
>750	Statement	 
>751	IdentifierDeclStatement	 
>752	IdentifierDecl	iincy = * incy
>753	AssignmentExpr	iincy = * incy
>754	UnaryOp	* incy
>755	Identifier	incy
>756	UnaryOperator	*
>757	Identifier	iincy
>758	Identifier	iincy
>759	IdentifierDeclType	long
>760	IdentifierDecl	iincx = * incx
>761	AssignmentExpr	iincx = * incx
>762	UnaryOp	* incx
>763	Identifier	incx
>764	UnaryOperator	*
>765	Identifier	iincx
>766	Identifier	iincx
>767	IdentifierDeclType	long
>768	IdentifierDecl	nn = * n
>769	AssignmentExpr	nn = * n
>770	UnaryOp	* n
>771	Identifier	n
>772	UnaryOperator	*
>773	Identifier	nn
>774	Identifier	nn
>775	IdentifierDeclType	long
>776	IdentifierDecl	iy
>777	Identifier	iy
>778	IdentifierDeclType	long
>779	IdentifierDecl	ix
>780	Identifier	ix
>781	IdentifierDeclType	long
>782	IdentifierDecl	m
>783	Identifier	m
>784	IdentifierDeclType	long
>785	IdentifierDecl	i
>786	Identifier	i
>787	IdentifierDeclType	long
>814	FunctionDef	dscal_ (int * n , float * sa , float * sx , int * incx)
>815	ParameterList	int * n , float * sa , float * sx , int * incx
>816	Parameter	 
>817	Identifier	incx
>818	ParameterType	int *
>819	Parameter	 
>820	Identifier	sx
>821	ParameterType	float *
>822	Parameter	 
>823	Identifier	sa
>824	ParameterType	float *
>825	Parameter	 
>826	Identifier	n
>827	ParameterType	int *
>828	ReturnType	int
>829	CompoundStatement	 
>830	ReturnStatement	 
>831	PrimaryExpression	0
>832	IfStatement	if ( nn > 0 && iincx > 0 )
>833	CompoundStatement	 
>834	IfStatement	if ( iincx == 1 )
>835	ElseStatement	else
>836	CompoundStatement	 
>837	ForStatement	for ( i = 0 ; i < nincx ; i += iincx )
>838	ExpressionStatement	 
>839	AssignmentExpr	sx [ i ] = ssa * sx [ i ]
>840	MultiplicativeExpression	ssa * sx [ i ]
>841	ArrayIndexing	sx [ i ]
>842	Identifier	i
>843	Identifier	sx
>844	Identifier	ssa
>845	ArrayIndexing	sx [ i ]
>846	Identifier	i
>847	Identifier	sx
>848	AssignmentExpr	 
>849	Identifier	iincx
>850	Identifier	i
>851	Condition	 
>852	RelationalExpression	i < nincx
>853	Identifier	nincx
>854	Identifier	i
>855	ForInit	 
>856	AssignmentExpr	i = 0
>857	PrimaryExpression	0
>858	Identifier	i
>859	ExpressionStatement	 
>860	AssignmentExpr	nincx = nn * iincx
>861	MultiplicativeExpression	nn * iincx
>862	Identifier	iincx
>863	Identifier	nn
>864	Identifier	nincx
>865	CompoundStatement	 
>866	ForStatement	for ( ; i < nn ; ++ i )
>867	ExpressionStatement	 
>868	AssignmentExpr	sx [ i ] = ssa * sx [ i ]
>869	MultiplicativeExpression	ssa * sx [ i ]
>870	ArrayIndexing	sx [ i ]
>871	Identifier	i
>872	Identifier	sx
>873	Identifier	ssa
>874	ArrayIndexing	sx [ i ]
>875	Identifier	i
>876	Identifier	sx
>877	UnaryExpression	 
>878	Identifier	i
>879	IncDec	++
>880	Condition	 
>881	RelationalExpression	i < nn
>882	Identifier	nn
>883	Identifier	i
>884	ForStatement	for ( i = 0 ; i < m ; i += 5 )
>885	CompoundStatement	 
>886	ExpressionStatement	 
>887	AssignmentExpr	sx [ i + 4 ] = ssa * sx [ i + 4 ]
>888	MultiplicativeExpression	ssa * sx [ i + 4 ]
>889	ArrayIndexing	sx [ i + 4 ]
>890	AdditiveExpression	i + 4
>891	PrimaryExpression	4
>892	Identifier	i
>893	Identifier	sx
>894	Identifier	ssa
>895	ArrayIndexing	sx [ i + 4 ]
>896	AdditiveExpression	i + 4
>897	PrimaryExpression	4
>898	Identifier	i
>899	Identifier	sx
>900	ExpressionStatement	 
>901	AssignmentExpr	sx [ i + 3 ] = ssa * sx [ i + 3 ]
>902	MultiplicativeExpression	ssa * sx [ i + 3 ]
>903	ArrayIndexing	sx [ i + 3 ]
>904	AdditiveExpression	i + 3
>905	PrimaryExpression	3
>906	Identifier	i
>907	Identifier	sx
>908	Identifier	ssa
>909	ArrayIndexing	sx [ i + 3 ]
>910	AdditiveExpression	i + 3
>911	PrimaryExpression	3
>912	Identifier	i
>913	Identifier	sx
>914	ExpressionStatement	 
>915	AssignmentExpr	sx [ i + 2 ] = ssa * sx [ i + 2 ]
>916	MultiplicativeExpression	ssa * sx [ i + 2 ]
>917	ArrayIndexing	sx [ i + 2 ]
>918	AdditiveExpression	i + 2
>919	PrimaryExpression	2
>920	Identifier	i
>921	Identifier	sx
>922	Identifier	ssa
>923	ArrayIndexing	sx [ i + 2 ]
>924	AdditiveExpression	i + 2
>925	PrimaryExpression	2
>926	Identifier	i
>927	Identifier	sx
>928	ExpressionStatement	 
>929	AssignmentExpr	sx [ i + 1 ] = ssa * sx [ i + 1 ]
>930	MultiplicativeExpression	ssa * sx [ i + 1 ]
>931	ArrayIndexing	sx [ i + 1 ]
>932	AdditiveExpression	i + 1
>933	PrimaryExpression	1
>934	Identifier	i
>935	Identifier	sx
>936	Identifier	ssa
>937	ArrayIndexing	sx [ i + 1 ]
>938	AdditiveExpression	i + 1
>939	PrimaryExpression	1
>940	Identifier	i
>941	Identifier	sx
>942	ExpressionStatement	 
>943	AssignmentExpr	sx [ i ] = ssa * sx [ i ]
>944	MultiplicativeExpression	ssa * sx [ i ]
>945	ArrayIndexing	sx [ i ]
>946	Identifier	i
>947	Identifier	sx
>948	Identifier	ssa
>949	ArrayIndexing	sx [ i ]
>950	Identifier	i
>951	Identifier	sx
>952	AssignmentExpr	 
>953	PrimaryExpression	5
>954	Identifier	i
>955	Condition	 
>956	RelationalExpression	i < m
>957	Identifier	m
>958	Identifier	i
>959	ForInit	 
>960	AssignmentExpr	i = 0
>961	PrimaryExpression	0
>962	Identifier	i
>963	ExpressionStatement	 
>964	AssignmentExpr	m = nn - 4
>965	AdditiveExpression	nn - 4
>966	PrimaryExpression	4
>967	Identifier	nn
>968	Identifier	m
>969	Condition	 
>970	EqualityExpression	iincx == 1
>971	PrimaryExpression	1
>972	Identifier	iincx
>973	Condition	 
>974	AndExpression	nn > 0 && iincx > 0
>975	RelationalExpression	iincx > 0
>976	PrimaryExpression	0
>977	Identifier	iincx
>978	RelationalExpression	nn > 0
>979	PrimaryExpression	0
>980	Identifier	nn
>981	IdentifierDeclStatement	 
>982	IdentifierDecl	ssa = * sa
>983	AssignmentExpr	ssa = * sa
>984	UnaryOp	* sa
>985	Identifier	sa
>986	UnaryOperator	*
>987	Identifier	ssa
>988	Identifier	ssa
>989	IdentifierDeclType	float
>990	IdentifierDeclStatement	 
>991	IdentifierDecl	iincx = * incx
>992	AssignmentExpr	iincx = * incx
>993	UnaryOp	* incx
>994	Identifier	incx
>995	UnaryOperator	*
>996	Identifier	iincx
>997	Identifier	iincx
>998	IdentifierDeclType	long
>999	IdentifierDecl	nn = * n
>1000	AssignmentExpr	nn = * n
>1001	UnaryOp	* n
>1002	Identifier	n
>1003	UnaryOperator	*
>1004	Identifier	nn
>1005	Identifier	nn
>1006	IdentifierDeclType	long
>1007	IdentifierDecl	nincx
>1008	Identifier	nincx
>1009	IdentifierDeclType	long
>1010	IdentifierDecl	m
>1011	Identifier	m
>1012	IdentifierDeclType	long
>1013	IdentifierDecl	i
>1014	Identifier	i
>1015	IdentifierDeclType	long
>1034	FunctionDef	TRON 
>1035	ParameterList	const function * fun_obj , float eps , int max_iter
>1036	Parameter	 
>1037	Identifier	max_iter
>1038	ParameterType	int
>1039	Parameter	 
>1040	Identifier	eps
>1041	ParameterType	float
>1042	Parameter	 
>1043	Identifier	fun_obj
>1044	ParameterType	const function *
>1045	CompoundStatement	 
>1046	ExpressionStatement	 
>1047	AssignmentExpr	this -> max_iter = max_iter
>1048	Identifier	max_iter
>1049	PtrMemberAccess	this -> max_iter
>1050	Identifier	max_iter
>1051	Identifier	this
>1052	ExpressionStatement	 
>1053	AssignmentExpr	this -> eps = eps
>1054	Identifier	eps
>1055	PtrMemberAccess	this -> eps
>1056	Identifier	eps
>1057	Identifier	this
>1058	ExpressionStatement	 
>1059	Identifier	fun_obj
>1060	Statement	 
>1061	Statement	 
>1062	Statement	 
>1063	Statement	 
>1064	Statement	 
>1065	Statement	 
>1066	Statement	 
>1067	Statement	 
>1068	Statement	 
>1079	FunctionDef	TRON 
>1080	ParameterList	 
>1081	CompoundStatement	 
>1085	FunctionDef	TRON 
>1086	ParameterList	float * w
>1087	Parameter	 
>1088	Identifier	w
>1089	ParameterType	float *
>1090	ReturnType	void
>1091	CompoundStatement	 
>1092	ExpressionStatement	 
>1093	Identifier	s
>1094	Statement	 
>1095	Statement	 
>1096	Statement	 
>1097	ExpressionStatement	 
>1098	Identifier	w_new
>1099	Statement	 
>1100	Statement	 
>1101	Statement	 
>1102	ExpressionStatement	 
>1103	Identifier	r
>1104	Statement	 
>1105	Statement	 
>1106	Statement	 
>1107	ExpressionStatement	 
>1108	Identifier	g
>1109	Statement	 
>1110	Statement	 
>1111	Statement	 
>1112	WhileStatement	while ( iter <= max_iter && search )
>1113	CompoundStatement	 
>1114	IfStatement	if ( fabs ( actred ) <= 1.0e-12f * fabs ( f ) && fabs ( prered ) <= 1.0e-12f * fabs ( f ) )
>1115	CompoundStatement	 
>1116	BreakStatement	 
>1117	Condition	 
>1118	AndExpression	fabs ( actred ) <= 1.0e-12f * fabs ( f ) && fabs ( prered ) <= 1.0e-12f * fabs ( f )
>1119	RelationalExpression	fabs ( prered ) <= 1.0e-12f * fabs ( f )
>1120	MultiplicativeExpression	1.0e-12f * fabs ( f )
>1121	CallExpression	fabs ( f )
>1122	ArgumentList	f
>1123	Argument	f
>1124	Identifier	f
>1125	Callee	fabs
>1126	Identifier	fabs
>1127	PrimaryExpression	1.0e-12f
>1128	CallExpression	fabs ( prered )
>1129	ArgumentList	prered
>1130	Argument	prered
>1131	Identifier	prered
>1132	Callee	fabs
>1133	Identifier	fabs
>1134	RelationalExpression	fabs ( actred ) <= 1.0e-12f * fabs ( f )
>1135	MultiplicativeExpression	1.0e-12f * fabs ( f )
>1136	CallExpression	fabs ( f )
>1137	ArgumentList	f
>1138	Argument	f
>1139	Identifier	f
>1140	Callee	fabs
>1141	Identifier	fabs
>1142	PrimaryExpression	1.0e-12f
>1143	CallExpression	fabs ( actred )
>1144	ArgumentList	actred
>1145	Argument	actred
>1146	Identifier	actred
>1147	Callee	fabs
>1148	Identifier	fabs
>1149	IfStatement	if ( fabs ( actred ) <= 0 && fabs ( prered ) <= 0 )
>1150	CompoundStatement	 
>1151	BreakStatement	 
>1152	Condition	 
>1153	AndExpression	fabs ( actred ) <= 0 && fabs ( prered ) <= 0
>1154	RelationalExpression	fabs ( prered ) <= 0
>1155	PrimaryExpression	0
>1156	CallExpression	fabs ( prered )
>1157	ArgumentList	prered
>1158	Argument	prered
>1159	Identifier	prered
>1160	Callee	fabs
>1161	Identifier	fabs
>1162	RelationalExpression	fabs ( actred ) <= 0
>1163	PrimaryExpression	0
>1164	CallExpression	fabs ( actred )
>1165	ArgumentList	actred
>1166	Argument	actred
>1167	Identifier	actred
>1168	Callee	fabs
>1169	Identifier	fabs
>1170	IfStatement	if ( f < 1.0e-32f )
>1171	CompoundStatement	 
>1172	BreakStatement	 
>1173	Condition	 
>1174	RelationalExpression	f < 1.0e-32f
>1175	PrimaryExpression	1.0e-32f
>1176	Identifier	f
>1177	IfStatement	if ( actred > eta0 * prered )
>1178	CompoundStatement	 
>1179	IfStatement	if ( gnorm < eps * gnorm1 )
>1180	BreakStatement	 
>1181	Condition	 
>1182	RelationalExpression	gnorm < eps * gnorm1
>1183	MultiplicativeExpression	eps * gnorm1
>1184	Identifier	gnorm1
>1185	Identifier	eps
>1186	Identifier	gnorm
>1187	ExpressionStatement	 
>1188	AssignmentExpr	gnorm = dnrm2_ ( & n , g , & inc )
>1189	CallExpression	dnrm2_ ( & n , g , & inc )
>1190	ArgumentList	& n
>1191	Argument	& inc
>1192	UnaryOp	& inc
>1193	Identifier	inc
>1194	UnaryOperator	&
>1195	Argument	g
>1196	Identifier	g
>1197	Argument	& n
>1198	UnaryOp	& n
>1199	Identifier	n
>1200	UnaryOperator	&
>1201	Callee	dnrm2_
>1202	Identifier	dnrm2_
>1203	Identifier	gnorm
>1204	ExpressionStatement	 
>1205	CallExpression	fun_obj -> grad ( w , g )
>1206	ArgumentList	w
>1207	Argument	g
>1208	Identifier	g
>1209	Argument	w
>1210	Identifier	w
>1211	Callee	fun_obj -> grad
>1212	PtrMemberAccess	fun_obj -> grad
>1213	Identifier	grad
>1214	Identifier	fun_obj
>1215	ExpressionStatement	 
>1216	AssignmentExpr	f = fnew
>1217	Identifier	fnew
>1218	Identifier	f
>1219	ExpressionStatement	 
>1220	CallExpression	memcpy ( w , w_new , sizeof ( float ) * n )
>1221	ArgumentList	w
>1222	Argument	sizeof ( float ) * n
>1223	MultiplicativeExpression	sizeof ( float ) * n
>1224	Identifier	n
>1225	SizeofExpr	sizeof ( float )
>1226	SizeofOperand	float
>1227	Sizeof	sizeof
>1228	Argument	w_new
>1229	Identifier	w_new
>1230	Argument	w
>1231	Identifier	w
>1232	Callee	memcpy
>1233	Identifier	memcpy
>1234	ExpressionStatement	 
>1235	IncDecOp	iter ++
>1236	IncDec	++
>1237	Identifier	iter
>1238	Condition	 
>1239	RelationalExpression	actred > eta0 * prered
>1240	MultiplicativeExpression	eta0 * prered
>1241	Identifier	prered
>1242	Identifier	eta0
>1243	Identifier	actred
>1244	IfStatement	if ( actred < eta0 * prered )
>1245	ElseStatement	else
>1246	IfStatement	if ( actred < eta1 * prered )
>1247	ElseStatement	else
>1248	IfStatement	if ( actred < eta2 * prered )
>1249	ElseStatement	else
>1250	ExpressionStatement	 
>1251	AssignmentExpr	delta = max ( delta , min ( alpha * snorm , sigma3 * delta ) )
>1252	CallExpression	max ( delta , min ( alpha * snorm , sigma3 * delta ) )
>1253	ArgumentList	delta
>1254	Argument	min ( alpha * snorm , sigma3 * delta )
>1255	CallExpression	min ( alpha * snorm , sigma3 * delta )
>1256	ArgumentList	alpha * snorm
>1257	Argument	sigma3 * delta
>1258	MultiplicativeExpression	sigma3 * delta
>1259	Identifier	delta
>1260	Identifier	sigma3
>1261	Argument	alpha * snorm
>1262	MultiplicativeExpression	alpha * snorm
>1263	Identifier	snorm
>1264	Identifier	alpha
>1265	Callee	min
>1266	Identifier	min
>1267	Argument	delta
>1268	Identifier	delta
>1269	Callee	max
>1270	Identifier	max
>1271	Identifier	delta
>1272	ExpressionStatement	 
>1273	AssignmentExpr	delta = max ( sigma1 * delta , min ( alpha * snorm , sigma3 * delta ) )
>1274	CallExpression	max ( sigma1 * delta , min ( alpha * snorm , sigma3 * delta ) )
>1275	ArgumentList	sigma1 * delta
>1276	Argument	min ( alpha * snorm , sigma3 * delta )
>1277	CallExpression	min ( alpha * snorm , sigma3 * delta )
>1278	ArgumentList	alpha * snorm
>1279	Argument	sigma3 * delta
>1280	MultiplicativeExpression	sigma3 * delta
>1281	Identifier	delta
>1282	Identifier	sigma3
>1283	Argument	alpha * snorm
>1284	MultiplicativeExpression	alpha * snorm
>1285	Identifier	snorm
>1286	Identifier	alpha
>1287	Callee	min
>1288	Identifier	min
>1289	Argument	sigma1 * delta
>1290	MultiplicativeExpression	sigma1 * delta
>1291	Identifier	delta
>1292	Identifier	sigma1
>1293	Callee	max
>1294	Identifier	max
>1295	Identifier	delta
>1296	Condition	 
>1297	RelationalExpression	actred < eta2 * prered
>1298	MultiplicativeExpression	eta2 * prered
>1299	Identifier	prered
>1300	Identifier	eta2
>1301	Identifier	actred
>1302	ExpressionStatement	 
>1303	AssignmentExpr	delta = max ( sigma1 * delta , min ( alpha * snorm , sigma2 * delta ) )
>1304	CallExpression	max ( sigma1 * delta , min ( alpha * snorm , sigma2 * delta ) )
>1305	ArgumentList	sigma1 * delta
>1306	Argument	min ( alpha * snorm , sigma2 * delta )
>1307	CallExpression	min ( alpha * snorm , sigma2 * delta )
>1308	ArgumentList	alpha * snorm
>1309	Argument	sigma2 * delta
>1310	MultiplicativeExpression	sigma2 * delta
>1311	Identifier	delta
>1312	Identifier	sigma2
>1313	Argument	alpha * snorm
>1314	MultiplicativeExpression	alpha * snorm
>1315	Identifier	snorm
>1316	Identifier	alpha
>1317	Callee	min
>1318	Identifier	min
>1319	Argument	sigma1 * delta
>1320	MultiplicativeExpression	sigma1 * delta
>1321	Identifier	delta
>1322	Identifier	sigma1
>1323	Callee	max
>1324	Identifier	max
>1325	Identifier	delta
>1326	Condition	 
>1327	RelationalExpression	actred < eta1 * prered
>1328	MultiplicativeExpression	eta1 * prered
>1329	Identifier	prered
>1330	Identifier	eta1
>1331	Identifier	actred
>1332	ExpressionStatement	 
>1333	AssignmentExpr	delta = min ( max ( alpha , sigma1 ) * snorm , sigma2 * delta )
>1334	CallExpression	min ( max ( alpha , sigma1 ) * snorm , sigma2 * delta )
>1335	ArgumentList	max ( alpha , sigma1 ) * snorm
>1336	Argument	sigma2 * delta
>1337	MultiplicativeExpression	sigma2 * delta
>1338	Identifier	delta
>1339	Identifier	sigma2
>1340	Argument	max ( alpha , sigma1 ) * snorm
>1341	MultiplicativeExpression	max ( alpha , sigma1 ) * snorm
>1342	Identifier	snorm
>1343	CallExpression	max ( alpha , sigma1 )
>1344	ArgumentList	alpha
>1345	Argument	sigma1
>1346	Identifier	sigma1
>1347	Argument	alpha
>1348	Identifier	alpha
>1349	Callee	max
>1350	Identifier	max
>1351	Callee	min
>1352	Identifier	min
>1353	Identifier	delta
>1354	Condition	 
>1355	RelationalExpression	actred < eta0 * prered
>1356	MultiplicativeExpression	eta0 * prered
>1357	Identifier	prered
>1358	Identifier	eta0
>1359	Identifier	actred
>1360	IfStatement	if ( fnew - f - gs <= 0.0f )
>1361	ElseStatement	else
>1362	ExpressionStatement	 
>1363	AssignmentExpr	alpha = max ( sigma1 , ( float ) - 0.5f * ( gs / ( fnew - f - gs ) ) )
>1364	CallExpression	max ( sigma1 , ( float ) - 0.5f * ( gs / ( fnew - f - gs ) ) )
>1365	ArgumentList	sigma1
>1366	Argument	( float ) - 0.5f * ( gs / ( fnew - f - gs ) )
>1367	MultiplicativeExpression	( float ) - 0.5f * ( gs / ( fnew - f - gs ) )
>1368	MultiplicativeExpression	gs / ( fnew - f - gs )
>1369	AdditiveExpression	fnew - f - gs
>1370	AdditiveExpression	f - gs
>1371	Identifier	gs
>1372	Identifier	f
>1373	Identifier	fnew
>1374	Identifier	gs
>1375	CastExpression	( float ) - 0.5f
>1376	UnaryOp	- 0.5f
>1377	PrimaryExpression	0.5f
>1378	UnaryOperator	-
>1379	CastTarget	float
>1380	Argument	sigma1
>1381	Identifier	sigma1
>1382	Callee	max
>1383	Identifier	max
>1384	Identifier	alpha
>1385	ExpressionStatement	 
>1386	AssignmentExpr	alpha = sigma3
>1387	Identifier	sigma3
>1388	Identifier	alpha
>1389	Condition	 
>1390	RelationalExpression	fnew - f - gs <= 0.0f
>1391	PrimaryExpression	0.0f
>1392	AdditiveExpression	fnew - f - gs
>1393	AdditiveExpression	f - gs
>1394	Identifier	gs
>1395	Identifier	f
>1396	Identifier	fnew
>1397	IfStatement	if ( iter == 1 )
>1398	ExpressionStatement	 
>1399	AssignmentExpr	delta = min ( delta , snorm )
>1400	CallExpression	min ( delta , snorm )
>1401	ArgumentList	delta
>1402	Argument	snorm
>1403	Identifier	snorm
>1404	Argument	delta
>1405	Identifier	delta
>1406	Callee	min
>1407	Identifier	min
>1408	Identifier	delta
>1409	Condition	 
>1410	EqualityExpression	iter == 1
>1411	PrimaryExpression	1
>1412	Identifier	iter
>1413	ExpressionStatement	 
>1414	AssignmentExpr	snorm = dnrm2_ ( & n , s , & inc )
>1415	CallExpression	dnrm2_ ( & n , s , & inc )
>1416	ArgumentList	& n
>1417	Argument	& inc
>1418	UnaryOp	& inc
>1419	Identifier	inc
>1420	UnaryOperator	&
>1421	Argument	s
>1422	Identifier	s
>1423	Argument	& n
>1424	UnaryOp	& n
>1425	Identifier	n
>1426	UnaryOperator	&
>1427	Callee	dnrm2_
>1428	Identifier	dnrm2_
>1429	Identifier	snorm
>1430	ExpressionStatement	 
>1431	AssignmentExpr	actred = f - fnew
>1432	AdditiveExpression	f - fnew
>1433	Identifier	fnew
>1434	Identifier	f
>1435	Identifier	actred
>1436	ExpressionStatement	 
>1437	AssignmentExpr	fnew = fun_obj -> fun ( w_new )
>1438	CallExpression	fun_obj -> fun ( w_new )
>1439	ArgumentList	w_new
>1440	Argument	w_new
>1441	Identifier	w_new
>1442	Callee	fun_obj -> fun
>1443	PtrMemberAccess	fun_obj -> fun
>1444	Identifier	fun
>1445	Identifier	fun_obj
>1446	Identifier	fnew
>1447	ExpressionStatement	 
>1448	AssignmentExpr	prered = - 0.5f * ( gs - ddot_ ( & n , s , & inc , r , & inc ) )
>1449	MultiplicativeExpression	- 0.5f * ( gs - ddot_ ( & n , s , & inc , r , & inc ) )
>1450	AdditiveExpression	gs - ddot_ ( & n , s , & inc , r , & inc )
>1451	CallExpression	ddot_ ( & n , s , & inc , r , & inc )
>1452	ArgumentList	& n
>1453	Argument	& inc
>1454	UnaryOp	& inc
>1455	Identifier	inc
>1456	UnaryOperator	&
>1457	Argument	r
>1458	Identifier	r
>1459	Argument	& inc
>1460	UnaryOp	& inc
>1461	Identifier	inc
>1462	UnaryOperator	&
>1463	Argument	s
>1464	Identifier	s
>1465	Argument	& n
>1466	UnaryOp	& n
>1467	Identifier	n
>1468	UnaryOperator	&
>1469	Callee	ddot_
>1470	Identifier	ddot_
>1471	Identifier	gs
>1472	UnaryOp	- 0.5f
>1473	PrimaryExpression	0.5f
>1474	UnaryOperator	-
>1475	Identifier	prered
>1476	ExpressionStatement	 
>1477	AssignmentExpr	gs = ddot_ ( & n , g , & inc , s , & inc )
>1478	CallExpression	ddot_ ( & n , g , & inc , s , & inc )
>1479	ArgumentList	& n
>1480	Argument	& inc
>1481	UnaryOp	& inc
>1482	Identifier	inc
>1483	UnaryOperator	&
>1484	Argument	s
>1485	Identifier	s
>1486	Argument	& inc
>1487	UnaryOp	& inc
>1488	Identifier	inc
>1489	UnaryOperator	&
>1490	Argument	g
>1491	Identifier	g
>1492	Argument	& n
>1493	UnaryOp	& n
>1494	Identifier	n
>1495	UnaryOperator	&
>1496	Callee	ddot_
>1497	Identifier	ddot_
>1498	Identifier	gs
>1499	ExpressionStatement	 
>1500	CallExpression	daxpy_ ( & n , & one , s , & inc , w_new , & inc )
>1501	ArgumentList	& n
>1502	Argument	& inc
>1503	UnaryOp	& inc
>1504	Identifier	inc
>1505	UnaryOperator	&
>1506	Argument	w_new
>1507	Identifier	w_new
>1508	Argument	& inc
>1509	UnaryOp	& inc
>1510	Identifier	inc
>1511	UnaryOperator	&
>1512	Argument	s
>1513	Identifier	s
>1514	Argument	& one
>1515	UnaryOp	& one
>1516	Identifier	one
>1517	UnaryOperator	&
>1518	Argument	& n
>1519	UnaryOp	& n
>1520	Identifier	n
>1521	UnaryOperator	&
>1522	Callee	daxpy_
>1523	Identifier	daxpy_
>1524	ExpressionStatement	 
>1525	CallExpression	memcpy ( w_new , w , sizeof ( float ) * n )
>1526	ArgumentList	w_new
>1527	Argument	sizeof ( float ) * n
>1528	MultiplicativeExpression	sizeof ( float ) * n
>1529	Identifier	n
>1530	SizeofExpr	sizeof ( float )
>1531	SizeofOperand	float
>1532	Sizeof	sizeof
>1533	Argument	w
>1534	Identifier	w
>1535	Argument	w_new
>1536	Identifier	w_new
>1537	Callee	memcpy
>1538	Identifier	memcpy
>1539	ExpressionStatement	 
>1540	AssignmentExpr	cg_iter = trcg ( delta , g , s , r )
>1541	CallExpression	trcg ( delta , g , s , r )
>1542	ArgumentList	delta
>1543	Argument	r
>1544	Identifier	r
>1545	Argument	s
>1546	Identifier	s
>1547	Argument	g
>1548	Identifier	g
>1549	Argument	delta
>1550	Identifier	delta
>1551	Callee	trcg
>1552	Identifier	trcg
>1553	Identifier	cg_iter
>1554	Condition	 
>1555	AndExpression	iter <= max_iter && search
>1556	Identifier	search
>1557	RelationalExpression	iter <= max_iter
>1558	Identifier	max_iter
>1559	Identifier	iter
>1560	ExpressionStatement	 
>1561	AssignmentExpr	iter = 1
>1562	PrimaryExpression	1
>1563	Identifier	iter
>1564	IfStatement	if ( gnorm1 < eps )
>1565	ExpressionStatement	 
>1566	AssignmentExpr	search = 0
>1567	PrimaryExpression	0
>1568	Identifier	search
>1569	Condition	 
>1570	RelationalExpression	gnorm1 < eps
>1571	Identifier	eps
>1572	Identifier	gnorm1
>1573	IdentifierDeclStatement	 
>1574	IdentifierDecl	gnorm = gnorm1
>1575	AssignmentExpr	gnorm = gnorm1
>1576	Identifier	gnorm1
>1577	Identifier	gnorm1
>1578	Identifier	gnorm
>1579	IdentifierDeclType	float
>1580	IdentifierDeclStatement	 
>1581	IdentifierDecl	gnorm1 = delta
>1582	AssignmentExpr	gnorm1 = delta
>1583	Identifier	delta
>1584	Identifier	delta
>1585	Identifier	gnorm1
>1586	IdentifierDeclType	float
>1587	ExpressionStatement	 
>1588	AssignmentExpr	delta = dnrm2_ ( & n , g , & inc )
>1589	CallExpression	dnrm2_ ( & n , g , & inc )
>1590	ArgumentList	& n
>1591	Argument	& inc
>1592	UnaryOp	& inc
>1593	Identifier	inc
>1594	UnaryOperator	&
>1595	Argument	g
>1596	Identifier	g
>1597	Argument	& n
>1598	UnaryOp	& n
>1599	Identifier	n
>1600	UnaryOperator	&
>1601	Callee	dnrm2_
>1602	Identifier	dnrm2_
>1603	Identifier	delta
>1604	ExpressionStatement	 
>1605	CallExpression	fun_obj -> grad ( w , g )
>1606	ArgumentList	w
>1607	Argument	g
>1608	Identifier	g
>1609	Argument	w
>1610	Identifier	w
>1611	Callee	fun_obj -> grad
>1612	PtrMemberAccess	fun_obj -> grad
>1613	Identifier	grad
>1614	Identifier	fun_obj
>1615	ExpressionStatement	 
>1616	AssignmentExpr	f = fun_obj -> fun ( w )
>1617	CallExpression	fun_obj -> fun ( w )
>1618	ArgumentList	w
>1619	Argument	w
>1620	Identifier	w
>1621	Callee	fun_obj -> fun
>1622	PtrMemberAccess	fun_obj -> fun
>1623	Identifier	fun
>1624	Identifier	fun_obj
>1625	Identifier	f
>1626	ForStatement	for ( i = 0 ; i < n ; i ++ )
>1627	ExpressionStatement	 
>1628	AssignmentExpr	w [ i ] = 0
>1629	PrimaryExpression	0
>1630	ArrayIndexing	w [ i ]
>1631	Identifier	i
>1632	Identifier	w
>1633	IncDecOp	 
>1634	IncDec	++
>1635	Identifier	i
>1636	Condition	 
>1637	RelationalExpression	i < n
>1638	Identifier	n
>1639	Identifier	i
>1640	ForInit	 
>1641	AssignmentExpr	i = 0
>1642	PrimaryExpression	0
>1643	Identifier	i
>1644	IdentifierDeclStatement	 
>1645	IdentifierDecl	* g = new float [ n ]
>1646	AssignmentExpr	* g = new float [ n ]
>1647	Identifier	n
>1648	Identifier	n
>1649	Identifier	g
>1650	IdentifierDeclType	float *
>1651	IdentifierDeclStatement	 
>1652	IdentifierDecl	* w_new = new float [ n ]
>1653	AssignmentExpr	* w_new = new float [ n ]
>1654	Identifier	n
>1655	Identifier	n
>1656	Identifier	w_new
>1657	IdentifierDeclType	float *
>1658	IdentifierDeclStatement	 
>1659	IdentifierDecl	* r = new float [ n ]
>1660	AssignmentExpr	* r = new float [ n ]
>1661	Identifier	n
>1662	Identifier	n
>1663	Identifier	r
>1664	IdentifierDeclType	float *
>1665	IdentifierDeclStatement	 
>1666	IdentifierDecl	* s = new float [ n ]
>1667	AssignmentExpr	* s = new float [ n ]
>1668	Identifier	n
>1669	Identifier	n
>1670	Identifier	s
>1671	IdentifierDeclType	float *
>1672	IdentifierDeclStatement	 
>1673	IdentifierDecl	inc = 1
>1674	AssignmentExpr	inc = 1
>1675	PrimaryExpression	1
>1676	Identifier	inc
>1677	Identifier	inc
>1678	IdentifierDeclType	int
>1679	IdentifierDecl	iter = 1
>1680	AssignmentExpr	iter = 1
>1681	PrimaryExpression	1
>1682	Identifier	iter
>1683	Identifier	iter
>1684	IdentifierDeclType	int
>1685	IdentifierDecl	search = 1
>1686	AssignmentExpr	search = 1
>1687	PrimaryExpression	1
>1688	Identifier	search
>1689	Identifier	search
>1690	IdentifierDeclType	int
>1691	IdentifierDeclStatement	 
>1692	IdentifierDecl	gs
>1693	Identifier	gs
>1694	IdentifierDeclType	float
>1695	IdentifierDecl	actred
>1696	Identifier	actred
>1697	IdentifierDeclType	float
>1698	IdentifierDecl	prered
>1699	Identifier	prered
>1700	IdentifierDeclType	float
>1701	IdentifierDecl	fnew
>1702	Identifier	fnew
>1703	IdentifierDeclType	float
>1704	IdentifierDecl	f
>1705	Identifier	f
>1706	IdentifierDeclType	float
>1707	IdentifierDecl	alpha
>1708	Identifier	alpha
>1709	IdentifierDeclType	float
>1710	IdentifierDeclStatement	 
>1711	IdentifierDecl	one = 1.0f
>1712	AssignmentExpr	one = 1.0f
>1713	PrimaryExpression	1.0f
>1714	Identifier	one
>1715	Identifier	one
>1716	IdentifierDeclType	float
>1717	IdentifierDecl	snorm
>1718	Identifier	snorm
>1719	IdentifierDeclType	float
>1720	IdentifierDecl	delta
>1721	Identifier	delta
>1722	IdentifierDeclType	float
>1723	IdentifierDeclStatement	 
>1724	IdentifierDecl	cg_iter
>1725	Identifier	cg_iter
>1726	IdentifierDeclType	int
>1727	IdentifierDecl	i
>1728	Identifier	i
>1729	IdentifierDeclType	int
>1730	IdentifierDeclStatement	 
>1731	IdentifierDecl	n = fun_obj -> get_nr_variable ( )
>1732	AssignmentExpr	n = fun_obj -> get_nr_variable ( )
>1733	CallExpression	fun_obj -> get_nr_variable ( )
>1734	ArgumentList	 
>1735	Callee	fun_obj -> get_nr_variable
>1736	PtrMemberAccess	fun_obj -> get_nr_variable
>1737	Identifier	get_nr_variable
>1738	Identifier	fun_obj
>1739	Identifier	n
>1740	Identifier	n
>1741	IdentifierDeclType	int
>1742	IdentifierDeclStatement	 
>1743	IdentifierDecl	sigma3 = 4.0f
>1744	AssignmentExpr	sigma3 = 4.0f
>1745	PrimaryExpression	4.0f
>1746	Identifier	sigma3
>1747	Identifier	sigma3
>1748	IdentifierDeclType	float
>1749	IdentifierDecl	sigma2 = 0.5f
>1750	AssignmentExpr	sigma2 = 0.5f
>1751	PrimaryExpression	0.5f
>1752	Identifier	sigma2
>1753	Identifier	sigma2
>1754	IdentifierDeclType	float
>1755	IdentifierDecl	sigma1 = 0.25f
>1756	AssignmentExpr	sigma1 = 0.25f
>1757	PrimaryExpression	0.25f
>1758	Identifier	sigma1
>1759	Identifier	sigma1
>1760	IdentifierDeclType	float
>1761	IdentifierDeclStatement	 
>1762	IdentifierDecl	eta2 = 0.75f
>1763	AssignmentExpr	eta2 = 0.75f
>1764	PrimaryExpression	0.75f
>1765	Identifier	eta2
>1766	Identifier	eta2
>1767	IdentifierDeclType	float
>1768	IdentifierDecl	eta1 = 0.25f
>1769	AssignmentExpr	eta1 = 0.25f
>1770	PrimaryExpression	0.25f
>1771	Identifier	eta1
>1772	Identifier	eta1
>1773	IdentifierDeclType	float
>1774	IdentifierDecl	eta0 = 1e-4f
>1775	AssignmentExpr	eta0 = 1e-4f
>1776	PrimaryExpression	1e-4f
>1777	Identifier	eta0
>1778	Identifier	eta0
>1779	IdentifierDeclType	float
>1828	FunctionDef	TRON 
>1829	ParameterList	float delta , float * g , float * s , float * r
>1830	Parameter	 
>1831	Identifier	r
>1832	ParameterType	float *
>1833	Parameter	 
>1834	Identifier	s
>1835	ParameterType	float *
>1836	Parameter	 
>1837	Identifier	g
>1838	ParameterType	float *
>1839	Parameter	 
>1840	Identifier	delta
>1841	ParameterType	float
>1842	ReturnType	int
>1843	CompoundStatement	 
>1844	ReturnStatement	 
>1845	Identifier	cg_iter
>1846	ExpressionStatement	 
>1847	Identifier	Hd
>1848	Statement	 
>1849	Statement	 
>1850	Statement	 
>1851	ExpressionStatement	 
>1852	Identifier	d
>1853	Statement	 
>1854	Statement	 
>1855	Statement	 
>1856	WhileStatement	while ( 1 )
>1857	CompoundStatement	 
>1858	ExpressionStatement	 
>1859	AssignmentExpr	rTr = rnewTrnew
>1860	Identifier	rnewTrnew
>1861	Identifier	rTr
>1862	ExpressionStatement	 
>1863	CallExpression	daxpy_ ( & n , & one , r , & inc , d , & inc )
>1864	ArgumentList	& n
>1865	Argument	& inc
>1866	UnaryOp	& inc
>1867	Identifier	inc
>1868	UnaryOperator	&
>1869	Argument	d
>1870	Identifier	d
>1871	Argument	& inc
>1872	UnaryOp	& inc
>1873	Identifier	inc
>1874	UnaryOperator	&
>1875	Argument	r
>1876	Identifier	r
>1877	Argument	& one
>1878	UnaryOp	& one
>1879	Identifier	one
>1880	UnaryOperator	&
>1881	Argument	& n
>1882	UnaryOp	& n
>1883	Identifier	n
>1884	UnaryOperator	&
>1885	Callee	daxpy_
>1886	Identifier	daxpy_
>1887	ExpressionStatement	 
>1888	CallExpression	dscal_ ( & n , & beta , d , & inc )
>1889	ArgumentList	& n
>1890	Argument	& inc
>1891	UnaryOp	& inc
>1892	Identifier	inc
>1893	UnaryOperator	&
>1894	Argument	d
>1895	Identifier	d
>1896	Argument	& beta
>1897	UnaryOp	& beta
>1898	Identifier	beta
>1899	UnaryOperator	&
>1900	Argument	& n
>1901	UnaryOp	& n
>1902	Identifier	n
>1903	UnaryOperator	&
>1904	Callee	dscal_
>1905	Identifier	dscal_
>1906	ExpressionStatement	 
>1907	AssignmentExpr	beta = rnewTrnew / rTr
>1908	MultiplicativeExpression	rnewTrnew / rTr
>1909	Identifier	rTr
>1910	Identifier	rnewTrnew
>1911	Identifier	beta
>1912	ExpressionStatement	 
>1913	AssignmentExpr	rnewTrnew = ddot_ ( & n , r , & inc , r , & inc )
>1914	CallExpression	ddot_ ( & n , r , & inc , r , & inc )
>1915	ArgumentList	& n
>1916	Argument	& inc
>1917	UnaryOp	& inc
>1918	Identifier	inc
>1919	UnaryOperator	&
>1920	Argument	r
>1921	Identifier	r
>1922	Argument	& inc
>1923	UnaryOp	& inc
>1924	Identifier	inc
>1925	UnaryOperator	&
>1926	Argument	r
>1927	Identifier	r
>1928	Argument	& n
>1929	UnaryOp	& n
>1930	Identifier	n
>1931	UnaryOperator	&
>1932	Callee	ddot_
>1933	Identifier	ddot_
>1934	Identifier	rnewTrnew
>1935	ExpressionStatement	 
>1936	CallExpression	daxpy_ ( & n , & alpha , Hd , & inc , r , & inc )
>1937	ArgumentList	& n
>1938	Argument	& inc
>1939	UnaryOp	& inc
>1940	Identifier	inc
>1941	UnaryOperator	&
>1942	Argument	r
>1943	Identifier	r
>1944	Argument	& inc
>1945	UnaryOp	& inc
>1946	Identifier	inc
>1947	UnaryOperator	&
>1948	Argument	Hd
>1949	Identifier	Hd
>1950	Argument	& alpha
>1951	UnaryOp	& alpha
>1952	Identifier	alpha
>1953	UnaryOperator	&
>1954	Argument	& n
>1955	UnaryOp	& n
>1956	Identifier	n
>1957	UnaryOperator	&
>1958	Callee	daxpy_
>1959	Identifier	daxpy_
>1960	ExpressionStatement	 
>1961	AssignmentExpr	alpha = - alpha
>1962	UnaryOp	- alpha
>1963	Identifier	alpha
>1964	UnaryOperator	-
>1965	Identifier	alpha
>1966	IfStatement	if ( dnrm2_ ( & n , s , & inc ) > delta )
>1967	CompoundStatement	 
>1968	BreakStatement	 
>1969	ExpressionStatement	 
>1970	CallExpression	daxpy_ ( & n , & alpha , Hd , & inc , r , & inc )
>1971	ArgumentList	& n
>1972	Argument	& inc
>1973	UnaryOp	& inc
>1974	Identifier	inc
>1975	UnaryOperator	&
>1976	Argument	r
>1977	Identifier	r
>1978	Argument	& inc
>1979	UnaryOp	& inc
>1980	Identifier	inc
>1981	UnaryOperator	&
>1982	Argument	Hd
>1983	Identifier	Hd
>1984	Argument	& alpha
>1985	UnaryOp	& alpha
>1986	Identifier	alpha
>1987	UnaryOperator	&
>1988	Argument	& n
>1989	UnaryOp	& n
>1990	Identifier	n
>1991	UnaryOperator	&
>1992	Callee	daxpy_
>1993	Identifier	daxpy_
>1994	ExpressionStatement	 
>1995	AssignmentExpr	alpha = - alpha
>1996	UnaryOp	- alpha
>1997	Identifier	alpha
>1998	UnaryOperator	-
>1999	Identifier	alpha
>2000	ExpressionStatement	 
>2001	CallExpression	daxpy_ ( & n , & alpha , d , & inc , s , & inc )
>2002	ArgumentList	& n
>2003	Argument	& inc
>2004	UnaryOp	& inc
>2005	Identifier	inc
>2006	UnaryOperator	&
>2007	Argument	s
>2008	Identifier	s
>2009	Argument	& inc
>2010	UnaryOp	& inc
>2011	Identifier	inc
>2012	UnaryOperator	&
>2013	Argument	d
>2014	Identifier	d
>2015	Argument	& alpha
>2016	UnaryOp	& alpha
>2017	Identifier	alpha
>2018	UnaryOperator	&
>2019	Argument	& n
>2020	UnaryOp	& n
>2021	Identifier	n
>2022	UnaryOperator	&
>2023	Callee	daxpy_
>2024	Identifier	daxpy_
>2025	IfStatement	if ( std >= 0 )
>2026	ElseStatement	else
>2027	ExpressionStatement	 
>2028	AssignmentExpr	alpha = ( rad - std ) / dtd
>2029	MultiplicativeExpression	( rad - std ) / dtd
>2030	Identifier	dtd
>2031	AdditiveExpression	rad - std
>2032	Identifier	std
>2033	Identifier	rad
>2034	Identifier	alpha
>2035	ExpressionStatement	 
>2036	AssignmentExpr	alpha = ( dsq - sts ) / ( std + rad )
>2037	MultiplicativeExpression	( dsq - sts ) / ( std + rad )
>2038	AdditiveExpression	std + rad
>2039	Identifier	rad
>2040	Identifier	std
>2041	AdditiveExpression	dsq - sts
>2042	Identifier	sts
>2043	Identifier	dsq
>2044	Identifier	alpha
>2045	Condition	 
>2046	RelationalExpression	std >= 0
>2047	PrimaryExpression	0
>2048	Identifier	std
>2049	IdentifierDeclStatement	 
>2050	IdentifierDecl	rad = sqrt ( std * std + dtd * ( dsq - sts ) )
>2051	AssignmentExpr	rad = sqrt ( std * std + dtd * ( dsq - sts ) )
>2052	CallExpression	sqrt ( std * std + dtd * ( dsq - sts ) )
>2053	ArgumentList	std * std + dtd * ( dsq - sts )
>2054	Argument	std * std + dtd * ( dsq - sts )
>2055	AdditiveExpression	std * std + dtd * ( dsq - sts )
>2056	MultiplicativeExpression	dtd * ( dsq - sts )
>2057	AdditiveExpression	dsq - sts
>2058	Identifier	sts
>2059	Identifier	dsq
>2060	Identifier	dtd
>2061	MultiplicativeExpression	std * std
>2062	Identifier	std
>2063	Identifier	std
>2064	Callee	sqrt
>2065	Identifier	sqrt
>2066	Identifier	rad
>2067	Identifier	rad
>2068	IdentifierDeclType	float
>2069	IdentifierDeclStatement	 
>2070	IdentifierDecl	dsq = delta * delta
>2071	AssignmentExpr	dsq = delta * delta
>2072	MultiplicativeExpression	delta * delta
>2073	Identifier	delta
>2074	Identifier	delta
>2075	Identifier	dsq
>2076	Identifier	dsq
>2077	IdentifierDeclType	float
>2078	IdentifierDeclStatement	 
>2079	IdentifierDecl	dtd = ddot_ ( & n , d , & inc , d , & inc )
>2080	AssignmentExpr	dtd = ddot_ ( & n , d , & inc , d , & inc )
>2081	CallExpression	ddot_ ( & n , d , & inc , d , & inc )
>2082	ArgumentList	& n
>2083	Argument	& inc
>2084	UnaryOp	& inc
>2085	Identifier	inc
>2086	UnaryOperator	&
>2087	Argument	d
>2088	Identifier	d
>2089	Argument	& inc
>2090	UnaryOp	& inc
>2091	Identifier	inc
>2092	UnaryOperator	&
>2093	Argument	d
>2094	Identifier	d
>2095	Argument	& n
>2096	UnaryOp	& n
>2097	Identifier	n
>2098	UnaryOperator	&
>2099	Callee	ddot_
>2100	Identifier	ddot_
>2101	Identifier	dtd
>2102	Identifier	dtd
>2103	IdentifierDeclType	float
>2104	IdentifierDeclStatement	 
>2105	IdentifierDecl	sts = ddot_ ( & n , s , & inc , s , & inc )
>2106	AssignmentExpr	sts = ddot_ ( & n , s , & inc , s , & inc )
>2107	CallExpression	ddot_ ( & n , s , & inc , s , & inc )
>2108	ArgumentList	& n
>2109	Argument	& inc
>2110	UnaryOp	& inc
>2111	Identifier	inc
>2112	UnaryOperator	&
>2113	Argument	s
>2114	Identifier	s
>2115	Argument	& inc
>2116	UnaryOp	& inc
>2117	Identifier	inc
>2118	UnaryOperator	&
>2119	Argument	s
>2120	Identifier	s
>2121	Argument	& n
>2122	UnaryOp	& n
>2123	Identifier	n
>2124	UnaryOperator	&
>2125	Callee	ddot_
>2126	Identifier	ddot_
>2127	Identifier	sts
>2128	Identifier	sts
>2129	IdentifierDeclType	float
>2130	IdentifierDeclStatement	 
>2131	IdentifierDecl	std = ddot_ ( & n , s , & inc , d , & inc )
>2132	AssignmentExpr	std = ddot_ ( & n , s , & inc , d , & inc )
>2133	CallExpression	ddot_ ( & n , s , & inc , d , & inc )
>2134	ArgumentList	& n
>2135	Argument	& inc
>2136	UnaryOp	& inc
>2137	Identifier	inc
>2138	UnaryOperator	&
>2139	Argument	d
>2140	Identifier	d
>2141	Argument	& inc
>2142	UnaryOp	& inc
>2143	Identifier	inc
>2144	UnaryOperator	&
>2145	Argument	s
>2146	Identifier	s
>2147	Argument	& n
>2148	UnaryOp	& n
>2149	Identifier	n
>2150	UnaryOperator	&
>2151	Callee	ddot_
>2152	Identifier	ddot_
>2153	Identifier	std
>2154	Identifier	std
>2155	IdentifierDeclType	float
>2156	ExpressionStatement	 
>2157	CallExpression	daxpy_ ( & n , & alpha , d , & inc , s , & inc )
>2158	ArgumentList	& n
>2159	Argument	& inc
>2160	UnaryOp	& inc
>2161	Identifier	inc
>2162	UnaryOperator	&
>2163	Argument	s
>2164	Identifier	s
>2165	Argument	& inc
>2166	UnaryOp	& inc
>2167	Identifier	inc
>2168	UnaryOperator	&
>2169	Argument	d
>2170	Identifier	d
>2171	Argument	& alpha
>2172	UnaryOp	& alpha
>2173	Identifier	alpha
>2174	UnaryOperator	&
>2175	Argument	& n
>2176	UnaryOp	& n
>2177	Identifier	n
>2178	UnaryOperator	&
>2179	Callee	daxpy_
>2180	Identifier	daxpy_
>2181	ExpressionStatement	 
>2182	AssignmentExpr	alpha = - alpha
>2183	UnaryOp	- alpha
>2184	Identifier	alpha
>2185	UnaryOperator	-
>2186	Identifier	alpha
>2187	Condition	 
>2188	RelationalExpression	dnrm2_ ( & n , s , & inc ) > delta
>2189	Identifier	delta
>2190	CallExpression	dnrm2_ ( & n , s , & inc )
>2191	ArgumentList	& n
>2192	Argument	& inc
>2193	UnaryOp	& inc
>2194	Identifier	inc
>2195	UnaryOperator	&
>2196	Argument	s
>2197	Identifier	s
>2198	Argument	& n
>2199	UnaryOp	& n
>2200	Identifier	n
>2201	UnaryOperator	&
>2202	Callee	dnrm2_
>2203	Identifier	dnrm2_
>2204	ExpressionStatement	 
>2205	CallExpression	daxpy_ ( & n , & alpha , d , & inc , s , & inc )
>2206	ArgumentList	& n
>2207	Argument	& inc
>2208	UnaryOp	& inc
>2209	Identifier	inc
>2210	UnaryOperator	&
>2211	Argument	s
>2212	Identifier	s
>2213	Argument	& inc
>2214	UnaryOp	& inc
>2215	Identifier	inc
>2216	UnaryOperator	&
>2217	Argument	d
>2218	Identifier	d
>2219	Argument	& alpha
>2220	UnaryOp	& alpha
>2221	Identifier	alpha
>2222	UnaryOperator	&
>2223	Argument	& n
>2224	UnaryOp	& n
>2225	Identifier	n
>2226	UnaryOperator	&
>2227	Callee	daxpy_
>2228	Identifier	daxpy_
>2229	ExpressionStatement	 
>2230	AssignmentExpr	alpha = rTr / ddot_ ( & n , d , & inc , Hd , & inc )
>2231	MultiplicativeExpression	rTr / ddot_ ( & n , d , & inc , Hd , & inc )
>2232	CallExpression	ddot_ ( & n , d , & inc , Hd , & inc )
>2233	ArgumentList	& n
>2234	Argument	& inc
>2235	UnaryOp	& inc
>2236	Identifier	inc
>2237	UnaryOperator	&
>2238	Argument	Hd
>2239	Identifier	Hd
>2240	Argument	& inc
>2241	UnaryOp	& inc
>2242	Identifier	inc
>2243	UnaryOperator	&
>2244	Argument	d
>2245	Identifier	d
>2246	Argument	& n
>2247	UnaryOp	& n
>2248	Identifier	n
>2249	UnaryOperator	&
>2250	Callee	ddot_
>2251	Identifier	ddot_
>2252	Identifier	rTr
>2253	Identifier	alpha
>2254	ExpressionStatement	 
>2255	CallExpression	fun_obj -> Hv ( d , Hd )
>2256	ArgumentList	d
>2257	Argument	Hd
>2258	Identifier	Hd
>2259	Argument	d
>2260	Identifier	d
>2261	Callee	fun_obj -> Hv
>2262	PtrMemberAccess	fun_obj -> Hv
>2263	Identifier	Hv
>2264	Identifier	fun_obj
>2265	ExpressionStatement	 
>2266	IncDecOp	cg_iter ++
>2267	IncDec	++
>2268	Identifier	cg_iter
>2269	IfStatement	if ( dnrm2_ ( & n , r , & inc ) <= cgtol )
>2270	BreakStatement	 
>2271	Condition	 
>2272	RelationalExpression	dnrm2_ ( & n , r , & inc ) <= cgtol
>2273	Identifier	cgtol
>2274	CallExpression	dnrm2_ ( & n , r , & inc )
>2275	ArgumentList	& n
>2276	Argument	& inc
>2277	UnaryOp	& inc
>2278	Identifier	inc
>2279	UnaryOperator	&
>2280	Argument	r
>2281	Identifier	r
>2282	Argument	& n
>2283	UnaryOp	& n
>2284	Identifier	n
>2285	UnaryOperator	&
>2286	Callee	dnrm2_
>2287	Identifier	dnrm2_
>2288	Condition	 
>2289	PrimaryExpression	1
>2290	ExpressionStatement	 
>2291	AssignmentExpr	rTr = ddot_ ( & n , r , & inc , r , & inc )
>2292	CallExpression	ddot_ ( & n , r , & inc , r , & inc )
>2293	ArgumentList	& n
>2294	Argument	& inc
>2295	UnaryOp	& inc
>2296	Identifier	inc
>2297	UnaryOperator	&
>2298	Argument	r
>2299	Identifier	r
>2300	Argument	& inc
>2301	UnaryOp	& inc
>2302	Identifier	inc
>2303	UnaryOperator	&
>2304	Argument	r
>2305	Identifier	r
>2306	Argument	& n
>2307	UnaryOp	& n
>2308	Identifier	n
>2309	UnaryOperator	&
>2310	Callee	ddot_
>2311	Identifier	ddot_
>2312	Identifier	rTr
>2313	IdentifierDeclStatement	 
>2314	IdentifierDecl	cg_iter = 0
>2315	AssignmentExpr	cg_iter = 0
>2316	PrimaryExpression	0
>2317	Identifier	cg_iter
>2318	Identifier	cg_iter
>2319	IdentifierDeclType	int
>2320	ExpressionStatement	 
>2321	AssignmentExpr	cgtol = 0.1f * dnrm2_ ( & n , g , & inc )
>2322	MultiplicativeExpression	0.1f * dnrm2_ ( & n , g , & inc )
>2323	CallExpression	dnrm2_ ( & n , g , & inc )
>2324	ArgumentList	& n
>2325	Argument	& inc
>2326	UnaryOp	& inc
>2327	Identifier	inc
>2328	UnaryOperator	&
>2329	Argument	g
>2330	Identifier	g
>2331	Argument	& n
>2332	UnaryOp	& n
>2333	Identifier	n
>2334	UnaryOperator	&
>2335	Callee	dnrm2_
>2336	Identifier	dnrm2_
>2337	PrimaryExpression	0.1f
>2338	Identifier	cgtol
>2339	ForStatement	for ( i = 0 ; i < n ; i ++ )
>2340	CompoundStatement	 
>2341	ExpressionStatement	 
>2342	AssignmentExpr	d [ i ] = r [ i ]
>2343	ArrayIndexing	r [ i ]
>2344	Identifier	i
>2345	Identifier	r
>2346	ArrayIndexing	d [ i ]
>2347	Identifier	i
>2348	Identifier	d
>2349	ExpressionStatement	 
>2350	AssignmentExpr	r [ i ] = - g [ i ]
>2351	UnaryOp	- g [ i ]
>2352	ArrayIndexing	g [ i ]
>2353	Identifier	i
>2354	Identifier	g
>2355	UnaryOperator	-
>2356	ArrayIndexing	r [ i ]
>2357	Identifier	i
>2358	Identifier	r
>2359	ExpressionStatement	 
>2360	AssignmentExpr	s [ i ] = 0
>2361	PrimaryExpression	0
>2362	ArrayIndexing	s [ i ]
>2363	Identifier	i
>2364	Identifier	s
>2365	IncDecOp	 
>2366	IncDec	++
>2367	Identifier	i
>2368	Condition	 
>2369	RelationalExpression	i < n
>2370	Identifier	n
>2371	Identifier	i
>2372	ForInit	 
>2373	AssignmentExpr	i = 0
>2374	PrimaryExpression	0
>2375	Identifier	i
>2376	IdentifierDeclStatement	 
>2377	IdentifierDecl	cgtol
>2378	Identifier	cgtol
>2379	IdentifierDeclType	float
>2380	IdentifierDecl	beta
>2381	Identifier	beta
>2382	IdentifierDeclType	float
>2383	IdentifierDecl	alpha
>2384	Identifier	alpha
>2385	IdentifierDeclType	float
>2386	IdentifierDecl	rnewTrnew
>2387	Identifier	rnewTrnew
>2388	IdentifierDeclType	float
>2389	IdentifierDecl	rTr
>2390	Identifier	rTr
>2391	IdentifierDeclType	float
>2392	IdentifierDeclStatement	 
>2393	IdentifierDecl	* Hd = new float [ n ]
>2394	AssignmentExpr	* Hd = new float [ n ]
>2395	Identifier	n
>2396	Identifier	n
>2397	Identifier	Hd
>2398	IdentifierDeclType	float *
>2399	IdentifierDeclStatement	 
>2400	IdentifierDecl	* d = new float [ n ]
>2401	AssignmentExpr	* d = new float [ n ]
>2402	Identifier	n
>2403	Identifier	n
>2404	Identifier	d
>2405	IdentifierDeclType	float *
>2406	IdentifierDeclStatement	 
>2407	IdentifierDecl	one = 1.0f
>2408	AssignmentExpr	one = 1.0f
>2409	PrimaryExpression	1.0f
>2410	Identifier	one
>2411	Identifier	one
>2412	IdentifierDeclType	float
>2413	IdentifierDeclStatement	 
>2414	IdentifierDecl	n = fun_obj -> get_nr_variable ( )
>2415	AssignmentExpr	n = fun_obj -> get_nr_variable ( )
>2416	CallExpression	fun_obj -> get_nr_variable ( )
>2417	ArgumentList	 
>2418	Callee	fun_obj -> get_nr_variable
>2419	PtrMemberAccess	fun_obj -> get_nr_variable
>2420	Identifier	get_nr_variable
>2421	Identifier	fun_obj
>2422	Identifier	n
>2423	Identifier	n
>2424	IdentifierDeclType	int
>2425	IdentifierDeclStatement	 
>2426	IdentifierDecl	inc = 1
>2427	AssignmentExpr	inc = 1
>2428	PrimaryExpression	1
>2429	Identifier	inc
>2430	Identifier	inc
>2431	IdentifierDeclType	int
>2432	IdentifierDecl	i
>2433	Identifier	i
>2434	IdentifierDeclType	int
>2475	FunctionDef	TRON 
>2476	ParameterList	int n , float * x
>2477	Parameter	 
>2478	Identifier	x
>2479	ParameterType	float *
>2480	Parameter	 
>2481	Identifier	n
>2482	ParameterType	int
>2483	ReturnType	float
>2484	CompoundStatement	 
>2485	ReturnStatement	 
>2486	Identifier	dmax
>2487	ForStatement	for ( int i = 1 ; i < n ; i ++ )
>2488	IfStatement	if ( fabs ( x [ i ] ) >= dmax )
>2489	ExpressionStatement	 
>2490	AssignmentExpr	dmax = fabs ( x [ i ] )
>2491	CallExpression	fabs ( x [ i ] )
>2492	ArgumentList	x [ i ]
>2493	Argument	x [ i ]
>2494	ArrayIndexing	x [ i ]
>2495	Identifier	i
>2496	Identifier	x
>2497	Callee	fabs
>2498	Identifier	fabs
>2499	Identifier	dmax
>2500	Condition	 
>2501	RelationalExpression	fabs ( x [ i ] ) >= dmax
>2502	Identifier	dmax
>2503	CallExpression	fabs ( x [ i ] )
>2504	ArgumentList	x [ i ]
>2505	Argument	x [ i ]
>2506	ArrayIndexing	x [ i ]
>2507	Identifier	i
>2508	Identifier	x
>2509	Callee	fabs
>2510	Identifier	fabs
>2511	IncDecOp	 
>2512	IncDec	++
>2513	Identifier	i
>2514	Condition	 
>2515	RelationalExpression	i < n
>2516	Identifier	n
>2517	Identifier	i
>2518	ForInit	 
>2519	IdentifierDeclStatement	int i = 1 ;
>2520	IdentifierDecl	i = 1
>2521	AssignmentExpr	i = 1
>2522	PrimaryExpression	1
>2523	Identifier	i
>2524	Identifier	i
>2525	IdentifierDeclType	int
>2526	IdentifierDeclStatement	 
>2527	IdentifierDecl	dmax = fabs ( x [ 0 ] )
>2528	AssignmentExpr	dmax = fabs ( x [ 0 ] )
>2529	CallExpression	fabs ( x [ 0 ] )
>2530	ArgumentList	x [ 0 ]
>2531	Argument	x [ 0 ]
>2532	ArrayIndexing	x [ 0 ]
>2533	PrimaryExpression	0
>2534	Identifier	x
>2535	Callee	fabs
>2536	Identifier	fabs
>2537	Identifier	dmax
>2538	Identifier	dmax
>2539	IdentifierDeclType	float
>2551	FunctionDef	l2loss_svm_fun (const problem * prob_ , float Cp , float Cn)
>2552	ParameterList	const problem * prob_ , float Cp , float Cn
>2553	Parameter	 
>2554	Identifier	Cn
>2555	ParameterType	float
>2556	Parameter	 
>2557	Identifier	Cp
>2558	ParameterType	float
>2559	Parameter	 
>2560	Identifier	prob_
>2561	ParameterType	const problem *
>2562	CompoundStatement	 
>2563	ForStatement	for ( i = 0 ; i < l ; i ++ )
>2564	CompoundStatement	 
>2565	IfStatement	if ( y [ i ] == 1 )
>2566	ElseStatement	else
>2567	ExpressionStatement	 
>2568	AssignmentExpr	C [ i ] = Cn
>2569	Identifier	Cn
>2570	ArrayIndexing	C [ i ]
>2571	Identifier	i
>2572	Identifier	C
>2573	ExpressionStatement	 
>2574	AssignmentExpr	C [ i ] = Cp
>2575	Identifier	Cp
>2576	ArrayIndexing	C [ i ]
>2577	Identifier	i
>2578	Identifier	C
>2579	Condition	 
>2580	EqualityExpression	y [ i ] == 1
>2581	PrimaryExpression	1
>2582	ArrayIndexing	y [ i ]
>2583	Identifier	i
>2584	Identifier	y
>2585	IncDecOp	 
>2586	IncDec	++
>2587	Identifier	i
>2588	Condition	 
>2589	RelationalExpression	i < l
>2590	Identifier	l
>2591	Identifier	i
>2592	ForInit	 
>2593	AssignmentExpr	i = 0
>2594	PrimaryExpression	0
>2595	Identifier	i
>2596	IdentifierDeclStatement	 
>2597	IdentifierDecl	* y = prob -> y
>2598	AssignmentExpr	* y = prob -> y
>2599	PtrMemberAccess	prob -> y
>2600	Identifier	y
>2601	Identifier	prob
>2602	Identifier	y
>2603	Identifier	y
>2604	IdentifierDeclType	int *
>2605	IdentifierDeclStatement	 
>2606	IdentifierDecl	l = prob -> l
>2607	AssignmentExpr	l = prob -> l
>2608	PtrMemberAccess	prob -> l
>2609	Identifier	l
>2610	Identifier	prob
>2611	Identifier	l
>2612	Identifier	l
>2613	IdentifierDeclType	int
>2614	IdentifierDeclStatement	 
>2615	IdentifierDecl	i
>2616	Identifier	i
>2617	IdentifierDeclType	int
>2635	FunctionDef	~l2loss_svm_fun ()
>2636	ParameterList	 
>2637	CompoundStatement	 
>2638	ExpressionStatement	 
>2639	Identifier	I
>2640	Statement	 
>2641	Statement	 
>2642	Statement	 
>2643	ExpressionStatement	 
>2644	Identifier	C
>2645	Statement	 
>2646	Statement	 
>2647	Statement	 
>2648	ExpressionStatement	 
>2649	Identifier	D
>2650	Statement	 
>2651	Statement	 
>2652	Statement	 
>2653	ExpressionStatement	 
>2654	Identifier	z
>2655	Statement	 
>2656	Statement	 
>2657	Statement	 
>2661	FunctionDef	fun (float * w)
>2662	ParameterList	float * w
>2663	Parameter	 
>2664	Identifier	w
>2665	ParameterType	float *
>2666	ReturnType	float
>2667	CompoundStatement	 
>2668	ReturnStatement	 
>2669	Identifier	f
>2670	ExpressionStatement	 
>2671	AssignmentExpr	f /= 2.0f
>2672	PrimaryExpression	2.0f
>2673	Identifier	f
>2674	ForStatement	for ( i = 0 ; i < n ; i ++ )
>2675	ExpressionStatement	 
>2676	AssignmentExpr	f += w [ i ] * w [ i ]
>2677	MultiplicativeExpression	w [ i ] * w [ i ]
>2678	ArrayIndexing	w [ i ]
>2679	Identifier	i
>2680	Identifier	w
>2681	ArrayIndexing	w [ i ]
>2682	Identifier	i
>2683	Identifier	w
>2684	Identifier	f
>2685	IncDecOp	 
>2686	IncDec	++
>2687	Identifier	i
>2688	Condition	 
>2689	RelationalExpression	i < n
>2690	Identifier	n
>2691	Identifier	i
>2692	ForInit	 
>2693	AssignmentExpr	i = 0
>2694	PrimaryExpression	0
>2695	Identifier	i
>2696	ExpressionStatement	 
>2697	AssignmentExpr	f = 2.0f * f
>2698	MultiplicativeExpression	2.0f * f
>2699	Identifier	f
>2700	PrimaryExpression	2.0f
>2701	Identifier	f
>2702	ForStatement	for ( i = 0 ; i < l ; i ++ )
>2703	CompoundStatement	 
>2704	IfStatement	if ( d < 0 )
>2705	ExpressionStatement	 
>2706	AssignmentExpr	f += C [ i ] * d * d
>2707	MultiplicativeExpression	C [ i ] * d * d
>2708	MultiplicativeExpression	d * d
>2709	Identifier	d
>2710	Identifier	d
>2711	ArrayIndexing	C [ i ]
>2712	Identifier	i
>2713	Identifier	C
>2714	Identifier	f
>2715	Condition	 
>2716	RelationalExpression	d < 0
>2717	PrimaryExpression	0
>2718	Identifier	d
>2719	IdentifierDeclStatement	 
>2720	IdentifierDecl	d = z [ i ] - 1.0f
>2721	AssignmentExpr	d = z [ i ] - 1.0f
>2722	AdditiveExpression	z [ i ] - 1.0f
>2723	PrimaryExpression	1.0f
>2724	ArrayIndexing	z [ i ]
>2725	Identifier	i
>2726	Identifier	z
>2727	Identifier	d
>2728	Identifier	d
>2729	IdentifierDeclType	float
>2730	ExpressionStatement	 
>2731	AssignmentExpr	z [ i ] = y [ i ] * z [ i ]
>2732	MultiplicativeExpression	y [ i ] * z [ i ]
>2733	ArrayIndexing	z [ i ]
>2734	Identifier	i
>2735	Identifier	z
>2736	ArrayIndexing	y [ i ]
>2737	Identifier	i
>2738	Identifier	y
>2739	ArrayIndexing	z [ i ]
>2740	Identifier	i
>2741	Identifier	z
>2742	IncDecOp	 
>2743	IncDec	++
>2744	Identifier	i
>2745	Condition	 
>2746	RelationalExpression	i < l
>2747	Identifier	l
>2748	Identifier	i
>2749	ForInit	 
>2750	AssignmentExpr	i = 0
>2751	PrimaryExpression	0
>2752	Identifier	i
>2753	ExpressionStatement	 
>2754	CallExpression	Xv ( w , z )
>2755	ArgumentList	w
>2756	Argument	z
>2757	Identifier	z
>2758	Argument	w
>2759	Identifier	w
>2760	Callee	Xv
>2761	Identifier	Xv
>2762	IdentifierDeclStatement	 
>2763	IdentifierDecl	n = prob -> n
>2764	AssignmentExpr	n = prob -> n
>2765	PtrMemberAccess	prob -> n
>2766	Identifier	n
>2767	Identifier	prob
>2768	Identifier	n
>2769	Identifier	n
>2770	IdentifierDeclType	int
>2771	IdentifierDeclStatement	 
>2772	IdentifierDecl	l = prob -> l
>2773	AssignmentExpr	l = prob -> l
>2774	PtrMemberAccess	prob -> l
>2775	Identifier	l
>2776	Identifier	prob
>2777	Identifier	l
>2778	Identifier	l
>2779	IdentifierDeclType	int
>2780	IdentifierDeclStatement	 
>2781	IdentifierDecl	* y = prob -> y
>2782	AssignmentExpr	* y = prob -> y
>2783	PtrMemberAccess	prob -> y
>2784	Identifier	y
>2785	Identifier	prob
>2786	Identifier	y
>2787	Identifier	y
>2788	IdentifierDeclType	int *
>2789	IdentifierDeclStatement	 
>2790	IdentifierDecl	f = 0.0f
>2791	AssignmentExpr	f = 0.0f
>2792	PrimaryExpression	0.0f
>2793	Identifier	f
>2794	Identifier	f
>2795	IdentifierDeclType	float
>2796	IdentifierDeclStatement	 
>2797	IdentifierDecl	i
>2798	Identifier	i
>2799	IdentifierDeclType	int
>2822	FunctionDef	grad (float * w , float * g)
>2823	ParameterList	float * w , float * g
>2824	Parameter	 
>2825	Identifier	g
>2826	ParameterType	float *
>2827	Parameter	 
>2828	Identifier	w
>2829	ParameterType	float *
>2830	ReturnType	void
>2831	CompoundStatement	 
>2832	ForStatement	for ( i = 0 ; i < n ; i ++ )
>2833	ExpressionStatement	 
>2834	AssignmentExpr	g [ i ] = w [ i ] + 2.0f * g [ i ]
>2835	AdditiveExpression	w [ i ] + 2.0f * g [ i ]
>2836	MultiplicativeExpression	2.0f * g [ i ]
>2837	ArrayIndexing	g [ i ]
>2838	Identifier	i
>2839	Identifier	g
>2840	PrimaryExpression	2.0f
>2841	ArrayIndexing	w [ i ]
>2842	Identifier	i
>2843	Identifier	w
>2844	ArrayIndexing	g [ i ]
>2845	Identifier	i
>2846	Identifier	g
>2847	IncDecOp	 
>2848	IncDec	++
>2849	Identifier	i
>2850	Condition	 
>2851	RelationalExpression	i < n
>2852	Identifier	n
>2853	Identifier	i
>2854	ForInit	 
>2855	AssignmentExpr	i = 0
>2856	PrimaryExpression	0
>2857	Identifier	i
>2858	ExpressionStatement	 
>2859	CallExpression	subXTv ( z , g )
>2860	ArgumentList	z
>2861	Argument	g
>2862	Identifier	g
>2863	Argument	z
>2864	Identifier	z
>2865	Callee	subXTv
>2866	Identifier	subXTv
>2867	ForStatement	for ( i = 0 ; i < l ; i ++ )
>2868	IfStatement	if ( z [ i ] < 1.0f )
>2869	CompoundStatement	 
>2870	ExpressionStatement	 
>2871	IncDecOp	sizeI ++
>2872	IncDec	++
>2873	Identifier	sizeI
>2874	ExpressionStatement	 
>2875	AssignmentExpr	I [ sizeI ] = i
>2876	Identifier	i
>2877	ArrayIndexing	I [ sizeI ]
>2878	Identifier	sizeI
>2879	Identifier	I
>2880	ExpressionStatement	 
>2881	AssignmentExpr	z [ sizeI ] = C [ i ] * y [ i ] * ( z [ i ] - 1 )
>2882	MultiplicativeExpression	C [ i ] * y [ i ] * ( z [ i ] - 1 )
>2883	MultiplicativeExpression	y [ i ] * ( z [ i ] - 1 )
>2884	AdditiveExpression	z [ i ] - 1
>2885	PrimaryExpression	1
>2886	ArrayIndexing	z [ i ]
>2887	Identifier	i
>2888	Identifier	z
>2889	ArrayIndexing	y [ i ]
>2890	Identifier	i
>2891	Identifier	y
>2892	ArrayIndexing	C [ i ]
>2893	Identifier	i
>2894	Identifier	C
>2895	ArrayIndexing	z [ sizeI ]
>2896	Identifier	sizeI
>2897	Identifier	z
>2898	Condition	 
>2899	RelationalExpression	z [ i ] < 1.0f
>2900	PrimaryExpression	1.0f
>2901	ArrayIndexing	z [ i ]
>2902	Identifier	i
>2903	Identifier	z
>2904	IncDecOp	 
>2905	IncDec	++
>2906	Identifier	i
>2907	Condition	 
>2908	RelationalExpression	i < l
>2909	Identifier	l
>2910	Identifier	i
>2911	ForInit	 
>2912	AssignmentExpr	i = 0
>2913	PrimaryExpression	0
>2914	Identifier	i
>2915	ExpressionStatement	 
>2916	AssignmentExpr	sizeI = 0
>2917	PrimaryExpression	0
>2918	Identifier	sizeI
>2919	IdentifierDeclStatement	 
>2920	IdentifierDecl	n = prob -> n
>2921	AssignmentExpr	n = prob -> n
>2922	PtrMemberAccess	prob -> n
>2923	Identifier	n
>2924	Identifier	prob
>2925	Identifier	n
>2926	Identifier	n
>2927	IdentifierDeclType	int
>2928	IdentifierDeclStatement	 
>2929	IdentifierDecl	l = prob -> l
>2930	AssignmentExpr	l = prob -> l
>2931	PtrMemberAccess	prob -> l
>2932	Identifier	l
>2933	Identifier	prob
>2934	Identifier	l
>2935	Identifier	l
>2936	IdentifierDeclType	int
>2937	IdentifierDeclStatement	 
>2938	IdentifierDecl	* y = prob -> y
>2939	AssignmentExpr	* y = prob -> y
>2940	PtrMemberAccess	prob -> y
>2941	Identifier	y
>2942	Identifier	prob
>2943	Identifier	y
>2944	Identifier	y
>2945	IdentifierDeclType	int *
>2946	IdentifierDeclStatement	 
>2947	IdentifierDecl	i
>2948	Identifier	i
>2949	IdentifierDeclType	int
>2976	FunctionDef	Hv (float * s , float * Hs)
>2977	ParameterList	float * s , float * Hs
>2978	Parameter	 
>2979	Identifier	Hs
>2980	ParameterType	float *
>2981	Parameter	 
>2982	Identifier	s
>2983	ParameterType	float *
>2984	ReturnType	void
>2985	CompoundStatement	 
>2986	ExpressionStatement	 
>2987	Identifier	wa
>2988	Statement	 
>2989	Statement	 
>2990	Statement	 
>2991	ForStatement	for ( i = 0 ; i < n ; i ++ )
>2992	ExpressionStatement	 
>2993	AssignmentExpr	Hs [ i ] = s [ i ] + 2 * Hs [ i ]
>2994	AdditiveExpression	s [ i ] + 2 * Hs [ i ]
>2995	MultiplicativeExpression	2 * Hs [ i ]
>2996	ArrayIndexing	Hs [ i ]
>2997	Identifier	i
>2998	Identifier	Hs
>2999	PrimaryExpression	2
>3000	ArrayIndexing	s [ i ]
>3001	Identifier	i
>3002	Identifier	s
>3003	ArrayIndexing	Hs [ i ]
>3004	Identifier	i
>3005	Identifier	Hs
>3006	IncDecOp	 
>3007	IncDec	++
>3008	Identifier	i
>3009	Condition	 
>3010	RelationalExpression	i < n
>3011	Identifier	n
>3012	Identifier	i
>3013	ForInit	 
>3014	AssignmentExpr	i = 0
>3015	PrimaryExpression	0
>3016	Identifier	i
>3017	ExpressionStatement	 
>3018	CallExpression	subXTv ( wa , Hs )
>3019	ArgumentList	wa
>3020	Argument	Hs
>3021	Identifier	Hs
>3022	Argument	wa
>3023	Identifier	wa
>3024	Callee	subXTv
>3025	Identifier	subXTv
>3026	ForStatement	for ( i = 0 ; i < sizeI ; i ++ )
>3027	ExpressionStatement	 
>3028	AssignmentExpr	wa [ i ] = C [ I [ i ] ] * wa [ i ]
>3029	MultiplicativeExpression	C [ I [ i ] ] * wa [ i ]
>3030	ArrayIndexing	wa [ i ]
>3031	Identifier	i
>3032	Identifier	wa
>3033	ArrayIndexing	C [ I [ i ] ]
>3034	ArrayIndexing	I [ i ]
>3035	Identifier	i
>3036	Identifier	I
>3037	Identifier	C
>3038	ArrayIndexing	wa [ i ]
>3039	Identifier	i
>3040	Identifier	wa
>3041	IncDecOp	 
>3042	IncDec	++
>3043	Identifier	i
>3044	Condition	 
>3045	RelationalExpression	i < sizeI
>3046	Identifier	sizeI
>3047	Identifier	i
>3048	ForInit	 
>3049	AssignmentExpr	i = 0
>3050	PrimaryExpression	0
>3051	Identifier	i
>3052	ExpressionStatement	 
>3053	CallExpression	subXv ( s , wa )
>3054	ArgumentList	s
>3055	Argument	wa
>3056	Identifier	wa
>3057	Argument	s
>3058	Identifier	s
>3059	Callee	subXv
>3060	Identifier	subXv
>3061	IdentifierDeclStatement	 
>3062	IdentifierDecl	* wa = new float [ l ]
>3063	AssignmentExpr	* wa = new float [ l ]
>3064	Identifier	l
>3065	Identifier	l
>3066	Identifier	wa
>3067	IdentifierDeclType	float *
>3068	IdentifierDeclStatement	 
>3069	IdentifierDecl	n = prob -> n
>3070	AssignmentExpr	n = prob -> n
>3071	PtrMemberAccess	prob -> n
>3072	Identifier	n
>3073	Identifier	prob
>3074	Identifier	n
>3075	Identifier	n
>3076	IdentifierDeclType	int
>3077	IdentifierDeclStatement	 
>3078	IdentifierDecl	l = prob -> l
>3079	AssignmentExpr	l = prob -> l
>3080	PtrMemberAccess	prob -> l
>3081	Identifier	l
>3082	Identifier	prob
>3083	Identifier	l
>3084	Identifier	l
>3085	IdentifierDeclType	int
>3086	IdentifierDeclStatement	 
>3087	IdentifierDecl	i
>3088	Identifier	i
>3089	IdentifierDeclType	int
>3114	FunctionDef	get_nr_variable ()
>3115	ParameterList	 
>3116	ReturnType	int
>3117	CompoundStatement	 
>3118	ReturnStatement	 
>3119	PtrMemberAccess	prob -> n
>3120	Identifier	n
>3121	Identifier	prob
>3128	FunctionDef	Xv (float * v , float * Xv)
>3129	ParameterList	float * v , float * Xv
>3130	Parameter	 
>3131	Identifier	Xv
>3132	ParameterType	float *
>3133	Parameter	 
>3134	Identifier	v
>3135	ParameterType	float *
>3136	ReturnType	void
>3137	CompoundStatement	 
>3138	ForStatement	for ( i = 0 ; i < l ; i ++ )
>3139	CompoundStatement	 
>3140	WhileStatement	while ( s -> index != - 1 )
>3141	CompoundStatement	 
>3142	ExpressionStatement	 
>3143	IncDecOp	s ++
>3144	IncDec	++
>3145	Identifier	s
>3146	ExpressionStatement	 
>3147	AssignmentExpr	Xv [ i ] += v [ s -> index - 1 ] * s -> value
>3148	MultiplicativeExpression	v [ s -> index - 1 ] * s -> value
>3149	PtrMemberAccess	s -> value
>3150	Identifier	value
>3151	Identifier	s
>3152	ArrayIndexing	v [ s -> index - 1 ]
>3153	AdditiveExpression	s -> index - 1
>3154	PrimaryExpression	1
>3155	PtrMemberAccess	s -> index
>3156	Identifier	index
>3157	Identifier	s
>3158	Identifier	v
>3159	ArrayIndexing	Xv [ i ]
>3160	Identifier	i
>3161	Identifier	Xv
>3162	Condition	 
>3163	EqualityExpression	s -> index != - 1
>3164	UnaryOp	- 1
>3165	PrimaryExpression	1
>3166	UnaryOperator	-
>3167	PtrMemberAccess	s -> index
>3168	Identifier	index
>3169	Identifier	s
>3170	ExpressionStatement	 
>3171	AssignmentExpr	Xv [ i ] = 0
>3172	PrimaryExpression	0
>3173	ArrayIndexing	Xv [ i ]
>3174	Identifier	i
>3175	Identifier	Xv
>3176	IdentifierDeclStatement	 
>3177	IdentifierDecl	* s = x [ i ]
>3178	AssignmentExpr	* s = x [ i ]
>3179	ArrayIndexing	x [ i ]
>3180	Identifier	i
>3181	Identifier	x
>3182	Identifier	s
>3183	Identifier	s
>3184	IdentifierDeclType	feature_node *
>3185	IncDecOp	 
>3186	IncDec	++
>3187	Identifier	i
>3188	Condition	 
>3189	RelationalExpression	i < l
>3190	Identifier	l
>3191	Identifier	i
>3192	ForInit	 
>3193	AssignmentExpr	i = 0
>3194	PrimaryExpression	0
>3195	Identifier	i
>3196	IdentifierDeclStatement	 
>3197	IdentifierDecl	* * x = prob -> x
>3198	AssignmentExpr	* * x = prob -> x
>3199	PtrMemberAccess	prob -> x
>3200	Identifier	x
>3201	Identifier	prob
>3202	Identifier	x
>3203	Identifier	x
>3204	IdentifierDeclType	feature_node * *
>3205	IdentifierDeclStatement	 
>3206	IdentifierDecl	l = prob -> l
>3207	AssignmentExpr	l = prob -> l
>3208	PtrMemberAccess	prob -> l
>3209	Identifier	l
>3210	Identifier	prob
>3211	Identifier	l
>3212	Identifier	l
>3213	IdentifierDeclType	int
>3214	IdentifierDeclStatement	 
>3215	IdentifierDecl	i
>3216	Identifier	i
>3217	IdentifierDeclType	int
>3240	FunctionDef	subXv (float * v , float * Xv)
>3241	ParameterList	float * v , float * Xv
>3242	Parameter	 
>3243	Identifier	Xv
>3244	ParameterType	float *
>3245	Parameter	 
>3246	Identifier	v
>3247	ParameterType	float *
>3248	ReturnType	void
>3249	CompoundStatement	 
>3250	ForStatement	for ( i = 0 ; i < sizeI ; i ++ )
>3251	CompoundStatement	 
>3252	WhileStatement	while ( s -> index != - 1 )
>3253	CompoundStatement	 
>3254	ExpressionStatement	 
>3255	IncDecOp	s ++
>3256	IncDec	++
>3257	Identifier	s
>3258	ExpressionStatement	 
>3259	AssignmentExpr	Xv [ i ] += v [ s -> index - 1 ] * s -> value
>3260	MultiplicativeExpression	v [ s -> index - 1 ] * s -> value
>3261	PtrMemberAccess	s -> value
>3262	Identifier	value
>3263	Identifier	s
>3264	ArrayIndexing	v [ s -> index - 1 ]
>3265	AdditiveExpression	s -> index - 1
>3266	PrimaryExpression	1
>3267	PtrMemberAccess	s -> index
>3268	Identifier	index
>3269	Identifier	s
>3270	Identifier	v
>3271	ArrayIndexing	Xv [ i ]
>3272	Identifier	i
>3273	Identifier	Xv
>3274	Condition	 
>3275	EqualityExpression	s -> index != - 1
>3276	UnaryOp	- 1
>3277	PrimaryExpression	1
>3278	UnaryOperator	-
>3279	PtrMemberAccess	s -> index
>3280	Identifier	index
>3281	Identifier	s
>3282	ExpressionStatement	 
>3283	AssignmentExpr	Xv [ i ] = 0
>3284	PrimaryExpression	0
>3285	ArrayIndexing	Xv [ i ]
>3286	Identifier	i
>3287	Identifier	Xv
>3288	IdentifierDeclStatement	 
>3289	IdentifierDecl	* s = x [ I [ i ] ]
>3290	AssignmentExpr	* s = x [ I [ i ] ]
>3291	ArrayIndexing	x [ I [ i ] ]
>3292	ArrayIndexing	I [ i ]
>3293	Identifier	i
>3294	Identifier	I
>3295	Identifier	x
>3296	Identifier	s
>3297	Identifier	s
>3298	IdentifierDeclType	feature_node *
>3299	IncDecOp	 
>3300	IncDec	++
>3301	Identifier	i
>3302	Condition	 
>3303	RelationalExpression	i < sizeI
>3304	Identifier	sizeI
>3305	Identifier	i
>3306	ForInit	 
>3307	AssignmentExpr	i = 0
>3308	PrimaryExpression	0
>3309	Identifier	i
>3310	IdentifierDeclStatement	 
>3311	IdentifierDecl	* * x = prob -> x
>3312	AssignmentExpr	* * x = prob -> x
>3313	PtrMemberAccess	prob -> x
>3314	Identifier	x
>3315	Identifier	prob
>3316	Identifier	x
>3317	Identifier	x
>3318	IdentifierDeclType	feature_node * *
>3319	IdentifierDeclStatement	 
>3320	IdentifierDecl	i
>3321	Identifier	i
>3322	IdentifierDeclType	int
>3348	FunctionDef	subXTv (float * v , float * XTv)
>3349	ParameterList	float * v , float * XTv
>3350	Parameter	 
>3351	Identifier	XTv
>3352	ParameterType	float *
>3353	Parameter	 
>3354	Identifier	v
>3355	ParameterType	float *
>3356	ReturnType	void
>3357	CompoundStatement	 
>3358	ForStatement	for ( i = 0 ; i < sizeI ; i ++ )
>3359	CompoundStatement	 
>3360	WhileStatement	while ( s -> index != - 1 )
>3361	CompoundStatement	 
>3362	ExpressionStatement	 
>3363	IncDecOp	s ++
>3364	IncDec	++
>3365	Identifier	s
>3366	ExpressionStatement	 
>3367	AssignmentExpr	XTv [ s -> index - 1 ] += v [ i ] * s -> value
>3368	MultiplicativeExpression	v [ i ] * s -> value
>3369	PtrMemberAccess	s -> value
>3370	Identifier	value
>3371	Identifier	s
>3372	ArrayIndexing	v [ i ]
>3373	Identifier	i
>3374	Identifier	v
>3375	ArrayIndexing	XTv [ s -> index - 1 ]
>3376	AdditiveExpression	s -> index - 1
>3377	PrimaryExpression	1
>3378	PtrMemberAccess	s -> index
>3379	Identifier	index
>3380	Identifier	s
>3381	Identifier	XTv
>3382	Condition	 
>3383	EqualityExpression	s -> index != - 1
>3384	UnaryOp	- 1
>3385	PrimaryExpression	1
>3386	UnaryOperator	-
>3387	PtrMemberAccess	s -> index
>3388	Identifier	index
>3389	Identifier	s
>3390	IdentifierDeclStatement	 
>3391	IdentifierDecl	* s = x [ I [ i ] ]
>3392	AssignmentExpr	* s = x [ I [ i ] ]
>3393	ArrayIndexing	x [ I [ i ] ]
>3394	ArrayIndexing	I [ i ]
>3395	Identifier	i
>3396	Identifier	I
>3397	Identifier	x
>3398	Identifier	s
>3399	Identifier	s
>3400	IdentifierDeclType	feature_node *
>3401	IncDecOp	 
>3402	IncDec	++
>3403	Identifier	i
>3404	Condition	 
>3405	RelationalExpression	i < sizeI
>3406	Identifier	sizeI
>3407	Identifier	i
>3408	ForInit	 
>3409	AssignmentExpr	i = 0
>3410	PrimaryExpression	0
>3411	Identifier	i
>3412	ForStatement	for ( i = 0 ; i < n ; i ++ )
>3413	ExpressionStatement	 
>3414	AssignmentExpr	XTv [ i ] = 0
>3415	PrimaryExpression	0
>3416	ArrayIndexing	XTv [ i ]
>3417	Identifier	i
>3418	Identifier	XTv
>3419	IncDecOp	 
>3420	IncDec	++
>3421	Identifier	i
>3422	Condition	 
>3423	RelationalExpression	i < n
>3424	Identifier	n
>3425	Identifier	i
>3426	ForInit	 
>3427	AssignmentExpr	i = 0
>3428	PrimaryExpression	0
>3429	Identifier	i
>3430	IdentifierDeclStatement	 
>3431	IdentifierDecl	* * x = prob -> x
>3432	AssignmentExpr	* * x = prob -> x
>3433	PtrMemberAccess	prob -> x
>3434	Identifier	x
>3435	Identifier	prob
>3436	Identifier	x
>3437	Identifier	x
>3438	IdentifierDeclType	feature_node * *
>3439	IdentifierDeclStatement	 
>3440	IdentifierDecl	n = prob -> n
>3441	AssignmentExpr	n = prob -> n
>3442	PtrMemberAccess	prob -> n
>3443	Identifier	n
>3444	Identifier	prob
>3445	Identifier	n
>3446	Identifier	n
>3447	IdentifierDeclType	int
>3448	IdentifierDeclStatement	 
>3449	IdentifierDecl	i
>3450	Identifier	i
>3451	IdentifierDeclType	int
>3492	FunctionDef	l2_lr_fun (const problem * prob , float Cp , float Cn)
>3493	ParameterList	const problem * prob , float Cp , float Cn
>3494	Parameter	 
>3495	Identifier	Cn
>3496	ParameterType	float
>3497	Parameter	 
>3498	Identifier	Cp
>3499	ParameterType	float
>3500	Parameter	 
>3501	Identifier	prob
>3502	ParameterType	const problem *
>3503	CompoundStatement	 
>3504	ForStatement	for ( int i = 0 ; i != l ; ++ i )
>3505	ExpressionStatement	 
>3506	AssignmentExpr	C [ i ] = ( y [ i ] == 1 ) ? Cp 
>3507	ConditionalExpression	( y [ i ] == 1 ) ? Cp 
>3508	Identifier	Cn
>3509	Identifier	Cp
>3510	Condition	y [ i ] == 1
>3511	EqualityExpression	y [ i ] == 1
>3512	PrimaryExpression	1
>3513	ArrayIndexing	y [ i ]
>3514	Identifier	i
>3515	Identifier	y
>3516	ArrayIndexing	C [ i ]
>3517	Identifier	i
>3518	Identifier	C
>3519	UnaryExpression	 
>3520	Identifier	i
>3521	IncDec	++
>3522	Condition	 
>3523	EqualityExpression	i != l
>3524	Identifier	l
>3525	Identifier	i
>3526	ForInit	 
>3527	IdentifierDeclStatement	int i = 0 ;
>3528	IdentifierDecl	i = 0
>3529	AssignmentExpr	i = 0
>3530	PrimaryExpression	0
>3531	Identifier	i
>3532	Identifier	i
>3533	IdentifierDeclType	int
>3534	ExpressionStatement	 
>3535	AssignmentExpr	C = new float [ l ]
>3536	Identifier	l
>3537	Identifier	C
>3538	ExpressionStatement	 
>3539	AssignmentExpr	D = new float [ l ]
>3540	Identifier	l
>3541	Identifier	D
>3542	ExpressionStatement	 
>3543	AssignmentExpr	z = new float [ l ]
>3544	Identifier	l
>3545	Identifier	z
>3546	ExpressionStatement	 
>3547	AssignmentExpr	this -> prob = prob
>3548	Identifier	prob
>3549	PtrMemberAccess	this -> prob
>3550	Identifier	prob
>3551	Identifier	this
>3552	IdentifierDeclStatement	 
>3553	IdentifierDecl	* y = prob -> y
>3554	AssignmentExpr	* y = prob -> y
>3555	PtrMemberAccess	prob -> y
>3556	Identifier	y
>3557	Identifier	prob
>3558	Identifier	y
>3559	Identifier	y
>3560	IdentifierDeclType	int *
>3561	IdentifierDeclStatement	 
>3562	IdentifierDecl	l = prob -> l
>3563	AssignmentExpr	l = prob -> l
>3564	PtrMemberAccess	prob -> l
>3565	Identifier	l
>3566	Identifier	prob
>3567	Identifier	l
>3568	Identifier	l
>3569	IdentifierDeclType	int
>3591	FunctionDef	~l2_lr_fun ()
>3592	ParameterList	 
>3593	CompoundStatement	 
>3594	ExpressionStatement	 
>3595	Identifier	C
>3596	Statement	 
>3597	Statement	 
>3598	Statement	 
>3599	ExpressionStatement	 
>3600	Identifier	D
>3601	Statement	 
>3602	Statement	 
>3603	Statement	 
>3604	ExpressionStatement	 
>3605	Identifier	z
>3606	Statement	 
>3607	Statement	 
>3608	Statement	 
>3612	FunctionDef	fun (float * w)
>3613	ParameterList	float * w
>3614	Parameter	 
>3615	Identifier	w
>3616	ParameterType	float *
>3617	ReturnType	float
>3618	CompoundStatement	 
>3619	ReturnStatement	 
>3620	Identifier	f
>3621	ExpressionStatement	 
>3622	AssignmentExpr	f /= 2.0f
>3623	PrimaryExpression	2.0f
>3624	Identifier	f
>3625	ForStatement	for ( int i = 0 ; i != n ; ++ i )
>3626	ExpressionStatement	 
>3627	AssignmentExpr	f += w [ i ] * w [ i ]
>3628	MultiplicativeExpression	w [ i ] * w [ i ]
>3629	ArrayIndexing	w [ i ]
>3630	Identifier	i
>3631	Identifier	w
>3632	ArrayIndexing	w [ i ]
>3633	Identifier	i
>3634	Identifier	w
>3635	Identifier	f
>3636	UnaryExpression	 
>3637	Identifier	i
>3638	IncDec	++
>3639	Condition	 
>3640	EqualityExpression	i != n
>3641	Identifier	n
>3642	Identifier	i
>3643	ForInit	 
>3644	IdentifierDeclStatement	int i = 0 ;
>3645	IdentifierDecl	i = 0
>3646	AssignmentExpr	i = 0
>3647	PrimaryExpression	0
>3648	Identifier	i
>3649	Identifier	i
>3650	IdentifierDeclType	int
>3651	ExpressionStatement	 
>3652	AssignmentExpr	f = 2.0f * f
>3653	MultiplicativeExpression	2.0f * f
>3654	Identifier	f
>3655	PrimaryExpression	2.0f
>3656	Identifier	f
>3657	ForStatement	for ( int i = 0 ; i != l ; ++ i )
>3658	CompoundStatement	 
>3659	IfStatement	if ( yz >= 0 )
>3660	ElseStatement	else
>3661	ExpressionStatement	 
>3662	AssignmentExpr	f += C [ i ] * ( - yz + log ( 1.0f + exp ( yz ) ) )
>3663	MultiplicativeExpression	C [ i ] * ( - yz + log ( 1.0f + exp ( yz ) ) )
>3664	AdditiveExpression	- yz + log ( 1.0f + exp ( yz ) )
>3665	CallExpression	log ( 1.0f + exp ( yz ) )
>3666	ArgumentList	1.0f + exp ( yz )
>3667	Argument	1.0f + exp ( yz )
>3668	AdditiveExpression	1.0f + exp ( yz )
>3669	CallExpression	exp ( yz )
>3670	ArgumentList	yz
>3671	Argument	yz
>3672	Identifier	yz
>3673	Callee	exp
>3674	Identifier	exp
>3675	PrimaryExpression	1.0f
>3676	Callee	log
>3677	Identifier	log
>3678	UnaryOp	- yz
>3679	Identifier	yz
>3680	UnaryOperator	-
>3681	ArrayIndexing	C [ i ]
>3682	Identifier	i
>3683	Identifier	C
>3684	Identifier	f
>3685	ExpressionStatement	 
>3686	AssignmentExpr	f += C [ i ] * log ( 1.0f + exp ( - yz ) )
>3687	MultiplicativeExpression	C [ i ] * log ( 1.0f + exp ( - yz ) )
>3688	CallExpression	log ( 1.0f + exp ( - yz ) )
>3689	ArgumentList	1.0f + exp ( - yz )
>3690	Argument	1.0f + exp ( - yz )
>3691	AdditiveExpression	1.0f + exp ( - yz )
>3692	CallExpression	exp ( - yz )
>3693	ArgumentList	- yz
>3694	Argument	- yz
>3695	UnaryOp	- yz
>3696	Identifier	yz
>3697	UnaryOperator	-
>3698	Callee	exp
>3699	Identifier	exp
>3700	PrimaryExpression	1.0f
>3701	Callee	log
>3702	Identifier	log
>3703	ArrayIndexing	C [ i ]
>3704	Identifier	i
>3705	Identifier	C
>3706	Identifier	f
>3707	Condition	 
>3708	RelationalExpression	yz >= 0
>3709	PrimaryExpression	0
>3710	Identifier	yz
>3711	IdentifierDeclStatement	 
>3712	IdentifierDecl	yz = y [ i ] * z [ i ]
>3713	AssignmentExpr	yz = y [ i ] * z [ i ]
>3714	MultiplicativeExpression	y [ i ] * z [ i ]
>3715	ArrayIndexing	z [ i ]
>3716	Identifier	i
>3717	Identifier	z
>3718	ArrayIndexing	y [ i ]
>3719	Identifier	i
>3720	Identifier	y
>3721	Identifier	yz
>3722	Identifier	yz
>3723	IdentifierDeclType	float
>3724	UnaryExpression	 
>3725	Identifier	i
>3726	IncDec	++
>3727	Condition	 
>3728	EqualityExpression	i != l
>3729	Identifier	l
>3730	Identifier	i
>3731	ForInit	 
>3732	IdentifierDeclStatement	int i = 0 ;
>3733	IdentifierDecl	i = 0
>3734	AssignmentExpr	i = 0
>3735	PrimaryExpression	0
>3736	Identifier	i
>3737	Identifier	i
>3738	IdentifierDeclType	int
>3739	ExpressionStatement	 
>3740	CallExpression	Xv ( w , z )
>3741	ArgumentList	w
>3742	Argument	z
>3743	Identifier	z
>3744	Argument	w
>3745	Identifier	w
>3746	Callee	Xv
>3747	Identifier	Xv
>3748	IdentifierDeclStatement	 
>3749	IdentifierDecl	n = prob -> n
>3750	AssignmentExpr	n = prob -> n
>3751	PtrMemberAccess	prob -> n
>3752	Identifier	n
>3753	Identifier	prob
>3754	Identifier	n
>3755	Identifier	n
>3756	IdentifierDeclType	int
>3757	IdentifierDeclStatement	 
>3758	IdentifierDecl	l = prob -> l
>3759	AssignmentExpr	l = prob -> l
>3760	PtrMemberAccess	prob -> l
>3761	Identifier	l
>3762	Identifier	prob
>3763	Identifier	l
>3764	Identifier	l
>3765	IdentifierDeclType	int
>3766	IdentifierDeclStatement	 
>3767	IdentifierDecl	* y = prob -> y
>3768	AssignmentExpr	* y = prob -> y
>3769	PtrMemberAccess	prob -> y
>3770	Identifier	y
>3771	Identifier	prob
>3772	Identifier	y
>3773	Identifier	y
>3774	IdentifierDeclType	int *
>3775	IdentifierDeclStatement	 
>3776	IdentifierDecl	f = 0.0f
>3777	AssignmentExpr	f = 0.0f
>3778	PrimaryExpression	0.0f
>3779	Identifier	f
>3780	Identifier	f
>3781	IdentifierDeclType	float
>3806	FunctionDef	grad (float * w , float * g)
>3807	ParameterList	float * w , float * g
>3808	Parameter	 
>3809	Identifier	g
>3810	ParameterType	float *
>3811	Parameter	 
>3812	Identifier	w
>3813	ParameterType	float *
>3814	ReturnType	void
>3815	CompoundStatement	 
>3816	ForStatement	for ( int i = 0 ; i != n ; ++ i )
>3817	ExpressionStatement	 
>3818	AssignmentExpr	g [ i ] = w [ i ] + g [ i ]
>3819	AdditiveExpression	w [ i ] + g [ i ]
>3820	ArrayIndexing	g [ i ]
>3821	Identifier	i
>3822	Identifier	g
>3823	ArrayIndexing	w [ i ]
>3824	Identifier	i
>3825	Identifier	w
>3826	ArrayIndexing	g [ i ]
>3827	Identifier	i
>3828	Identifier	g
>3829	UnaryExpression	 
>3830	Identifier	i
>3831	IncDec	++
>3832	Condition	 
>3833	EqualityExpression	i != n
>3834	Identifier	n
>3835	Identifier	i
>3836	ForInit	 
>3837	IdentifierDeclStatement	int i = 0 ;
>3838	IdentifierDecl	i = 0
>3839	AssignmentExpr	i = 0
>3840	PrimaryExpression	0
>3841	Identifier	i
>3842	Identifier	i
>3843	IdentifierDeclType	int
>3844	ExpressionStatement	 
>3845	CallExpression	XTv ( z , g )
>3846	ArgumentList	z
>3847	Argument	g
>3848	Identifier	g
>3849	Argument	z
>3850	Identifier	z
>3851	Callee	XTv
>3852	Identifier	XTv
>3853	ForStatement	for ( int i = 0 ; i != l ; ++ i )
>3854	CompoundStatement	 
>3855	ExpressionStatement	 
>3856	AssignmentExpr	z [ i ] = C [ i ] * ( z [ i ] - 1.0f ) * y [ i ]
>3857	MultiplicativeExpression	C [ i ] * ( z [ i ] - 1.0f ) * y [ i ]
>3858	MultiplicativeExpression	( z [ i ] - 1.0f ) * y [ i ]
>3859	ArrayIndexing	y [ i ]
>3860	Identifier	i
>3861	Identifier	y
>3862	AdditiveExpression	z [ i ] - 1.0f
>3863	PrimaryExpression	1.0f
>3864	ArrayIndexing	z [ i ]
>3865	Identifier	i
>3866	Identifier	z
>3867	ArrayIndexing	C [ i ]
>3868	Identifier	i
>3869	Identifier	C
>3870	ArrayIndexing	z [ i ]
>3871	Identifier	i
>3872	Identifier	z
>3873	ExpressionStatement	 
>3874	AssignmentExpr	D [ i ] = z [ i ] * ( 1.0f - z [ i ] )
>3875	MultiplicativeExpression	z [ i ] * ( 1.0f - z [ i ] )
>3876	AdditiveExpression	1.0f - z [ i ]
>3877	ArrayIndexing	z [ i ]
>3878	Identifier	i
>3879	Identifier	z
>3880	PrimaryExpression	1.0f
>3881	ArrayIndexing	z [ i ]
>3882	Identifier	i
>3883	Identifier	z
>3884	ArrayIndexing	D [ i ]
>3885	Identifier	i
>3886	Identifier	D
>3887	ExpressionStatement	 
>3888	AssignmentExpr	z [ i ] = 1.0f / ( 1.0f + exp ( - y [ i ] * z [ i ] ) )
>3889	MultiplicativeExpression	1.0f / ( 1.0f + exp ( - y [ i ] * z [ i ] ) )
>3890	AdditiveExpression	1.0f + exp ( - y [ i ] * z [ i ] )
>3891	CallExpression	exp ( - y [ i ] * z [ i ] )
>3892	ArgumentList	- y [ i ] * z [ i ]
>3893	Argument	- y [ i ] * z [ i ]
>3894	MultiplicativeExpression	- y [ i ] * z [ i ]
>3895	ArrayIndexing	z [ i ]
>3896	Identifier	i
>3897	Identifier	z
>3898	UnaryOp	- y [ i ]
>3899	ArrayIndexing	y [ i ]
>3900	Identifier	i
>3901	Identifier	y
>3902	UnaryOperator	-
>3903	Callee	exp
>3904	Identifier	exp
>3905	PrimaryExpression	1.0f
>3906	PrimaryExpression	1.0f
>3907	ArrayIndexing	z [ i ]
>3908	Identifier	i
>3909	Identifier	z
>3910	UnaryExpression	 
>3911	Identifier	i
>3912	IncDec	++
>3913	Condition	 
>3914	EqualityExpression	i != l
>3915	Identifier	l
>3916	Identifier	i
>3917	ForInit	 
>3918	IdentifierDeclStatement	int i = 0 ;
>3919	IdentifierDecl	i = 0
>3920	AssignmentExpr	i = 0
>3921	PrimaryExpression	0
>3922	Identifier	i
>3923	Identifier	i
>3924	IdentifierDeclType	int
>3925	IdentifierDeclStatement	 
>3926	IdentifierDecl	n = prob -> n
>3927	AssignmentExpr	n = prob -> n
>3928	PtrMemberAccess	prob -> n
>3929	Identifier	n
>3930	Identifier	prob
>3931	Identifier	n
>3932	Identifier	n
>3933	IdentifierDeclType	int
>3934	IdentifierDeclStatement	 
>3935	IdentifierDecl	l = prob -> l
>3936	AssignmentExpr	l = prob -> l
>3937	PtrMemberAccess	prob -> l
>3938	Identifier	l
>3939	Identifier	prob
>3940	Identifier	l
>3941	Identifier	l
>3942	IdentifierDeclType	int
>3943	IdentifierDeclStatement	 
>3944	IdentifierDecl	* y = prob -> y
>3945	AssignmentExpr	* y = prob -> y
>3946	PtrMemberAccess	prob -> y
>3947	Identifier	y
>3948	Identifier	prob
>3949	Identifier	y
>3950	Identifier	y
>3951	IdentifierDeclType	int *
>3977	FunctionDef	Hv (float * s , float * Hs)
>3978	ParameterList	float * s , float * Hs
>3979	Parameter	 
>3980	Identifier	Hs
>3981	ParameterType	float *
>3982	Parameter	 
>3983	Identifier	s
>3984	ParameterType	float *
>3985	ReturnType	void
>3986	CompoundStatement	 
>3987	ExpressionStatement	 
>3988	Identifier	wa
>3989	Statement	 
>3990	Statement	 
>3991	Statement	 
>3992	ForStatement	for ( int i = 0 ; i != n ; ++ i )
>3993	ExpressionStatement	 
>3994	AssignmentExpr	Hs [ i ] = s [ i ] + Hs [ i ]
>3995	AdditiveExpression	s [ i ] + Hs [ i ]
>3996	ArrayIndexing	Hs [ i ]
>3997	Identifier	i
>3998	Identifier	Hs
>3999	ArrayIndexing	s [ i ]
>4000	Identifier	i
>4001	Identifier	s
>4002	ArrayIndexing	Hs [ i ]
>4003	Identifier	i
>4004	Identifier	Hs
>4005	UnaryExpression	 
>4006	Identifier	i
>4007	IncDec	++
>4008	Condition	 
>4009	EqualityExpression	i != n
>4010	Identifier	n
>4011	Identifier	i
>4012	ForInit	 
>4013	IdentifierDeclStatement	int i = 0 ;
>4014	IdentifierDecl	i = 0
>4015	AssignmentExpr	i = 0
>4016	PrimaryExpression	0
>4017	Identifier	i
>4018	Identifier	i
>4019	IdentifierDeclType	int
>4020	ExpressionStatement	 
>4021	CallExpression	XTv ( wa , Hs )
>4022	ArgumentList	wa
>4023	Argument	Hs
>4024	Identifier	Hs
>4025	Argument	wa
>4026	Identifier	wa
>4027	Callee	XTv
>4028	Identifier	XTv
>4029	ForStatement	for ( int i = 0 ; i != l ; ++ i )
>4030	ExpressionStatement	 
>4031	AssignmentExpr	wa [ i ] = C [ i ] * D [ i ] * wa [ i ]
>4032	MultiplicativeExpression	C [ i ] * D [ i ] * wa [ i ]
>4033	MultiplicativeExpression	D [ i ] * wa [ i ]
>4034	ArrayIndexing	wa [ i ]
>4035	Identifier	i
>4036	Identifier	wa
>4037	ArrayIndexing	D [ i ]
>4038	Identifier	i
>4039	Identifier	D
>4040	ArrayIndexing	C [ i ]
>4041	Identifier	i
>4042	Identifier	C
>4043	ArrayIndexing	wa [ i ]
>4044	Identifier	i
>4045	Identifier	wa
>4046	UnaryExpression	 
>4047	Identifier	i
>4048	IncDec	++
>4049	Condition	 
>4050	EqualityExpression	i != l
>4051	Identifier	l
>4052	Identifier	i
>4053	ForInit	 
>4054	IdentifierDeclStatement	int i = 0 ;
>4055	IdentifierDecl	i = 0
>4056	AssignmentExpr	i = 0
>4057	PrimaryExpression	0
>4058	Identifier	i
>4059	Identifier	i
>4060	IdentifierDeclType	int
>4061	ExpressionStatement	 
>4062	CallExpression	Xv ( s , wa )
>4063	ArgumentList	s
>4064	Argument	wa
>4065	Identifier	wa
>4066	Argument	s
>4067	Identifier	s
>4068	Callee	Xv
>4069	Identifier	Xv
>4070	IdentifierDeclStatement	 
>4071	IdentifierDecl	* wa = new float [ l ]
>4072	AssignmentExpr	* wa = new float [ l ]
>4073	Identifier	l
>4074	Identifier	l
>4075	Identifier	wa
>4076	IdentifierDeclType	float *
>4077	IdentifierDeclStatement	 
>4078	IdentifierDecl	n = prob -> n
>4079	AssignmentExpr	n = prob -> n
>4080	PtrMemberAccess	prob -> n
>4081	Identifier	n
>4082	Identifier	prob
>4083	Identifier	n
>4084	Identifier	n
>4085	IdentifierDeclType	int
>4086	IdentifierDeclStatement	 
>4087	IdentifierDecl	l = prob -> l
>4088	AssignmentExpr	l = prob -> l
>4089	PtrMemberAccess	prob -> l
>4090	Identifier	l
>4091	Identifier	prob
>4092	Identifier	l
>4093	Identifier	l
>4094	IdentifierDeclType	int
>4116	FunctionDef	get_nr_variable ()
>4117	ParameterList	 
>4118	ReturnType	int
>4119	CompoundStatement	 
>4120	ReturnStatement	 
>4121	PtrMemberAccess	prob -> n
>4122	Identifier	n
>4123	Identifier	prob
>4130	FunctionDef	Xv (float * v , float * Xv)
>4131	ParameterList	float * v , float * Xv
>4132	Parameter	 
>4133	Identifier	Xv
>4134	ParameterType	float *
>4135	Parameter	 
>4136	Identifier	v
>4137	ParameterType	float *
>4138	ReturnType	void
>4139	CompoundStatement	 
>4140	ForStatement	for ( i = 0 ; i < l ; i ++ )
>4141	CompoundStatement	 
>4142	WhileStatement	while ( s -> index != - 1 )
>4143	CompoundStatement	 
>4144	ExpressionStatement	 
>4145	IncDecOp	s ++
>4146	IncDec	++
>4147	Identifier	s
>4148	ExpressionStatement	 
>4149	AssignmentExpr	Xv [ i ] += v [ s -> index - 1 ] * s -> value
>4150	MultiplicativeExpression	v [ s -> index - 1 ] * s -> value
>4151	PtrMemberAccess	s -> value
>4152	Identifier	value
>4153	Identifier	s
>4154	ArrayIndexing	v [ s -> index - 1 ]
>4155	AdditiveExpression	s -> index - 1
>4156	PrimaryExpression	1
>4157	PtrMemberAccess	s -> index
>4158	Identifier	index
>4159	Identifier	s
>4160	Identifier	v
>4161	ArrayIndexing	Xv [ i ]
>4162	Identifier	i
>4163	Identifier	Xv
>4164	Condition	 
>4165	EqualityExpression	s -> index != - 1
>4166	UnaryOp	- 1
>4167	PrimaryExpression	1
>4168	UnaryOperator	-
>4169	PtrMemberAccess	s -> index
>4170	Identifier	index
>4171	Identifier	s
>4172	ExpressionStatement	 
>4173	AssignmentExpr	Xv [ i ] = 0
>4174	PrimaryExpression	0
>4175	ArrayIndexing	Xv [ i ]
>4176	Identifier	i
>4177	Identifier	Xv
>4178	IdentifierDeclStatement	 
>4179	IdentifierDecl	* s = x [ i ]
>4180	AssignmentExpr	* s = x [ i ]
>4181	ArrayIndexing	x [ i ]
>4182	Identifier	i
>4183	Identifier	x
>4184	Identifier	s
>4185	Identifier	s
>4186	IdentifierDeclType	feature_node *
>4187	IncDecOp	 
>4188	IncDec	++
>4189	Identifier	i
>4190	Condition	 
>4191	RelationalExpression	i < l
>4192	Identifier	l
>4193	Identifier	i
>4194	ForInit	 
>4195	AssignmentExpr	i = 0
>4196	PrimaryExpression	0
>4197	Identifier	i
>4198	IdentifierDeclStatement	 
>4199	IdentifierDecl	* * x = prob -> x
>4200	AssignmentExpr	* * x = prob -> x
>4201	PtrMemberAccess	prob -> x
>4202	Identifier	x
>4203	Identifier	prob
>4204	Identifier	x
>4205	Identifier	x
>4206	IdentifierDeclType	feature_node * *
>4207	IdentifierDeclStatement	 
>4208	IdentifierDecl	l = prob -> l
>4209	AssignmentExpr	l = prob -> l
>4210	PtrMemberAccess	prob -> l
>4211	Identifier	l
>4212	Identifier	prob
>4213	Identifier	l
>4214	Identifier	l
>4215	IdentifierDeclType	int
>4216	IdentifierDeclStatement	 
>4217	IdentifierDecl	i
>4218	Identifier	i
>4219	IdentifierDeclType	int
>4242	FunctionDef	XTv (float * v , float * XTv)
>4243	ParameterList	float * v , float * XTv
>4244	Parameter	 
>4245	Identifier	XTv
>4246	ParameterType	float *
>4247	Parameter	 
>4248	Identifier	v
>4249	ParameterType	float *
>4250	ReturnType	void
>4251	CompoundStatement	 
>4252	ForStatement	for ( i = 0 ; i < l ; i ++ )
>4253	CompoundStatement	 
>4254	WhileStatement	while ( s -> index != - 1 )
>4255	CompoundStatement	 
>4256	ExpressionStatement	 
>4257	IncDecOp	s ++
>4258	IncDec	++
>4259	Identifier	s
>4260	ExpressionStatement	 
>4261	AssignmentExpr	XTv [ s -> index - 1 ] += v [ i ] * s -> value
>4262	MultiplicativeExpression	v [ i ] * s -> value
>4263	PtrMemberAccess	s -> value
>4264	Identifier	value
>4265	Identifier	s
>4266	ArrayIndexing	v [ i ]
>4267	Identifier	i
>4268	Identifier	v
>4269	ArrayIndexing	XTv [ s -> index - 1 ]
>4270	AdditiveExpression	s -> index - 1
>4271	PrimaryExpression	1
>4272	PtrMemberAccess	s -> index
>4273	Identifier	index
>4274	Identifier	s
>4275	Identifier	XTv
>4276	Condition	 
>4277	EqualityExpression	s -> index != - 1
>4278	UnaryOp	- 1
>4279	PrimaryExpression	1
>4280	UnaryOperator	-
>4281	PtrMemberAccess	s -> index
>4282	Identifier	index
>4283	Identifier	s
>4284	IdentifierDeclStatement	 
>4285	IdentifierDecl	* s = x [ i ]
>4286	AssignmentExpr	* s = x [ i ]
>4287	ArrayIndexing	x [ i ]
>4288	Identifier	i
>4289	Identifier	x
>4290	Identifier	s
>4291	Identifier	s
>4292	IdentifierDeclType	feature_node *
>4293	IncDecOp	 
>4294	IncDec	++
>4295	Identifier	i
>4296	Condition	 
>4297	RelationalExpression	i < l
>4298	Identifier	l
>4299	Identifier	i
>4300	ForInit	 
>4301	AssignmentExpr	i = 0
>4302	PrimaryExpression	0
>4303	Identifier	i
>4304	ForStatement	for ( i = 0 ; i < n ; i ++ )
>4305	ExpressionStatement	 
>4306	AssignmentExpr	XTv [ i ] = 0
>4307	PrimaryExpression	0
>4308	ArrayIndexing	XTv [ i ]
>4309	Identifier	i
>4310	Identifier	XTv
>4311	IncDecOp	 
>4312	IncDec	++
>4313	Identifier	i
>4314	Condition	 
>4315	RelationalExpression	i < n
>4316	Identifier	n
>4317	Identifier	i
>4318	ForInit	 
>4319	AssignmentExpr	i = 0
>4320	PrimaryExpression	0
>4321	Identifier	i
>4322	IdentifierDeclStatement	 
>4323	IdentifierDecl	* * x = prob -> x
>4324	AssignmentExpr	* * x = prob -> x
>4325	PtrMemberAccess	prob -> x
>4326	Identifier	x
>4327	Identifier	prob
>4328	Identifier	x
>4329	Identifier	x
>4330	IdentifierDeclType	feature_node * *
>4331	IdentifierDeclStatement	 
>4332	IdentifierDecl	n = prob -> n
>4333	AssignmentExpr	n = prob -> n
>4334	PtrMemberAccess	prob -> n
>4335	Identifier	n
>4336	Identifier	prob
>4337	Identifier	n
>4338	Identifier	n
>4339	IdentifierDeclType	int
>4340	IdentifierDeclStatement	 
>4341	IdentifierDecl	l = prob -> l
>4342	AssignmentExpr	l = prob -> l
>4343	PtrMemberAccess	prob -> l
>4344	Identifier	l
>4345	Identifier	prob
>4346	Identifier	l
>4347	Identifier	l
>4348	IdentifierDeclType	int
>4349	IdentifierDeclStatement	 
>4350	IdentifierDecl	i
>4351	Identifier	i
>4352	IdentifierDeclType	int
>4385	FunctionDef	linear 
>4386	ParameterList	const problem * prob , int * nr_class_ret , int * * label_ret , int * * start_ret , int * * count_ret , int * perm
>4387	Parameter	 
>4388	Identifier	perm
>4389	ParameterType	int *
>4390	Parameter	 
>4391	Identifier	count_ret
>4392	ParameterType	int * *
>4393	Parameter	 
>4394	Identifier	start_ret
>4395	ParameterType	int * *
>4396	Parameter	 
>4397	Identifier	label_ret
>4398	ParameterType	int * *
>4399	Parameter	 
>4400	Identifier	nr_class_ret
>4401	ParameterType	int *
>4402	Parameter	 
>4403	Identifier	prob
>4404	ParameterType	const problem *
>4405	ReturnType	void
>4406	CompoundStatement	 
>4407	ExpressionStatement	 
>4408	CallExpression	free ( data_label )
>4409	ArgumentList	data_label
>4410	Argument	data_label
>4411	Identifier	data_label
>4412	Callee	free
>4413	Identifier	free
>4414	ExpressionStatement	 
>4415	AssignmentExpr	* count_ret = count
>4416	Identifier	count
>4417	UnaryOp	* count_ret
>4418	Identifier	count_ret
>4419	UnaryOperator	*
>4420	ExpressionStatement	 
>4421	AssignmentExpr	* start_ret = start
>4422	Identifier	start
>4423	UnaryOp	* start_ret
>4424	Identifier	start_ret
>4425	UnaryOperator	*
>4426	ExpressionStatement	 
>4427	AssignmentExpr	* label_ret = label
>4428	Identifier	label
>4429	UnaryOp	* label_ret
>4430	Identifier	label_ret
>4431	UnaryOperator	*
>4432	ExpressionStatement	 
>4433	AssignmentExpr	* nr_class_ret = nr_class
>4434	Identifier	nr_class
>4435	UnaryOp	* nr_class_ret
>4436	Identifier	nr_class_ret
>4437	UnaryOperator	*
>4438	ForStatement	for ( i = 1 ; i < nr_class ; i ++ )
>4439	ExpressionStatement	 
>4440	AssignmentExpr	start [ i ] = start [ i - 1 ] + count [ i - 1 ]
>4441	AdditiveExpression	start [ i - 1 ] + count [ i - 1 ]
>4442	ArrayIndexing	count [ i - 1 ]
>4443	AdditiveExpression	i - 1
>4444	PrimaryExpression	1
>4445	Identifier	i
>4446	Identifier	count
>4447	ArrayIndexing	start [ i - 1 ]
>4448	AdditiveExpression	i - 1
>4449	PrimaryExpression	1
>4450	Identifier	i
>4451	Identifier	start
>4452	ArrayIndexing	start [ i ]
>4453	Identifier	i
>4454	Identifier	start
>4455	IncDecOp	 
>4456	IncDec	++
>4457	Identifier	i
>4458	Condition	 
>4459	RelationalExpression	i < nr_class
>4460	Identifier	nr_class
>4461	Identifier	i
>4462	ForInit	 
>4463	AssignmentExpr	i = 1
>4464	PrimaryExpression	1
>4465	Identifier	i
>4466	ExpressionStatement	 
>4467	AssignmentExpr	start [ 0 ] = 0
>4468	PrimaryExpression	0
>4469	ArrayIndexing	start [ 0 ]
>4470	PrimaryExpression	0
>4471	Identifier	start
>4472	ForStatement	for ( i = 0 ; i < l ; i ++ )
>4473	CompoundStatement	 
>4474	ExpressionStatement	 
>4475	UnaryExpression	++ start [ data_label [ i ] ]
>4476	ArrayIndexing	start [ data_label [ i ] ]
>4477	ArrayIndexing	data_label [ i ]
>4478	Identifier	i
>4479	Identifier	data_label
>4480	Identifier	start
>4481	IncDec	++
>4482	ExpressionStatement	 
>4483	AssignmentExpr	perm [ start [ data_label [ i ] ] ] = i
>4484	Identifier	i
>4485	ArrayIndexing	perm [ start [ data_label [ i ] ] ]
>4486	ArrayIndexing	start [ data_label [ i ] ]
>4487	ArrayIndexing	data_label [ i ]
>4488	Identifier	i
>4489	Identifier	data_label
>4490	Identifier	start
>4491	Identifier	perm
>4492	IncDecOp	 
>4493	IncDec	++
>4494	Identifier	i
>4495	Condition	 
>4496	RelationalExpression	i < l
>4497	Identifier	l
>4498	Identifier	i
>4499	ForInit	 
>4500	AssignmentExpr	i = 0
>4501	PrimaryExpression	0
>4502	Identifier	i
>4503	ForStatement	for ( i = 1 ; i < nr_class ; i ++ )
>4504	ExpressionStatement	 
>4505	AssignmentExpr	start [ i ] = start [ i - 1 ] + count [ i - 1 ]
>4506	AdditiveExpression	start [ i - 1 ] + count [ i - 1 ]
>4507	ArrayIndexing	count [ i - 1 ]
>4508	AdditiveExpression	i - 1
>4509	PrimaryExpression	1
>4510	Identifier	i
>4511	Identifier	count
>4512	ArrayIndexing	start [ i - 1 ]
>4513	AdditiveExpression	i - 1
>4514	PrimaryExpression	1
>4515	Identifier	i
>4516	Identifier	start
>4517	ArrayIndexing	start [ i ]
>4518	Identifier	i
>4519	Identifier	start
>4520	IncDecOp	 
>4521	IncDec	++
>4522	Identifier	i
>4523	Condition	 
>4524	RelationalExpression	i < nr_class
>4525	Identifier	nr_class
>4526	Identifier	i
>4527	ForInit	 
>4528	AssignmentExpr	i = 1
>4529	PrimaryExpression	1
>4530	Identifier	i
>4531	ExpressionStatement	 
>4532	AssignmentExpr	start [ 0 ] = 0
>4533	PrimaryExpression	0
>4534	ArrayIndexing	start [ 0 ]
>4535	PrimaryExpression	0
>4536	Identifier	start
>4537	IdentifierDeclStatement	 
>4538	IdentifierDecl	* start = Malloc ( int , nr_class )
>4539	AssignmentExpr	* start = Malloc ( int , nr_class )
>4540	CallExpression	Malloc ( int , nr_class )
>4541	ArgumentList	int
>4542	Argument	nr_class
>4543	Identifier	nr_class
>4544	Argument	int
>4545	Identifier	int
>4546	Callee	Malloc
>4547	Identifier	Malloc
>4548	Identifier	start
>4549	Identifier	start
>4550	IdentifierDeclType	int *
>4551	ForStatement	for ( i = 0 ; i < l ; i ++ )
>4552	CompoundStatement	 
>4553	IfStatement	if ( j == nr_class )
>4554	CompoundStatement	 
>4555	ExpressionStatement	 
>4556	UnaryExpression	++ nr_class
>4557	Identifier	nr_class
>4558	IncDec	++
>4559	ExpressionStatement	 
>4560	AssignmentExpr	count [ nr_class ] = 1
>4561	PrimaryExpression	1
>4562	ArrayIndexing	count [ nr_class ]
>4563	Identifier	nr_class
>4564	Identifier	count
>4565	ExpressionStatement	 
>4566	AssignmentExpr	label [ nr_class ] = this_label
>4567	Identifier	this_label
>4568	ArrayIndexing	label [ nr_class ]
>4569	Identifier	nr_class
>4570	Identifier	label
>4571	IfStatement	if ( nr_class == max_nr_class )
>4572	CompoundStatement	 
>4573	ExpressionStatement	 
>4574	AssignmentExpr	count = ( int * ) realloc ( count , max_nr_class * sizeof ( int ) )
>4575	CastExpression	( int * ) realloc ( count , max_nr_class * sizeof ( int ) )
>4576	CallExpression	realloc ( count , max_nr_class * sizeof ( int ) )
>4577	ArgumentList	count
>4578	Argument	max_nr_class * sizeof ( int )
>4579	MultiplicativeExpression	max_nr_class * sizeof ( int )
>4580	SizeofExpr	sizeof ( int )
>4581	SizeofOperand	int
>4582	Sizeof	sizeof
>4583	Identifier	max_nr_class
>4584	Argument	count
>4585	Identifier	count
>4586	Callee	realloc
>4587	Identifier	realloc
>4588	CastTarget	int *
>4589	Identifier	count
>4590	ExpressionStatement	 
>4591	AssignmentExpr	label = ( int * ) realloc ( label , max_nr_class * sizeof ( int ) )
>4592	CastExpression	( int * ) realloc ( label , max_nr_class * sizeof ( int ) )
>4593	CallExpression	realloc ( label , max_nr_class * sizeof ( int ) )
>4594	ArgumentList	label
>4595	Argument	max_nr_class * sizeof ( int )
>4596	MultiplicativeExpression	max_nr_class * sizeof ( int )
>4597	SizeofExpr	sizeof ( int )
>4598	SizeofOperand	int
>4599	Sizeof	sizeof
>4600	Identifier	max_nr_class
>4601	Argument	label
>4602	Identifier	label
>4603	Callee	realloc
>4604	Identifier	realloc
>4605	CastTarget	int *
>4606	Identifier	label
>4607	ExpressionStatement	 
>4608	AssignmentExpr	max_nr_class *= 2
>4609	PrimaryExpression	2
>4610	Identifier	max_nr_class
>4611	Condition	 
>4612	EqualityExpression	nr_class == max_nr_class
>4613	Identifier	max_nr_class
>4614	Identifier	nr_class
>4615	Condition	 
>4616	EqualityExpression	j == nr_class
>4617	Identifier	nr_class
>4618	Identifier	j
>4619	ExpressionStatement	 
>4620	AssignmentExpr	data_label [ i ] = j
>4621	Identifier	j
>4622	ArrayIndexing	data_label [ i ]
>4623	Identifier	i
>4624	Identifier	data_label
>4625	ForStatement	for ( j = 0 ; j < nr_class ; j ++ )
>4626	CompoundStatement	 
>4627	IfStatement	if ( this_label == label [ j ] )
>4628	CompoundStatement	 
>4629	BreakStatement	 
>4630	ExpressionStatement	 
>4631	UnaryExpression	++ count [ j ]
>4632	ArrayIndexing	count [ j ]
>4633	Identifier	j
>4634	Identifier	count
>4635	IncDec	++
>4636	Condition	 
>4637	EqualityExpression	this_label == label [ j ]
>4638	ArrayIndexing	label [ j ]
>4639	Identifier	j
>4640	Identifier	label
>4641	Identifier	this_label
>4642	IncDecOp	 
>4643	IncDec	++
>4644	Identifier	j
>4645	Condition	 
>4646	RelationalExpression	j < nr_class
>4647	Identifier	nr_class
>4648	Identifier	j
>4649	ForInit	 
>4650	AssignmentExpr	j = 0
>4651	PrimaryExpression	0
>4652	Identifier	j
>4653	IdentifierDeclStatement	 
>4654	IdentifierDecl	j
>4655	Identifier	j
>4656	IdentifierDeclType	int
>4657	IdentifierDeclStatement	 
>4658	IdentifierDecl	this_label = prob -> y [ i ]
>4659	AssignmentExpr	this_label = prob -> y [ i ]
>4660	ArrayIndexing	prob -> y [ i ]
>4661	Identifier	i
>4662	PtrMemberAccess	prob -> y
>4663	Identifier	y
>4664	Identifier	prob
>4665	Identifier	this_label
>4666	Identifier	this_label
>4667	IdentifierDeclType	int
>4668	IncDecOp	 
>4669	IncDec	++
>4670	Identifier	i
>4671	Condition	 
>4672	RelationalExpression	i < l
>4673	Identifier	l
>4674	Identifier	i
>4675	ForInit	 
>4676	AssignmentExpr	i = 0
>4677	PrimaryExpression	0
>4678	Identifier	i
>4679	IdentifierDeclStatement	 
>4680	IdentifierDecl	i
>4681	Identifier	i
>4682	IdentifierDeclType	int
>4683	IdentifierDeclStatement	 
>4684	IdentifierDecl	* data_label = Malloc ( int , l )
>4685	AssignmentExpr	* data_label = Malloc ( int , l )
>4686	CallExpression	Malloc ( int , l )
>4687	ArgumentList	int
>4688	Argument	l
>4689	Identifier	l
>4690	Argument	int
>4691	Identifier	int
>4692	Callee	Malloc
>4693	Identifier	Malloc
>4694	Identifier	data_label
>4695	Identifier	data_label
>4696	IdentifierDeclType	int *
>4697	IdentifierDeclStatement	 
>4698	IdentifierDecl	* count = Malloc ( int , max_nr_class )
>4699	AssignmentExpr	* count = Malloc ( int , max_nr_class )
>4700	CallExpression	Malloc ( int , max_nr_class )
>4701	ArgumentList	int
>4702	Argument	max_nr_class
>4703	Identifier	max_nr_class
>4704	Argument	int
>4705	Identifier	int
>4706	Callee	Malloc
>4707	Identifier	Malloc
>4708	Identifier	count
>4709	Identifier	count
>4710	IdentifierDeclType	int *
>4711	IdentifierDeclStatement	 
>4712	IdentifierDecl	* label = Malloc ( int , max_nr_class )
>4713	AssignmentExpr	* label = Malloc ( int , max_nr_class )
>4714	CallExpression	Malloc ( int , max_nr_class )
>4715	ArgumentList	int
>4716	Argument	max_nr_class
>4717	Identifier	max_nr_class
>4718	Argument	int
>4719	Identifier	int
>4720	Callee	Malloc
>4721	Identifier	Malloc
>4722	Identifier	label
>4723	Identifier	label
>4724	IdentifierDeclType	int *
>4725	IdentifierDeclStatement	 
>4726	IdentifierDecl	nr_class = 0
>4727	AssignmentExpr	nr_class = 0
>4728	PrimaryExpression	0
>4729	Identifier	nr_class
>4730	Identifier	nr_class
>4731	IdentifierDeclType	int
>4732	IdentifierDeclStatement	 
>4733	IdentifierDecl	max_nr_class = 16
>4734	AssignmentExpr	max_nr_class = 16
>4735	PrimaryExpression	16
>4736	Identifier	max_nr_class
>4737	Identifier	max_nr_class
>4738	IdentifierDeclType	int
>4739	IdentifierDeclStatement	 
>4740	IdentifierDecl	l = prob -> l
>4741	AssignmentExpr	l = prob -> l
>4742	PtrMemberAccess	prob -> l
>4743	Identifier	l
>4744	Identifier	prob
>4745	Identifier	l
>4746	Identifier	l
>4747	IdentifierDeclType	int
>4792	FunctionDef	linear 
>4793	ParameterList	const problem * prob , const parameter * param , float * w , float Cp , float Cn
>4794	Parameter	 
>4795	Identifier	Cn
>4796	ParameterType	float
>4797	Parameter	 
>4798	Identifier	Cp
>4799	ParameterType	float
>4800	Parameter	 
>4801	Identifier	w
>4802	ParameterType	float *
>4803	Parameter	 
>4804	Identifier	param
>4805	ParameterType	const parameter *
>4806	Parameter	 
>4807	Identifier	prob
>4808	ParameterType	const problem *
>4809	ReturnType	void
>4810	CompoundStatement	 
>4811	IfStatement	if ( fun_obj )
>4812	CompoundStatement	 
>4813	ExpressionStatement	 
>4814	Identifier	fun_obj
>4815	Statement	 
>4816	ExpressionStatement	 
>4817	CallExpression	tron_obj . tron ( w )
>4818	ArgumentList	w
>4819	Argument	w
>4820	Identifier	w
>4821	Callee	tron_obj . tron
>4822	MemberAccess	tron_obj . tron
>4823	Identifier	tron
>4824	Identifier	tron_obj
>4825	IdentifierDeclStatement	 
>4826	IdentifierDecl	tron_obj ( fun_obj , eps )
>4827	Expression	fun_obj , eps
>4828	Identifier	eps
>4829	Identifier	fun_obj
>4830	Identifier	tron_obj
>4831	IdentifierDeclType	TRON
>4832	Condition	 
>4833	Identifier	fun_obj
>4834	SwitchStatement	switch ( param -> solver_type )
>4835	CompoundStatement	 
>4836	BreakStatement	 
>4837	Label	 
>4838	Identifier	default
>4839	BreakStatement	 
>4840	ExpressionStatement	 
>4841	AssignmentExpr	fun_obj = new l2loss_svm_fun ( prob , Cp , Cn )
>4842	Expression	prob , Cp , Cn
>4843	Expression	Cp , Cn
>4844	Identifier	Cn
>4845	Identifier	Cp
>4846	Identifier	prob
>4847	Identifier	fun_obj
>4848	Label	 
>4849	Identifier	L2LOSS_SVM
>4850	BreakStatement	 
>4851	ExpressionStatement	 
>4852	AssignmentExpr	fun_obj = new l2_lr_fun ( prob , Cp , Cn )
>4853	Expression	prob , Cp , Cn
>4854	Expression	Cp , Cn
>4855	Identifier	Cn
>4856	Identifier	Cp
>4857	Identifier	prob
>4858	Identifier	fun_obj
>4859	Label	 
>4860	Identifier	L2_LR
>4861	Condition	 
>4862	PtrMemberAccess	param -> solver_type
>4863	Identifier	solver_type
>4864	Identifier	param
>4865	IdentifierDeclStatement	 
>4866	IdentifierDecl	* fun_obj = NULL
>4867	AssignmentExpr	* fun_obj = NULL
>4868	Identifier	NULL
>4869	Identifier	NULL
>4870	Identifier	fun_obj
>4871	IdentifierDeclType	function *
>4872	IdentifierDeclStatement	 
>4873	IdentifierDecl	eps = param -> eps
>4874	AssignmentExpr	eps = param -> eps
>4875	PtrMemberAccess	param -> eps
>4876	Identifier	eps
>4877	Identifier	param
>4878	Identifier	eps
>4879	Identifier	eps
>4880	IdentifierDeclType	float
>4896	FunctionDef	linear 
>4897	ParameterList	int l , int n , float * y , float * x , float bias
>4898	Parameter	 
>4899	Identifier	bias
>4900	ParameterType	float
>4901	Parameter	 
>4902	Identifier	x
>4903	ParameterType	float *
>4904	Parameter	 
>4905	Identifier	y
>4906	ParameterType	float *
>4907	Parameter	 
>4908	Identifier	n
>4909	ParameterType	int
>4910	Parameter	 
>4911	Identifier	l
>4912	ParameterType	int
>4913	ReturnType	void
>4914	CompoundStatement	 
>4915	IfStatement	if ( bias >= 0 )
>4916	ElseStatement	else
>4917	ExpressionStatement	 
>4918	AssignmentExpr	the_problem -> n = n
>4919	Identifier	n
>4920	PtrMemberAccess	the_problem -> n
>4921	Identifier	n
>4922	Identifier	the_problem
>4923	CompoundStatement	 
>4924	ExpressionStatement	 
>4925	AssignmentExpr	x_space [ k - 2 ] . index = the_problem -> n
>4926	PtrMemberAccess	the_problem -> n
>4927	Identifier	n
>4928	Identifier	the_problem
>4929	MemberAccess	x_space [ k - 2 ] . index
>4930	Identifier	index
>4931	ArrayIndexing	x_space [ k - 2 ]
>4932	AdditiveExpression	k - 2
>4933	PrimaryExpression	2
>4934	Identifier	k
>4935	Identifier	x_space
>4936	ForStatement	for ( int i = 1 ; i != l ; ++ i )
>4937	ExpressionStatement	 
>4938	AssignmentExpr	( the_problem -> x [ i ] - 2 ) -> index = the_problem -> n
>4939	PtrMemberAccess	the_problem -> n
>4940	Identifier	n
>4941	Identifier	the_problem
>4942	PtrMemberAccess	( the_problem -> x [ i ] - 2 ) -> index
>4943	Identifier	index
>4944	AdditiveExpression	the_problem -> x [ i ] - 2
>4945	PrimaryExpression	2
>4946	ArrayIndexing	the_problem -> x [ i ]
>4947	Identifier	i
>4948	PtrMemberAccess	the_problem -> x
>4949	Identifier	x
>4950	Identifier	the_problem
>4951	UnaryExpression	 
>4952	Identifier	i
>4953	IncDec	++
>4954	Condition	 
>4955	EqualityExpression	i != l
>4956	Identifier	l
>4957	Identifier	i
>4958	ForInit	 
>4959	IdentifierDeclStatement	int i = 1 ;
>4960	IdentifierDecl	i = 1
>4961	AssignmentExpr	i = 1
>4962	PrimaryExpression	1
>4963	Identifier	i
>4964	Identifier	i
>4965	IdentifierDeclType	int
>4966	ExpressionStatement	 
>4967	AssignmentExpr	the_problem -> n = n + 1
>4968	AdditiveExpression	n + 1
>4969	PrimaryExpression	1
>4970	Identifier	n
>4971	PtrMemberAccess	the_problem -> n
>4972	Identifier	n
>4973	Identifier	the_problem
>4974	Condition	 
>4975	RelationalExpression	bias >= 0
>4976	PrimaryExpression	0
>4977	Identifier	bias
>4978	ForStatement	for ( int i = 0 ; i != l ; ++ i )
>4979	CompoundStatement	 
>4980	ExpressionStatement	 
>4981	AssignmentExpr	x_space [ k ++ ] . index = - 1
>4982	UnaryOp	- 1
>4983	PrimaryExpression	1
>4984	UnaryOperator	-
>4985	MemberAccess	x_space [ k ++ ] . index
>4986	Identifier	index
>4987	ArrayIndexing	x_space [ k ++ ]
>4988	IncDecOp	k ++
>4989	IncDec	++
>4990	Identifier	k
>4991	Identifier	x_space
>4992	IfStatement	if ( bias >= 0 )
>4993	ExpressionStatement	 
>4994	AssignmentExpr	x_space [ k ++ ] . value = bias
>4995	Identifier	bias
>4996	MemberAccess	x_space [ k ++ ] . value
>4997	Identifier	value
>4998	ArrayIndexing	x_space [ k ++ ]
>4999	IncDecOp	k ++
>5000	IncDec	++
>5001	Identifier	k
>5002	Identifier	x_space
>5003	Condition	 
>5004	RelationalExpression	bias >= 0
>5005	PrimaryExpression	0
>5006	Identifier	bias
>5007	ForStatement	for ( int j = 0 ; j != n - 1 ; ++ j )
>5008	CompoundStatement	 
>5009	ExpressionStatement	 
>5010	UnaryExpression	++ k
>5011	Identifier	k
>5012	IncDec	++
>5013	ExpressionStatement	 
>5014	AssignmentExpr	x_space [ k ] . value = x [ k ]
>5015	ArrayIndexing	x [ k ]
>5016	Identifier	k
>5017	Identifier	x
>5018	MemberAccess	x_space [ k ] . value
>5019	Identifier	value
>5020	ArrayIndexing	x_space [ k ]
>5021	Identifier	k
>5022	Identifier	x_space
>5023	ExpressionStatement	 
>5024	AssignmentExpr	x_space [ k ] . index = j + 1
>5025	AdditiveExpression	j + 1
>5026	PrimaryExpression	1
>5027	Identifier	j
>5028	MemberAccess	x_space [ k ] . index
>5029	Identifier	index
>5030	ArrayIndexing	x_space [ k ]
>5031	Identifier	k
>5032	Identifier	x_space
>5033	UnaryExpression	 
>5034	Identifier	j
>5035	IncDec	++
>5036	Condition	 
>5037	EqualityExpression	j != n - 1
>5038	AdditiveExpression	n - 1
>5039	PrimaryExpression	1
>5040	Identifier	n
>5041	Identifier	j
>5042	ForInit	 
>5043	IdentifierDeclStatement	int j = 0 ;
>5044	IdentifierDecl	j = 0
>5045	AssignmentExpr	j = 0
>5046	PrimaryExpression	0
>5047	Identifier	j
>5048	Identifier	j
>5049	IdentifierDeclType	int
>5050	ExpressionStatement	 
>5051	AssignmentExpr	the_problem -> y [ i ] = ( int ) y [ i ]
>5052	CastExpression	( int ) y [ i ]
>5053	ArrayIndexing	y [ i ]
>5054	Identifier	i
>5055	Identifier	y
>5056	CastTarget	int
>5057	ArrayIndexing	the_problem -> y [ i ]
>5058	Identifier	i
>5059	PtrMemberAccess	the_problem -> y
>5060	Identifier	y
>5061	Identifier	the_problem
>5062	ExpressionStatement	 
>5063	AssignmentExpr	the_problem -> x [ i ] = & x_space [ k ]
>5064	UnaryOp	& x_space [ k ]
>5065	ArrayIndexing	x_space [ k ]
>5066	Identifier	k
>5067	Identifier	x_space
>5068	UnaryOperator	&
>5069	ArrayIndexing	the_problem -> x [ i ]
>5070	Identifier	i
>5071	PtrMemberAccess	the_problem -> x
>5072	Identifier	x
>5073	Identifier	the_problem
>5074	UnaryExpression	 
>5075	Identifier	i
>5076	IncDec	++
>5077	Condition	 
>5078	EqualityExpression	i != l
>5079	Identifier	l
>5080	Identifier	i
>5081	ForInit	 
>5082	IdentifierDeclStatement	int i = 0 ;
>5083	IdentifierDecl	i = 0
>5084	AssignmentExpr	i = 0
>5085	PrimaryExpression	0
>5086	Identifier	i
>5087	Identifier	i
>5088	IdentifierDeclType	int
>5089	IdentifierDeclStatement	 
>5090	IdentifierDecl	k = 0
>5091	AssignmentExpr	k = 0
>5092	PrimaryExpression	0
>5093	Identifier	k
>5094	Identifier	k
>5095	IdentifierDeclType	int
>5096	ExpressionStatement	 
>5097	AssignmentExpr	x_space = new feature_node [ l * ( n + 1 ) ]
>5098	MultiplicativeExpression	l * ( n + 1 )
>5099	AdditiveExpression	n + 1
>5100	PrimaryExpression	1
>5101	Identifier	n
>5102	Identifier	l
>5103	Identifier	x_space
>5104	ExpressionStatement	 
>5105	AssignmentExpr	the_problem = new problem ( l , n , bias )
>5106	Expression	l , n , bias
>5107	Expression	n , bias
>5108	Identifier	bias
>5109	Identifier	n
>5110	Identifier	l
>5111	Identifier	the_problem
>5148	FunctionDef	linear 
>5149	ParameterList	const problem * prob , const parameter * param
>5150	Parameter	 
>5151	Identifier	param
>5152	ParameterType	const parameter *
>5153	Parameter	 
>5154	Identifier	prob
>5155	ParameterType	const problem *
>5156	ReturnType	model *
>5157	CompoundStatement	 
>5158	ReturnStatement	 
>5159	Identifier	model_
>5160	ExpressionStatement	 
>5161	CallExpression	free ( weighted_C )
>5162	ArgumentList	weighted_C
>5163	Argument	weighted_C
>5164	Identifier	weighted_C
>5165	Callee	free
>5166	Identifier	free
>5167	ExpressionStatement	 
>5168	CallExpression	free ( perm )
>5169	ArgumentList	perm
>5170	Argument	perm
>5171	Identifier	perm
>5172	Callee	free
>5173	Identifier	free
>5174	ExpressionStatement	 
>5175	CallExpression	free ( count )
>5176	ArgumentList	count
>5177	Argument	count
>5178	Identifier	count
>5179	Callee	free
>5180	Identifier	free
>5181	ExpressionStatement	 
>5182	CallExpression	free ( start )
>5183	ArgumentList	start
>5184	Argument	start
>5185	Identifier	start
>5186	Callee	free
>5187	Identifier	free
>5188	ExpressionStatement	 
>5189	CallExpression	free ( label )
>5190	ArgumentList	label
>5191	Argument	label
>5192	Identifier	label
>5193	Callee	free
>5194	Identifier	free
>5195	ExpressionStatement	 
>5196	CallExpression	free ( x )
>5197	ArgumentList	x
>5198	Argument	x
>5199	Identifier	x
>5200	Callee	free
>5201	Identifier	free
>5202	IfStatement	if ( nr_class == 2 )
>5203	ElseStatement	else
>5204	CompoundStatement	 
>5205	ForStatement	for ( i = 0 ; i < nr_class ; i ++ )
>5206	CompoundStatement	 
>5207	ExpressionStatement	 
>5208	CallExpression	train_one ( & sub_prob , param , & model_ -> w [ i * n ] , weighted_C [ i ] , param -> C )
>5209	ArgumentList	& sub_prob
>5210	Argument	param -> C
>5211	PtrMemberAccess	param -> C
>5212	Identifier	C
>5213	Identifier	param
>5214	Argument	weighted_C [ i ]
>5215	ArrayIndexing	weighted_C [ i ]
>5216	Identifier	i
>5217	Identifier	weighted_C
>5218	Argument	& model_ -> w [ i * n ]
>5219	UnaryOp	& model_ -> w [ i * n ]
>5220	ArrayIndexing	model_ -> w [ i * n ]
>5221	MultiplicativeExpression	i * n
>5222	Identifier	n
>5223	Identifier	i
>5224	PtrMemberAccess	model_ -> w
>5225	Identifier	w
>5226	Identifier	model_
>5227	UnaryOperator	&
>5228	Argument	param
>5229	Identifier	param
>5230	Argument	& sub_prob
>5231	UnaryOp	& sub_prob
>5232	Identifier	sub_prob
>5233	UnaryOperator	&
>5234	Callee	train_one
>5235	Identifier	train_one
>5236	ForStatement	for ( ; k < sub_prob . l ; k ++ )
>5237	ExpressionStatement	 
>5238	AssignmentExpr	sub_prob . y [ k ] = - 1
>5239	UnaryOp	- 1
>5240	PrimaryExpression	1
>5241	UnaryOperator	-
>5242	ArrayIndexing	sub_prob . y [ k ]
>5243	Identifier	k
>5244	MemberAccess	sub_prob . y
>5245	Identifier	y
>5246	Identifier	sub_prob
>5247	IncDecOp	 
>5248	IncDec	++
>5249	Identifier	k
>5250	Condition	 
>5251	RelationalExpression	k < sub_prob . l
>5252	MemberAccess	sub_prob . l
>5253	Identifier	l
>5254	Identifier	sub_prob
>5255	Identifier	k
>5256	ForStatement	for ( ; k < ei ; k ++ )
>5257	ExpressionStatement	 
>5258	AssignmentExpr	sub_prob . y [ k ] = + 1
>5259	UnaryOp	+ 1
>5260	PrimaryExpression	1
>5261	UnaryOperator	+
>5262	ArrayIndexing	sub_prob . y [ k ]
>5263	Identifier	k
>5264	MemberAccess	sub_prob . y
>5265	Identifier	y
>5266	Identifier	sub_prob
>5267	IncDecOp	 
>5268	IncDec	++
>5269	Identifier	k
>5270	Condition	 
>5271	RelationalExpression	k < ei
>5272	Identifier	ei
>5273	Identifier	k
>5274	ForStatement	for ( ; k < si ; k ++ )
>5275	ExpressionStatement	 
>5276	AssignmentExpr	sub_prob . y [ k ] = - 1
>5277	UnaryOp	- 1
>5278	PrimaryExpression	1
>5279	UnaryOperator	-
>5280	ArrayIndexing	sub_prob . y [ k ]
>5281	Identifier	k
>5282	MemberAccess	sub_prob . y
>5283	Identifier	y
>5284	Identifier	sub_prob
>5285	IncDecOp	 
>5286	IncDec	++
>5287	Identifier	k
>5288	Condition	 
>5289	RelationalExpression	k < si
>5290	Identifier	si
>5291	Identifier	k
>5292	ExpressionStatement	 
>5293	AssignmentExpr	k = 0
>5294	PrimaryExpression	0
>5295	Identifier	k
>5296	IdentifierDeclStatement	 
>5297	IdentifierDecl	ei = si + count [ i ]
>5298	AssignmentExpr	ei = si + count [ i ]
>5299	AdditiveExpression	si + count [ i ]
>5300	ArrayIndexing	count [ i ]
>5301	Identifier	i
>5302	Identifier	count
>5303	Identifier	si
>5304	Identifier	ei
>5305	Identifier	ei
>5306	IdentifierDeclType	int
>5307	IdentifierDeclStatement	 
>5308	IdentifierDecl	si = start [ i ]
>5309	AssignmentExpr	si = start [ i ]
>5310	ArrayIndexing	start [ i ]
>5311	Identifier	i
>5312	Identifier	start
>5313	Identifier	si
>5314	Identifier	si
>5315	IdentifierDeclType	int
>5316	IncDecOp	 
>5317	IncDec	++
>5318	Identifier	i
>5319	Condition	 
>5320	RelationalExpression	i < nr_class
>5321	Identifier	nr_class
>5322	Identifier	i
>5323	ForInit	 
>5324	AssignmentExpr	i = 0
>5325	PrimaryExpression	0
>5326	Identifier	i
>5327	ExpressionStatement	 
>5328	AssignmentExpr	model_ -> w = Malloc ( float , n * nr_class )
>5329	CallExpression	Malloc ( float , n * nr_class )
>5330	ArgumentList	float
>5331	Argument	n * nr_class
>5332	MultiplicativeExpression	n * nr_class
>5333	Identifier	nr_class
>5334	Identifier	n
>5335	Argument	float
>5336	Identifier	float
>5337	Callee	Malloc
>5338	Identifier	Malloc
>5339	PtrMemberAccess	model_ -> w
>5340	Identifier	w
>5341	Identifier	model_
>5342	CompoundStatement	 
>5343	ExpressionStatement	 
>5344	CallExpression	train_one ( & sub_prob , param , & model_ -> w [ 0 ] , weighted_C [ 0 ] , weighted_C [ 1 ] )
>5345	ArgumentList	& sub_prob
>5346	Argument	weighted_C [ 1 ]
>5347	ArrayIndexing	weighted_C [ 1 ]
>5348	PrimaryExpression	1
>5349	Identifier	weighted_C
>5350	Argument	weighted_C [ 0 ]
>5351	ArrayIndexing	weighted_C [ 0 ]
>5352	PrimaryExpression	0
>5353	Identifier	weighted_C
>5354	Argument	& model_ -> w [ 0 ]
>5355	UnaryOp	& model_ -> w [ 0 ]
>5356	ArrayIndexing	model_ -> w [ 0 ]
>5357	PrimaryExpression	0
>5358	PtrMemberAccess	model_ -> w
>5359	Identifier	w
>5360	Identifier	model_
>5361	UnaryOperator	&
>5362	Argument	param
>5363	Identifier	param
>5364	Argument	& sub_prob
>5365	UnaryOp	& sub_prob
>5366	Identifier	sub_prob
>5367	UnaryOperator	&
>5368	Callee	train_one
>5369	Identifier	train_one
>5370	ForStatement	for ( ; k < sub_prob . l ; k ++ )
>5371	ExpressionStatement	 
>5372	AssignmentExpr	sub_prob . y [ k ] = - 1
>5373	UnaryOp	- 1
>5374	PrimaryExpression	1
>5375	UnaryOperator	-
>5376	ArrayIndexing	sub_prob . y [ k ]
>5377	Identifier	k
>5378	MemberAccess	sub_prob . y
>5379	Identifier	y
>5380	Identifier	sub_prob
>5381	IncDecOp	 
>5382	IncDec	++
>5383	Identifier	k
>5384	Condition	 
>5385	RelationalExpression	k < sub_prob . l
>5386	MemberAccess	sub_prob . l
>5387	Identifier	l
>5388	Identifier	sub_prob
>5389	Identifier	k
>5390	ForStatement	for ( ; k < e0 ; k ++ )
>5391	ExpressionStatement	 
>5392	AssignmentExpr	sub_prob . y [ k ] = + 1
>5393	UnaryOp	+ 1
>5394	PrimaryExpression	1
>5395	UnaryOperator	+
>5396	ArrayIndexing	sub_prob . y [ k ]
>5397	Identifier	k
>5398	MemberAccess	sub_prob . y
>5399	Identifier	y
>5400	Identifier	sub_prob
>5401	IncDecOp	 
>5402	IncDec	++
>5403	Identifier	k
>5404	Condition	 
>5405	RelationalExpression	k < e0
>5406	Identifier	e0
>5407	Identifier	k
>5408	ExpressionStatement	 
>5409	AssignmentExpr	k = 0
>5410	PrimaryExpression	0
>5411	Identifier	k
>5412	IdentifierDeclStatement	 
>5413	IdentifierDecl	e0 = start [ 0 ] + count [ 0 ]
>5414	AssignmentExpr	e0 = start [ 0 ] + count [ 0 ]
>5415	AdditiveExpression	start [ 0 ] + count [ 0 ]
>5416	ArrayIndexing	count [ 0 ]
>5417	PrimaryExpression	0
>5418	Identifier	count
>5419	ArrayIndexing	start [ 0 ]
>5420	PrimaryExpression	0
>5421	Identifier	start
>5422	Identifier	e0
>5423	Identifier	e0
>5424	IdentifierDeclType	int
>5425	ExpressionStatement	 
>5426	AssignmentExpr	model_ -> w = Malloc ( float , n )
>5427	CallExpression	Malloc ( float , n )
>5428	ArgumentList	float
>5429	Argument	n
>5430	Identifier	n
>5431	Argument	float
>5432	Identifier	float
>5433	Callee	Malloc
>5434	Identifier	Malloc
>5435	PtrMemberAccess	model_ -> w
>5436	Identifier	w
>5437	Identifier	model_
>5438	Condition	 
>5439	EqualityExpression	nr_class == 2
>5440	PrimaryExpression	2
>5441	Identifier	nr_class
>5442	ForStatement	for ( int k = 0 ; k < sub_prob . l ; k ++ )
>5443	ExpressionStatement	 
>5444	AssignmentExpr	sub_prob . x [ k ] = x [ k ]
>5445	ArrayIndexing	x [ k ]
>5446	Identifier	k
>5447	Identifier	x
>5448	ArrayIndexing	sub_prob . x [ k ]
>5449	Identifier	k
>5450	MemberAccess	sub_prob . x
>5451	Identifier	x
>5452	Identifier	sub_prob
>5453	IncDecOp	 
>5454	IncDec	++
>5455	Identifier	k
>5456	Condition	 
>5457	RelationalExpression	k < sub_prob . l
>5458	MemberAccess	sub_prob . l
>5459	Identifier	l
>5460	Identifier	sub_prob
>5461	Identifier	k
>5462	ForInit	 
>5463	IdentifierDeclStatement	int k = 0 ;
>5464	IdentifierDecl	k = 0
>5465	AssignmentExpr	k = 0
>5466	PrimaryExpression	0
>5467	Identifier	k
>5468	Identifier	k
>5469	IdentifierDeclType	int
>5470	IdentifierDeclStatement	 
>5471	IdentifierDecl	sub_prob ( l , n , 0.0f )
>5472	Expression	l , n , 0.0f
>5473	Expression	n , 0.0f
>5474	PrimaryExpression	0.0f
>5475	Identifier	n
>5476	Identifier	l
>5477	Identifier	sub_prob
>5478	IdentifierDeclType	problem
>5479	IdentifierDeclStatement	 
>5480	IdentifierDecl	k
>5481	Identifier	k
>5482	IdentifierDeclType	int
>5483	ForStatement	for ( i = 0 ; i < l ; i ++ )
>5484	ExpressionStatement	 
>5485	AssignmentExpr	x [ i ] = prob -> x [ perm [ i ] ]
>5486	ArrayIndexing	prob -> x [ perm [ i ] ]
>5487	ArrayIndexing	perm [ i ]
>5488	Identifier	i
>5489	Identifier	perm
>5490	PtrMemberAccess	prob -> x
>5491	Identifier	x
>5492	Identifier	prob
>5493	ArrayIndexing	x [ i ]
>5494	Identifier	i
>5495	Identifier	x
>5496	IncDecOp	 
>5497	IncDec	++
>5498	Identifier	i
>5499	Condition	 
>5500	RelationalExpression	i < l
>5501	Identifier	l
>5502	Identifier	i
>5503	ForInit	 
>5504	AssignmentExpr	i = 0
>5505	PrimaryExpression	0
>5506	Identifier	i
>5507	ExpressionStatement	 
>5508	Statement	 
>5509	Statement	 
>5510	Statement	 
>5511	Statement	 
>5512	Statement	 
>5513	Statement	 
>5514	Statement	 
>5515	Statement	 
>5516	Statement	 
>5517	Statement	 
>5518	Statement	 
>5519	Statement	 
>5520	ForStatement	for ( i = 0 ; i < param -> nr_weight ; i ++ )
>5521	CompoundStatement	 
>5522	IfStatement	if ( j == nr_class )
>5523	ElseStatement	else
>5524	ExpressionStatement	 
>5525	AssignmentExpr	weighted_C [ j ] *= param -> weight [ i ]
>5526	ArrayIndexing	param -> weight [ i ]
>5527	Identifier	i
>5528	PtrMemberAccess	param -> weight
>5529	Identifier	weight
>5530	Identifier	param
>5531	ArrayIndexing	weighted_C [ j ]
>5532	Identifier	j
>5533	Identifier	weighted_C
>5534	ExpressionStatement	 
>5535	CallExpression	fprintf ( stderr , \"warning
>5536	ArgumentList	stderr
>5537	Argument	param -> weight_label [ i ]
>5538	ArrayIndexing	param -> weight_label [ i ]
>5539	Identifier	i
>5540	PtrMemberAccess	param -> weight_label
>5541	Identifier	weight_label
>5542	Identifier	param
>5543	Argument	\"warning
>5544	PrimaryExpression	\"warning
>5545	Argument	stderr
>5546	Identifier	stderr
>5547	Callee	fprintf
>5548	Identifier	fprintf
>5549	Condition	 
>5550	EqualityExpression	j == nr_class
>5551	Identifier	nr_class
>5552	Identifier	j
>5553	ForStatement	for ( j = 0 ; j < nr_class ; j ++ )
>5554	IfStatement	if ( param -> weight_label [ i ] == label [ j ] )
>5555	BreakStatement	 
>5556	Condition	 
>5557	EqualityExpression	param -> weight_label [ i ] == label [ j ]
>5558	ArrayIndexing	label [ j ]
>5559	Identifier	j
>5560	Identifier	label
>5561	ArrayIndexing	param -> weight_label [ i ]
>5562	Identifier	i
>5563	PtrMemberAccess	param -> weight_label
>5564	Identifier	weight_label
>5565	Identifier	param
>5566	IncDecOp	 
>5567	IncDec	++
>5568	Identifier	j
>5569	Condition	 
>5570	RelationalExpression	j < nr_class
>5571	Identifier	nr_class
>5572	Identifier	j
>5573	ForInit	 
>5574	AssignmentExpr	j = 0
>5575	PrimaryExpression	0
>5576	Identifier	j
>5577	IdentifierDeclStatement	 
>5578	IdentifierDecl	j
>5579	Identifier	j
>5580	IdentifierDeclType	int
>5581	IncDecOp	 
>5582	IncDec	++
>5583	Identifier	i
>5584	Condition	 
>5585	RelationalExpression	i < param -> nr_weight
>5586	PtrMemberAccess	param -> nr_weight
>5587	Identifier	nr_weight
>5588	Identifier	param
>5589	Identifier	i
>5590	ForInit	 
>5591	AssignmentExpr	i = 0
>5592	PrimaryExpression	0
>5593	Identifier	i
>5594	ForStatement	for ( i = 0 ; i < nr_class ; i ++ )
>5595	ExpressionStatement	 
>5596	AssignmentExpr	weighted_C [ i ] = param -> C
>5597	PtrMemberAccess	param -> C
>5598	Identifier	C
>5599	Identifier	param
>5600	ArrayIndexing	weighted_C [ i ]
>5601	Identifier	i
>5602	Identifier	weighted_C
>5603	IncDecOp	 
>5604	IncDec	++
>5605	Identifier	i
>5606	Condition	 
>5607	RelationalExpression	i < nr_class
>5608	Identifier	nr_class
>5609	Identifier	i
>5610	ForInit	 
>5611	AssignmentExpr	i = 0
>5612	PrimaryExpression	0
>5613	Identifier	i
>5614	IdentifierDeclStatement	 
>5615	IdentifierDecl	* weighted_C = Malloc ( float , nr_class )
>5616	AssignmentExpr	* weighted_C = Malloc ( float , nr_class )
>5617	CallExpression	Malloc ( float , nr_class )
>5618	ArgumentList	float
>5619	Argument	nr_class
>5620	Identifier	nr_class
>5621	Argument	float
>5622	Identifier	float
>5623	Callee	Malloc
>5624	Identifier	Malloc
>5625	Identifier	weighted_C
>5626	Identifier	weighted_C
>5627	IdentifierDeclType	float *
>5628	ForStatement	for ( i = 0 ; i < nr_class ; i ++ )
>5629	ExpressionStatement	 
>5630	AssignmentExpr	model_ -> label [ i ] = label [ i ]
>5631	ArrayIndexing	label [ i ]
>5632	Identifier	i
>5633	Identifier	label
>5634	ArrayIndexing	model_ -> label [ i ]
>5635	Identifier	i
>5636	PtrMemberAccess	model_ -> label
>5637	Identifier	label
>5638	Identifier	model_
>5639	IncDecOp	 
>5640	IncDec	++
>5641	Identifier	i
>5642	Condition	 
>5643	RelationalExpression	i < nr_class
>5644	Identifier	nr_class
>5645	Identifier	i
>5646	ForInit	 
>5647	AssignmentExpr	i = 0
>5648	PrimaryExpression	0
>5649	Identifier	i
>5650	ExpressionStatement	 
>5651	AssignmentExpr	model_ -> label = Malloc ( int , nr_class )
>5652	CallExpression	Malloc ( int , nr_class )
>5653	ArgumentList	int
>5654	Argument	nr_class
>5655	Identifier	nr_class
>5656	Argument	int
>5657	Identifier	int
>5658	Callee	Malloc
>5659	Identifier	Malloc
>5660	PtrMemberAccess	model_ -> label
>5661	Identifier	label
>5662	Identifier	model_
>5663	ExpressionStatement	 
>5664	AssignmentExpr	model_ -> nr_class = nr_class
>5665	Identifier	nr_class
>5666	PtrMemberAccess	model_ -> nr_class
>5667	Identifier	nr_class
>5668	Identifier	model_
>5669	ExpressionStatement	 
>5670	CallExpression	group_classes ( prob , & nr_class , & label , & start , & count , perm )
>5671	ArgumentList	prob
>5672	Argument	perm
>5673	Identifier	perm
>5674	Argument	& count
>5675	UnaryOp	& count
>5676	Identifier	count
>5677	UnaryOperator	&
>5678	Argument	& start
>5679	UnaryOp	& start
>5680	Identifier	start
>5681	UnaryOperator	&
>5682	Argument	& label
>5683	UnaryOp	& label
>5684	Identifier	label
>5685	UnaryOperator	&
>5686	Argument	& nr_class
>5687	UnaryOp	& nr_class
>5688	Identifier	nr_class
>5689	UnaryOperator	&
>5690	Argument	prob
>5691	Identifier	prob
>5692	Callee	group_classes
>5693	Identifier	group_classes
>5694	IdentifierDeclStatement	 
>5695	IdentifierDecl	* perm = Malloc ( int , l )
>5696	AssignmentExpr	* perm = Malloc ( int , l )
>5697	CallExpression	Malloc ( int , l )
>5698	ArgumentList	int
>5699	Argument	l
>5700	Identifier	l
>5701	Argument	int
>5702	Identifier	int
>5703	Callee	Malloc
>5704	Identifier	Malloc
>5705	Identifier	perm
>5706	Identifier	perm
>5707	IdentifierDeclType	int *
>5708	IdentifierDeclStatement	 
>5709	IdentifierDecl	* count = NULL
>5710	AssignmentExpr	* count = NULL
>5711	Identifier	NULL
>5712	Identifier	NULL
>5713	Identifier	count
>5714	IdentifierDeclType	int *
>5715	IdentifierDeclStatement	 
>5716	IdentifierDecl	* start = NULL
>5717	AssignmentExpr	* start = NULL
>5718	Identifier	NULL
>5719	Identifier	NULL
>5720	Identifier	start
>5721	IdentifierDeclType	int *
>5722	IdentifierDeclStatement	 
>5723	IdentifierDecl	* label = NULL
>5724	AssignmentExpr	* label = NULL
>5725	Identifier	NULL
>5726	Identifier	NULL
>5727	Identifier	label
>5728	IdentifierDeclType	int *
>5729	IdentifierDeclStatement	 
>5730	IdentifierDecl	nr_class
>5731	Identifier	nr_class
>5732	IdentifierDeclType	int
>5733	ExpressionStatement	 
>5734	AssignmentExpr	model_ -> bias = prob -> bias
>5735	PtrMemberAccess	prob -> bias
>5736	Identifier	bias
>5737	Identifier	prob
>5738	PtrMemberAccess	model_ -> bias
>5739	Identifier	bias
>5740	Identifier	model_
>5741	ExpressionStatement	 
>5742	AssignmentExpr	model_ -> param = * param
>5743	UnaryOp	* param
>5744	Identifier	param
>5745	UnaryOperator	*
>5746	PtrMemberAccess	model_ -> param
>5747	Identifier	param
>5748	Identifier	model_
>5749	IfStatement	if ( prob -> bias >= 0 )
>5750	ElseStatement	else
>5751	ExpressionStatement	 
>5752	AssignmentExpr	model_ -> nr_feature = n
>5753	Identifier	n
>5754	PtrMemberAccess	model_ -> nr_feature
>5755	Identifier	nr_feature
>5756	Identifier	model_
>5757	ExpressionStatement	 
>5758	AssignmentExpr	model_ -> nr_feature = n - 1
>5759	AdditiveExpression	n - 1
>5760	PrimaryExpression	1
>5761	Identifier	n
>5762	PtrMemberAccess	model_ -> nr_feature
>5763	Identifier	nr_feature
>5764	Identifier	model_
>5765	Condition	 
>5766	RelationalExpression	prob -> bias >= 0
>5767	PrimaryExpression	0
>5768	PtrMemberAccess	prob -> bias
>5769	Identifier	bias
>5770	Identifier	prob
>5771	IdentifierDeclStatement	 
>5772	IdentifierDecl	* model_ = Malloc ( model , 1 )
>5773	AssignmentExpr	* model_ = Malloc ( model , 1 )
>5774	CallExpression	Malloc ( model , 1 )
>5775	ArgumentList	model
>5776	Argument	1
>5777	PrimaryExpression	1
>5778	Argument	model
>5779	Identifier	model
>5780	Callee	Malloc
>5781	Identifier	Malloc
>5782	Identifier	model_
>5783	Identifier	model_
>5784	IdentifierDeclType	model *
>5785	IdentifierDeclStatement	 
>5786	IdentifierDecl	n = prob -> n
>5787	AssignmentExpr	n = prob -> n
>5788	PtrMemberAccess	prob -> n
>5789	Identifier	n
>5790	Identifier	prob
>5791	Identifier	n
>5792	Identifier	n
>5793	IdentifierDeclType	int
>5794	IdentifierDeclStatement	 
>5795	IdentifierDecl	l = prob -> l
>5796	AssignmentExpr	l = prob -> l
>5797	PtrMemberAccess	prob -> l
>5798	Identifier	l
>5799	Identifier	prob
>5800	Identifier	l
>5801	Identifier	l
>5802	IdentifierDeclType	int
>5803	IdentifierDeclStatement	 
>5804	IdentifierDecl	i
>5805	Identifier	i
>5806	IdentifierDeclType	int
>5885	FunctionDef	linear 
>5886	ParameterList	const char * model_file_name , const struct model * model_
>5887	Parameter	 
>5888	Identifier	model_
>5889	ParameterType	const struct model *
>5890	Parameter	 
>5891	Identifier	model_file_name
>5892	ParameterType	const char *
>5893	ReturnType	int
>5894	CompoundStatement	 
>5895	IfStatement	if ( ferror ( fp ) != 0 || fclose ( fp ) != 0 )
>5896	ElseStatement	else
>5897	ReturnStatement	 
>5898	PrimaryExpression	0
>5899	ReturnStatement	 
>5900	UnaryOp	- 1
>5901	PrimaryExpression	1
>5902	UnaryOperator	-
>5903	Condition	 
>5904	OrExpression	ferror ( fp ) != 0 || fclose ( fp ) != 0
>5905	EqualityExpression	fclose ( fp ) != 0
>5906	PrimaryExpression	0
>5907	CallExpression	fclose ( fp )
>5908	ArgumentList	fp
>5909	Argument	fp
>5910	Identifier	fp
>5911	Callee	fclose
>5912	Identifier	fclose
>5913	EqualityExpression	ferror ( fp ) != 0
>5914	PrimaryExpression	0
>5915	CallExpression	ferror ( fp )
>5916	ArgumentList	fp
>5917	Argument	fp
>5918	Identifier	fp
>5919	Callee	ferror
>5920	Identifier	ferror
>5921	ForStatement	for ( i = 0 ; i < n ; i ++ )
>5922	CompoundStatement	 
>5923	ExpressionStatement	 
>5924	CallExpression	fprintf ( fp , \"\n\" )
>5925	ArgumentList	fp
>5926	Argument	\"\n\"
>5927	PrimaryExpression	\"\n\"
>5928	Argument	fp
>5929	Identifier	fp
>5930	Callee	fprintf
>5931	Identifier	fprintf
>5932	ForStatement	for ( j = 0 ; j < nr_classifier ; j ++ )
>5933	ExpressionStatement	 
>5934	CallExpression	fprintf ( fp , \"%.16g \" , model_ -> w [ j * n + i ] )
>5935	ArgumentList	fp
>5936	Argument	model_ -> w [ j * n + i ]
>5937	ArrayIndexing	model_ -> w [ j * n + i ]
>5938	AdditiveExpression	j * n + i
>5939	Identifier	i
>5940	MultiplicativeExpression	j * n
>5941	Identifier	n
>5942	Identifier	j
>5943	PtrMemberAccess	model_ -> w
>5944	Identifier	w
>5945	Identifier	model_
>5946	Argument	\"%.16g \"
>5947	PrimaryExpression	\"%.16g \"
>5948	Argument	fp
>5949	Identifier	fp
>5950	Callee	fprintf
>5951	Identifier	fprintf
>5952	IncDecOp	 
>5953	IncDec	++
>5954	Identifier	j
>5955	Condition	 
>5956	RelationalExpression	j < nr_classifier
>5957	Identifier	nr_classifier
>5958	Identifier	j
>5959	ForInit	 
>5960	AssignmentExpr	j = 0
>5961	PrimaryExpression	0
>5962	Identifier	j
>5963	IdentifierDeclStatement	 
>5964	IdentifierDecl	j
>5965	Identifier	j
>5966	IdentifierDeclType	int
>5967	IncDecOp	 
>5968	IncDec	++
>5969	Identifier	i
>5970	Condition	 
>5971	RelationalExpression	i < n
>5972	Identifier	n
>5973	Identifier	i
>5974	ForInit	 
>5975	AssignmentExpr	i = 0
>5976	PrimaryExpression	0
>5977	Identifier	i
>5978	ExpressionStatement	 
>5979	CallExpression	fprintf ( fp , \"w\n\" )
>5980	ArgumentList	fp
>5981	Argument	\"w\n\"
>5982	PrimaryExpression	\"w\n\"
>5983	Argument	fp
>5984	Identifier	fp
>5985	Callee	fprintf
>5986	Identifier	fprintf
>5987	ExpressionStatement	 
>5988	CallExpression	fprintf ( fp , \"bias %.16g\n\" , model_ -> bias )
>5989	ArgumentList	fp
>5990	Argument	model_ -> bias
>5991	PtrMemberAccess	model_ -> bias
>5992	Identifier	bias
>5993	Identifier	model_
>5994	Argument	\"bias %.16g\n\"
>5995	PrimaryExpression	\"bias %.16g\n\"
>5996	Argument	fp
>5997	Identifier	fp
>5998	Callee	fprintf
>5999	Identifier	fprintf
>6000	ExpressionStatement	 
>6001	CallExpression	fprintf ( fp , \"nr_feature %d\n\" , nr_feature )
>6002	ArgumentList	fp
>6003	Argument	nr_feature
>6004	Identifier	nr_feature
>6005	Argument	\"nr_feature %d\n\"
>6006	PrimaryExpression	\"nr_feature %d\n\"
>6007	Argument	fp
>6008	Identifier	fp
>6009	Callee	fprintf
>6010	Identifier	fprintf
>6011	ExpressionStatement	 
>6012	CallExpression	fprintf ( fp , \"\n\" )
>6013	ArgumentList	fp
>6014	Argument	\"\n\"
>6015	PrimaryExpression	\"\n\"
>6016	Argument	fp
>6017	Identifier	fp
>6018	Callee	fprintf
>6019	Identifier	fprintf
>6020	ForStatement	for ( i = 0 ; i < model_ -> nr_class ; i ++ )
>6021	ExpressionStatement	 
>6022	CallExpression	fprintf ( fp , \" %d\" , model_ -> label [ i ] )
>6023	ArgumentList	fp
>6024	Argument	model_ -> label [ i ]
>6025	ArrayIndexing	model_ -> label [ i ]
>6026	Identifier	i
>6027	PtrMemberAccess	model_ -> label
>6028	Identifier	label
>6029	Identifier	model_
>6030	Argument	\" %d\"
>6031	PrimaryExpression	\" %d\"
>6032	Argument	fp
>6033	Identifier	fp
>6034	Callee	fprintf
>6035	Identifier	fprintf
>6036	IncDecOp	 
>6037	IncDec	++
>6038	Identifier	i
>6039	Condition	 
>6040	RelationalExpression	i < model_ -> nr_class
>6041	PtrMemberAccess	model_ -> nr_class
>6042	Identifier	nr_class
>6043	Identifier	model_
>6044	Identifier	i
>6045	ForInit	 
>6046	AssignmentExpr	i = 0
>6047	PrimaryExpression	0
>6048	Identifier	i
>6049	ExpressionStatement	 
>6050	CallExpression	fprintf ( fp , \"label\" )
>6051	ArgumentList	fp
>6052	Argument	\"label\"
>6053	PrimaryExpression	\"label\"
>6054	Argument	fp
>6055	Identifier	fp
>6056	Callee	fprintf
>6057	Identifier	fprintf
>6058	ExpressionStatement	 
>6059	CallExpression	fprintf ( fp , \"nr_class %d\n\" , model_ -> nr_class )
>6060	ArgumentList	fp
>6061	Argument	model_ -> nr_class
>6062	PtrMemberAccess	model_ -> nr_class
>6063	Identifier	nr_class
>6064	Identifier	model_
>6065	Argument	\"nr_class %d\n\"
>6066	PrimaryExpression	\"nr_class %d\n\"
>6067	Argument	fp
>6068	Identifier	fp
>6069	Callee	fprintf
>6070	Identifier	fprintf
>6071	ExpressionStatement	 
>6072	CallExpression	fprintf ( fp , \"solver_type %s\n\" , solver_type_table [ param . solver_type ] )
>6073	ArgumentList	fp
>6074	Argument	solver_type_table [ param . solver_type ]
>6075	ArrayIndexing	solver_type_table [ param . solver_type ]
>6076	MemberAccess	param . solver_type
>6077	Identifier	solver_type
>6078	Identifier	param
>6079	Identifier	solver_type_table
>6080	Argument	\"solver_type %s\n\"
>6081	PrimaryExpression	\"solver_type %s\n\"
>6082	Argument	fp
>6083	Identifier	fp
>6084	Callee	fprintf
>6085	Identifier	fprintf
>6086	IfStatement	if ( model_ -> nr_class == 2 )
>6087	ElseStatement	else
>6088	ExpressionStatement	 
>6089	AssignmentExpr	nr_classifier = model_ -> nr_class
>6090	PtrMemberAccess	model_ -> nr_class
>6091	Identifier	nr_class
>6092	Identifier	model_
>6093	Identifier	nr_classifier
>6094	ExpressionStatement	 
>6095	AssignmentExpr	nr_classifier = 1
>6096	PrimaryExpression	1
>6097	Identifier	nr_classifier
>6098	Condition	 
>6099	EqualityExpression	model_ -> nr_class == 2
>6100	PrimaryExpression	2
>6101	PtrMemberAccess	model_ -> nr_class
>6102	Identifier	nr_class
>6103	Identifier	model_
>6104	IdentifierDeclStatement	 
>6105	IdentifierDecl	nr_classifier
>6106	Identifier	nr_classifier
>6107	IdentifierDeclType	int
>6108	IfStatement	if ( fp == NULL )
>6109	ReturnStatement	 
>6110	UnaryOp	- 1
>6111	PrimaryExpression	1
>6112	UnaryOperator	-
>6113	Condition	 
>6114	EqualityExpression	fp == NULL
>6115	Identifier	NULL
>6116	Identifier	fp
>6117	IdentifierDeclStatement	 
>6118	IdentifierDecl	* fp = fopen ( model_file_name , \"w\" )
>6119	AssignmentExpr	* fp = fopen ( model_file_name , \"w\" )
>6120	CallExpression	fopen ( model_file_name , \"w\" )
>6121	ArgumentList	model_file_name
>6122	Argument	\"w\"
>6123	PrimaryExpression	\"w\"
>6124	Argument	model_file_name
>6125	Identifier	model_file_name
>6126	Callee	fopen
>6127	Identifier	fopen
>6128	Identifier	fp
>6129	Identifier	fp
>6130	IdentifierDeclType	FILE *
>6131	IfStatement	if ( model_ -> bias >= 0 )
>6132	ElseStatement	else
>6133	ExpressionStatement	 
>6134	AssignmentExpr	n = nr_feature
>6135	Identifier	nr_feature
>6136	Identifier	n
>6137	ExpressionStatement	 
>6138	AssignmentExpr	n = nr_feature + 1
>6139	AdditiveExpression	nr_feature + 1
>6140	PrimaryExpression	1
>6141	Identifier	nr_feature
>6142	Identifier	n
>6143	Condition	 
>6144	RelationalExpression	model_ -> bias >= 0
>6145	PrimaryExpression	0
>6146	PtrMemberAccess	model_ -> bias
>6147	Identifier	bias
>6148	Identifier	model_
>6149	IdentifierDeclStatement	 
>6150	IdentifierDecl	& param = model_ -> param
>6151	AssignmentExpr	& param = model_ -> param
>6152	PtrMemberAccess	model_ -> param
>6153	Identifier	param
>6154	Identifier	model_
>6155	Identifier	param
>6156	Identifier	param
>6157	IdentifierDeclType	const parameter &
>6158	IdentifierDeclStatement	 
>6159	IdentifierDecl	n
>6160	Identifier	n
>6161	IdentifierDeclType	int
>6162	IdentifierDeclStatement	 
>6163	IdentifierDecl	nr_feature = model_ -> nr_feature
>6164	AssignmentExpr	nr_feature = model_ -> nr_feature
>6165	PtrMemberAccess	model_ -> nr_feature
>6166	Identifier	nr_feature
>6167	Identifier	model_
>6168	Identifier	nr_feature
>6169	Identifier	nr_feature
>6170	IdentifierDeclType	int
>6171	IdentifierDeclStatement	 
>6172	IdentifierDecl	i
>6173	Identifier	i
>6174	IdentifierDeclType	int
>6175	IdentifierDeclStatement	 
>6176	IdentifierDecl	* solver_type_table [ ] = { \"L2_LR\" , \"L1_LR\" , \"L2LOSS_SVM\" , NULL }
>6177	AssignmentExpr	* solver_type_table [ ] = { \"L2_LR\" , \"L1_LR\" , \"L2LOSS_SVM\" , NULL }
>6178	InitializerList	\"L2_LR\"
>6179	Identifier	NULL
>6180	PrimaryExpression	\"L2LOSS_SVM\"
>6181	PrimaryExpression	\"L1_LR\"
>6182	PrimaryExpression	\"L2_LR\"
>6183	Identifier	solver_type_table
>6184	Identifier	solver_type_table
>6185	IdentifierDeclType	const char * [ ]
>6220	FunctionDef	linear 
>6221	ParameterList	const char * model_file_name
>6222	Parameter	 
>6223	Identifier	model_file_name
>6224	ParameterType	const char *
>6225	ReturnType	struct model *
>6226	CompoundStatement	 
>6227	ReturnStatement	 
>6228	Identifier	model_
>6229	IfStatement	if ( ferror ( fp ) != 0 || fclose ( fp ) != 0 )
>6230	ReturnStatement	 
>6231	Identifier	NULL
>6232	Condition	 
>6233	OrExpression	ferror ( fp ) != 0 || fclose ( fp ) != 0
>6234	EqualityExpression	fclose ( fp ) != 0
>6235	PrimaryExpression	0
>6236	CallExpression	fclose ( fp )
>6237	ArgumentList	fp
>6238	Argument	fp
>6239	Identifier	fp
>6240	Callee	fclose
>6241	Identifier	fclose
>6242	EqualityExpression	ferror ( fp ) != 0
>6243	PrimaryExpression	0
>6244	CallExpression	ferror ( fp )
>6245	ArgumentList	fp
>6246	Argument	fp
>6247	Identifier	fp
>6248	Callee	ferror
>6249	Identifier	ferror
>6250	ForStatement	for ( i = 0 ; i < n ; i ++ )
>6251	CompoundStatement	 
>6252	ExpressionStatement	 
>6253	UnaryExpression	++ rrr
>6254	Identifier	rrr
>6255	IncDec	++
>6256	IdentifierDeclStatement	 
>6257	IdentifierDecl	rrr = fscanf ( fp , \"\n\" )
>6258	AssignmentExpr	rrr = fscanf ( fp , \"\n\" )
>6259	CallExpression	fscanf ( fp , \"\n\" )
>6260	ArgumentList	fp
>6261	Argument	\"\n\"
>6262	PrimaryExpression	\"\n\"
>6263	Argument	fp
>6264	Identifier	fp
>6265	Callee	fscanf
>6266	Identifier	fscanf
>6267	Identifier	rrr
>6268	Identifier	rrr
>6269	IdentifierDeclType	int
>6270	ForStatement	for ( j = 0 ; j < nr_classifier ; j ++ )
>6271	CompoundStatement	 
>6272	ExpressionStatement	 
>6273	UnaryExpression	++ rrr
>6274	Identifier	rrr
>6275	IncDec	++
>6276	IdentifierDeclStatement	 
>6277	IdentifierDecl	rrr = fscanf ( fp , \"%f \" , & model_ -> w [ j * n + i ] )
>6278	AssignmentExpr	rrr = fscanf ( fp , \"%f \" , & model_ -> w [ j * n + i ] )
>6279	CallExpression	fscanf ( fp , \"%f \" , & model_ -> w [ j * n + i ] )
>6280	ArgumentList	fp
>6281	Argument	& model_ -> w [ j * n + i ]
>6282	UnaryOp	& model_ -> w [ j * n + i ]
>6283	ArrayIndexing	model_ -> w [ j * n + i ]
>6284	AdditiveExpression	j * n + i
>6285	Identifier	i
>6286	MultiplicativeExpression	j * n
>6287	Identifier	n
>6288	Identifier	j
>6289	PtrMemberAccess	model_ -> w
>6290	Identifier	w
>6291	Identifier	model_
>6292	UnaryOperator	&
>6293	Argument	\"%f \"
>6294	PrimaryExpression	\"%f \"
>6295	Argument	fp
>6296	Identifier	fp
>6297	Callee	fscanf
>6298	Identifier	fscanf
>6299	Identifier	rrr
>6300	Identifier	rrr
>6301	IdentifierDeclType	int
>6302	IncDecOp	 
>6303	IncDec	++
>6304	Identifier	j
>6305	Condition	 
>6306	RelationalExpression	j < nr_classifier
>6307	Identifier	nr_classifier
>6308	Identifier	j
>6309	ForInit	 
>6310	AssignmentExpr	j = 0
>6311	PrimaryExpression	0
>6312	Identifier	j
>6313	IdentifierDeclStatement	 
>6314	IdentifierDecl	j
>6315	Identifier	j
>6316	IdentifierDeclType	int
>6317	IncDecOp	 
>6318	IncDec	++
>6319	Identifier	i
>6320	Condition	 
>6321	RelationalExpression	i < n
>6322	Identifier	n
>6323	Identifier	i
>6324	ForInit	 
>6325	AssignmentExpr	i = 0
>6326	PrimaryExpression	0
>6327	Identifier	i
>6328	ExpressionStatement	 
>6329	AssignmentExpr	model_ -> w = Malloc ( float , n * nr_classifier )
>6330	CallExpression	Malloc ( float , n * nr_classifier )
>6331	ArgumentList	float
>6332	Argument	n * nr_classifier
>6333	MultiplicativeExpression	n * nr_classifier
>6334	Identifier	nr_classifier
>6335	Identifier	n
>6336	Argument	float
>6337	Identifier	float
>6338	Callee	Malloc
>6339	Identifier	Malloc
>6340	PtrMemberAccess	model_ -> w
>6341	Identifier	w
>6342	Identifier	model_
>6343	IfStatement	if ( nr_class == 2 )
>6344	ElseStatement	else
>6345	ExpressionStatement	 
>6346	AssignmentExpr	nr_classifier = nr_class
>6347	Identifier	nr_class
>6348	Identifier	nr_classifier
>6349	ExpressionStatement	 
>6350	AssignmentExpr	nr_classifier = 1
>6351	PrimaryExpression	1
>6352	Identifier	nr_classifier
>6353	Condition	 
>6354	EqualityExpression	nr_class == 2
>6355	PrimaryExpression	2
>6356	Identifier	nr_class
>6357	IdentifierDeclStatement	 
>6358	IdentifierDecl	nr_classifier
>6359	Identifier	nr_classifier
>6360	IdentifierDeclType	int
>6361	IfStatement	if ( model_ -> bias >= 0 )
>6362	ElseStatement	else
>6363	ExpressionStatement	 
>6364	AssignmentExpr	n = nr_feature
>6365	Identifier	nr_feature
>6366	Identifier	n
>6367	ExpressionStatement	 
>6368	AssignmentExpr	n = nr_feature + 1
>6369	AdditiveExpression	nr_feature + 1
>6370	PrimaryExpression	1
>6371	Identifier	nr_feature
>6372	Identifier	n
>6373	Condition	 
>6374	RelationalExpression	model_ -> bias >= 0
>6375	PrimaryExpression	0
>6376	PtrMemberAccess	model_ -> bias
>6377	Identifier	bias
>6378	Identifier	model_
>6379	ExpressionStatement	 
>6380	AssignmentExpr	nr_feature = model_ -> nr_feature
>6381	PtrMemberAccess	model_ -> nr_feature
>6382	Identifier	nr_feature
>6383	Identifier	model_
>6384	Identifier	nr_feature
>6385	WhileStatement	while ( 1 )
>6386	CompoundStatement	 
>6387	IfStatement	if ( strcmp ( cmd , \"solver_type\" ) == 0 )
>6388	ElseStatement	else
>6389	IfStatement	if ( strcmp ( cmd , \"nr_class\" ) == 0 )
>6390	ElseStatement	else
>6391	IfStatement	if ( strcmp ( cmd , \"nr_feature\" ) == 0 )
>6392	ElseStatement	else
>6393	IfStatement	if ( strcmp ( cmd , \"bias\" ) == 0 )
>6394	ElseStatement	else
>6395	IfStatement	if ( strcmp ( cmd , \"w\" ) == 0 )
>6396	ElseStatement	else
>6397	IfStatement	if ( strcmp ( cmd , \"label\" ) == 0 )
>6398	ElseStatement	else
>6399	CompoundStatement	 
>6400	ReturnStatement	 
>6401	Identifier	NULL
>6402	ExpressionStatement	 
>6403	CallExpression	fclose ( fp )
>6404	ArgumentList	fp
>6405	Argument	fp
>6406	Identifier	fp
>6407	Callee	fclose
>6408	Identifier	fclose
>6409	ExpressionStatement	 
>6410	CallExpression	free ( model_ )
>6411	ArgumentList	model_
>6412	Argument	model_
>6413	Identifier	model_
>6414	Callee	free
>6415	Identifier	free
>6416	ExpressionStatement	 
>6417	CallExpression	fprintf ( stderr , \"unknown text in model file
>6418	ArgumentList	stderr
>6419	Argument	cmd
>6420	Identifier	cmd
>6421	Argument	\"unknown text in model file
>6422	PrimaryExpression	\"unknown text in model file
>6423	Argument	stderr
>6424	Identifier	stderr
>6425	Callee	fprintf
>6426	Identifier	fprintf
>6427	CompoundStatement	 
>6428	ForStatement	for ( int i = 0 ; i < nr_class ; i ++ )
>6429	CompoundStatement	 
>6430	ExpressionStatement	 
>6431	UnaryExpression	++ rrr
>6432	Identifier	rrr
>6433	IncDec	++
>6434	IdentifierDeclStatement	 
>6435	IdentifierDecl	rrr = fscanf ( fp , \"%d\" , & model_ -> label [ i ] )
>6436	AssignmentExpr	rrr = fscanf ( fp , \"%d\" , & model_ -> label [ i ] )
>6437	CallExpression	fscanf ( fp , \"%d\" , & model_ -> label [ i ] )
>6438	ArgumentList	fp
>6439	Argument	& model_ -> label [ i ]
>6440	UnaryOp	& model_ -> label [ i ]
>6441	ArrayIndexing	model_ -> label [ i ]
>6442	Identifier	i
>6443	PtrMemberAccess	model_ -> label
>6444	Identifier	label
>6445	Identifier	model_
>6446	UnaryOperator	&
>6447	Argument	\"%d\"
>6448	PrimaryExpression	\"%d\"
>6449	Argument	fp
>6450	Identifier	fp
>6451	Callee	fscanf
>6452	Identifier	fscanf
>6453	Identifier	rrr
>6454	Identifier	rrr
>6455	IdentifierDeclType	int
>6456	IncDecOp	 
>6457	IncDec	++
>6458	Identifier	i
>6459	Condition	 
>6460	RelationalExpression	i < nr_class
>6461	Identifier	nr_class
>6462	Identifier	i
>6463	ForInit	 
>6464	IdentifierDeclStatement	int i = 0 ;
>6465	IdentifierDecl	i = 0
>6466	AssignmentExpr	i = 0
>6467	PrimaryExpression	0
>6468	Identifier	i
>6469	Identifier	i
>6470	IdentifierDeclType	int
>6471	ExpressionStatement	 
>6472	AssignmentExpr	model_ -> label = Malloc ( int , nr_class )
>6473	CallExpression	Malloc ( int , nr_class )
>6474	ArgumentList	int
>6475	Argument	nr_class
>6476	Identifier	nr_class
>6477	Argument	int
>6478	Identifier	int
>6479	Callee	Malloc
>6480	Identifier	Malloc
>6481	PtrMemberAccess	model_ -> label
>6482	Identifier	label
>6483	Identifier	model_
>6484	IdentifierDeclStatement	 
>6485	IdentifierDecl	nr_class = model_ -> nr_class
>6486	AssignmentExpr	nr_class = model_ -> nr_class
>6487	PtrMemberAccess	model_ -> nr_class
>6488	Identifier	nr_class
>6489	Identifier	model_
>6490	Identifier	nr_class
>6491	Identifier	nr_class
>6492	IdentifierDeclType	int
>6493	Condition	 
>6494	EqualityExpression	strcmp ( cmd , \"label\" ) == 0
>6495	PrimaryExpression	0
>6496	CallExpression	strcmp ( cmd , \"label\" )
>6497	ArgumentList	cmd
>6498	Argument	\"label\"
>6499	PrimaryExpression	\"label\"
>6500	Argument	cmd
>6501	Identifier	cmd
>6502	Callee	strcmp
>6503	Identifier	strcmp
>6504	CompoundStatement	 
>6505	BreakStatement	 
>6506	Condition	 
>6507	EqualityExpression	strcmp ( cmd , \"w\" ) == 0
>6508	PrimaryExpression	0
>6509	CallExpression	strcmp ( cmd , \"w\" )
>6510	ArgumentList	cmd
>6511	Argument	\"w\"
>6512	PrimaryExpression	\"w\"
>6513	Argument	cmd
>6514	Identifier	cmd
>6515	Callee	strcmp
>6516	Identifier	strcmp
>6517	CompoundStatement	 
>6518	ExpressionStatement	 
>6519	AssignmentExpr	model_ -> bias = bias
>6520	Identifier	bias
>6521	PtrMemberAccess	model_ -> bias
>6522	Identifier	bias
>6523	Identifier	model_
>6524	ExpressionStatement	 
>6525	UnaryExpression	++ rrr
>6526	Identifier	rrr
>6527	IncDec	++
>6528	IdentifierDeclStatement	 
>6529	IdentifierDecl	rrr = fscanf ( fp , \"%f\" , & bias )
>6530	AssignmentExpr	rrr = fscanf ( fp , \"%f\" , & bias )
>6531	CallExpression	fscanf ( fp , \"%f\" , & bias )
>6532	ArgumentList	fp
>6533	Argument	& bias
>6534	UnaryOp	& bias
>6535	Identifier	bias
>6536	UnaryOperator	&
>6537	Argument	\"%f\"
>6538	PrimaryExpression	\"%f\"
>6539	Argument	fp
>6540	Identifier	fp
>6541	Callee	fscanf
>6542	Identifier	fscanf
>6543	Identifier	rrr
>6544	Identifier	rrr
>6545	IdentifierDeclType	int
>6546	Condition	 
>6547	EqualityExpression	strcmp ( cmd , \"bias\" ) == 0
>6548	PrimaryExpression	0
>6549	CallExpression	strcmp ( cmd , \"bias\" )
>6550	ArgumentList	cmd
>6551	Argument	\"bias\"
>6552	PrimaryExpression	\"bias\"
>6553	Argument	cmd
>6554	Identifier	cmd
>6555	Callee	strcmp
>6556	Identifier	strcmp
>6557	CompoundStatement	 
>6558	ExpressionStatement	 
>6559	AssignmentExpr	model_ -> nr_feature = nr_feature
>6560	Identifier	nr_feature
>6561	PtrMemberAccess	model_ -> nr_feature
>6562	Identifier	nr_feature
>6563	Identifier	model_
>6564	ExpressionStatement	 
>6565	UnaryExpression	++ rrr
>6566	Identifier	rrr
>6567	IncDec	++
>6568	IdentifierDeclStatement	 
>6569	IdentifierDecl	rrr = fscanf ( fp , \"%d\" , & nr_feature )
>6570	AssignmentExpr	rrr = fscanf ( fp , \"%d\" , & nr_feature )
>6571	CallExpression	fscanf ( fp , \"%d\" , & nr_feature )
>6572	ArgumentList	fp
>6573	Argument	& nr_feature
>6574	UnaryOp	& nr_feature
>6575	Identifier	nr_feature
>6576	UnaryOperator	&
>6577	Argument	\"%d\"
>6578	PrimaryExpression	\"%d\"
>6579	Argument	fp
>6580	Identifier	fp
>6581	Callee	fscanf
>6582	Identifier	fscanf
>6583	Identifier	rrr
>6584	Identifier	rrr
>6585	IdentifierDeclType	int
>6586	Condition	 
>6587	EqualityExpression	strcmp ( cmd , \"nr_feature\" ) == 0
>6588	PrimaryExpression	0
>6589	CallExpression	strcmp ( cmd , \"nr_feature\" )
>6590	ArgumentList	cmd
>6591	Argument	\"nr_feature\"
>6592	PrimaryExpression	\"nr_feature\"
>6593	Argument	cmd
>6594	Identifier	cmd
>6595	Callee	strcmp
>6596	Identifier	strcmp
>6597	CompoundStatement	 
>6598	ExpressionStatement	 
>6599	AssignmentExpr	model_ -> nr_class = nr_class
>6600	Identifier	nr_class
>6601	PtrMemberAccess	model_ -> nr_class
>6602	Identifier	nr_class
>6603	Identifier	model_
>6604	ExpressionStatement	 
>6605	UnaryExpression	++ rrr
>6606	Identifier	rrr
>6607	IncDec	++
>6608	IdentifierDeclStatement	 
>6609	IdentifierDecl	rrr = fscanf ( fp , \"%d\" , & nr_class )
>6610	AssignmentExpr	rrr = fscanf ( fp , \"%d\" , & nr_class )
>6611	CallExpression	fscanf ( fp , \"%d\" , & nr_class )
>6612	ArgumentList	fp
>6613	Argument	& nr_class
>6614	UnaryOp	& nr_class
>6615	Identifier	nr_class
>6616	UnaryOperator	&
>6617	Argument	\"%d\"
>6618	PrimaryExpression	\"%d\"
>6619	Argument	fp
>6620	Identifier	fp
>6621	Callee	fscanf
>6622	Identifier	fscanf
>6623	Identifier	rrr
>6624	Identifier	rrr
>6625	IdentifierDeclType	int
>6626	Condition	 
>6627	EqualityExpression	strcmp ( cmd , \"nr_class\" ) == 0
>6628	PrimaryExpression	0
>6629	CallExpression	strcmp ( cmd , \"nr_class\" )
>6630	ArgumentList	cmd
>6631	Argument	\"nr_class\"
>6632	PrimaryExpression	\"nr_class\"
>6633	Argument	cmd
>6634	Identifier	cmd
>6635	Callee	strcmp
>6636	Identifier	strcmp
>6637	CompoundStatement	 
>6638	IfStatement	if ( solver_type_table [ i ] == NULL )
>6639	CompoundStatement	 
>6640	ReturnStatement	 
>6641	Identifier	NULL
>6642	ExpressionStatement	 
>6643	CallExpression	fclose ( fp )
>6644	ArgumentList	fp
>6645	Argument	fp
>6646	Identifier	fp
>6647	Callee	fclose
>6648	Identifier	fclose
>6649	ExpressionStatement	 
>6650	CallExpression	free ( model_ )
>6651	ArgumentList	model_
>6652	Argument	model_
>6653	Identifier	model_
>6654	Callee	free
>6655	Identifier	free
>6656	ExpressionStatement	 
>6657	CallExpression	free ( model_ -> label )
>6658	ArgumentList	model_ -> label
>6659	Argument	model_ -> label
>6660	PtrMemberAccess	model_ -> label
>6661	Identifier	label
>6662	Identifier	model_
>6663	Callee	free
>6664	Identifier	free
>6665	ExpressionStatement	 
>6666	CallExpression	fprintf ( stderr , \"unknown solver type.\n\" )
>6667	ArgumentList	stderr
>6668	Argument	\"unknown solver type.\n\"
>6669	PrimaryExpression	\"unknown solver type.\n\"
>6670	Argument	stderr
>6671	Identifier	stderr
>6672	Callee	fprintf
>6673	Identifier	fprintf
>6674	Condition	 
>6675	EqualityExpression	solver_type_table [ i ] == NULL
>6676	Identifier	NULL
>6677	ArrayIndexing	solver_type_table [ i ]
>6678	Identifier	i
>6679	Identifier	solver_type_table
>6680	ForStatement	for ( i = 0 ; solver_type_table [ i ] ; i ++ )
>6681	CompoundStatement	 
>6682	IfStatement	if ( strcmp ( solver_type_table [ i ] , cmd ) == 0 )
>6683	CompoundStatement	 
>6684	BreakStatement	 
>6685	ExpressionStatement	 
>6686	AssignmentExpr	param . solver_type = i
>6687	Identifier	i
>6688	MemberAccess	param . solver_type
>6689	Identifier	solver_type
>6690	Identifier	param
>6691	Condition	 
>6692	EqualityExpression	strcmp ( solver_type_table [ i ] , cmd ) == 0
>6693	PrimaryExpression	0
>6694	CallExpression	strcmp ( solver_type_table [ i ] , cmd )
>6695	ArgumentList	solver_type_table [ i ]
>6696	Argument	cmd
>6697	Identifier	cmd
>6698	Argument	solver_type_table [ i ]
>6699	ArrayIndexing	solver_type_table [ i ]
>6700	Identifier	i
>6701	Identifier	solver_type_table
>6702	Callee	strcmp
>6703	Identifier	strcmp
>6704	IncDecOp	 
>6705	IncDec	++
>6706	Identifier	i
>6707	Condition	 
>6708	ArrayIndexing	solver_type_table [ i ]
>6709	Identifier	i
>6710	Identifier	solver_type_table
>6711	ForInit	 
>6712	AssignmentExpr	i = 0
>6713	PrimaryExpression	0
>6714	Identifier	i
>6715	IdentifierDeclStatement	 
>6716	IdentifierDecl	i
>6717	Identifier	i
>6718	IdentifierDeclType	int
>6719	ExpressionStatement	 
>6720	UnaryExpression	++ rrr
>6721	Identifier	rrr
>6722	IncDec	++
>6723	IdentifierDeclStatement	 
>6724	IdentifierDecl	rrr = fscanf ( fp , \"%80s\" , cmd )
>6725	AssignmentExpr	rrr = fscanf ( fp , \"%80s\" , cmd )
>6726	CallExpression	fscanf ( fp , \"%80s\" , cmd )
>6727	ArgumentList	fp
>6728	Argument	cmd
>6729	Identifier	cmd
>6730	Argument	\"%80s\"
>6731	PrimaryExpression	\"%80s\"
>6732	Argument	fp
>6733	Identifier	fp
>6734	Callee	fscanf
>6735	Identifier	fscanf
>6736	Identifier	rrr
>6737	Identifier	rrr
>6738	IdentifierDeclType	int
>6739	Condition	 
>6740	EqualityExpression	strcmp ( cmd , \"solver_type\" ) == 0
>6741	PrimaryExpression	0
>6742	CallExpression	strcmp ( cmd , \"solver_type\" )
>6743	ArgumentList	cmd
>6744	Argument	\"solver_type\"
>6745	PrimaryExpression	\"solver_type\"
>6746	Argument	cmd
>6747	Identifier	cmd
>6748	Callee	strcmp
>6749	Identifier	strcmp
>6750	ExpressionStatement	 
>6751	UnaryExpression	++ rrr
>6752	Identifier	rrr
>6753	IncDec	++
>6754	IdentifierDeclStatement	 
>6755	IdentifierDecl	rrr = fscanf ( fp , \"%80s\" , cmd )
>6756	AssignmentExpr	rrr = fscanf ( fp , \"%80s\" , cmd )
>6757	CallExpression	fscanf ( fp , \"%80s\" , cmd )
>6758	ArgumentList	fp
>6759	Argument	cmd
>6760	Identifier	cmd
>6761	Argument	\"%80s\"
>6762	PrimaryExpression	\"%80s\"
>6763	Argument	fp
>6764	Identifier	fp
>6765	Callee	fscanf
>6766	Identifier	fscanf
>6767	Identifier	rrr
>6768	Identifier	rrr
>6769	IdentifierDeclType	int
>6770	Condition	 
>6771	PrimaryExpression	1
>6772	IdentifierDeclStatement	 
>6773	IdentifierDecl	cmd [ 81 ]
>6774	PrimaryExpression	81
>6775	Identifier	cmd
>6776	IdentifierDeclType	char [ 81 ]
>6777	ExpressionStatement	 
>6778	AssignmentExpr	model_ -> label = NULL
>6779	Identifier	NULL
>6780	PtrMemberAccess	model_ -> label
>6781	Identifier	label
>6782	Identifier	model_
>6783	IdentifierDeclStatement	 
>6784	IdentifierDecl	& param = model_ -> param
>6785	AssignmentExpr	& param = model_ -> param
>6786	PtrMemberAccess	model_ -> param
>6787	Identifier	param
>6788	Identifier	model_
>6789	Identifier	param
>6790	Identifier	param
>6791	IdentifierDeclType	parameter &
>6792	IdentifierDeclStatement	 
>6793	IdentifierDecl	* model_ = Malloc ( model , 1 )
>6794	AssignmentExpr	* model_ = Malloc ( model , 1 )
>6795	CallExpression	Malloc ( model , 1 )
>6796	ArgumentList	model
>6797	Argument	1
>6798	PrimaryExpression	1
>6799	Argument	model
>6800	Identifier	model
>6801	Callee	Malloc
>6802	Identifier	Malloc
>6803	Identifier	model_
>6804	Identifier	model_
>6805	IdentifierDeclType	model *
>6806	IdentifierDeclStatement	 
>6807	IdentifierDecl	bias
>6808	Identifier	bias
>6809	IdentifierDeclType	float
>6810	IdentifierDeclStatement	 
>6811	IdentifierDecl	nr_class
>6812	Identifier	nr_class
>6813	IdentifierDeclType	int
>6814	IdentifierDeclStatement	 
>6815	IdentifierDecl	n
>6816	Identifier	n
>6817	IdentifierDeclType	int
>6818	IdentifierDeclStatement	 
>6819	IdentifierDecl	nr_feature
>6820	Identifier	nr_feature
>6821	IdentifierDeclType	int
>6822	IdentifierDeclStatement	 
>6823	IdentifierDecl	i
>6824	Identifier	i
>6825	IdentifierDeclType	int
>6826	IfStatement	if ( fp == NULL )
>6827	ReturnStatement	 
>6828	Identifier	NULL
>6829	Condition	 
>6830	EqualityExpression	fp == NULL
>6831	Identifier	NULL
>6832	Identifier	fp
>6833	IdentifierDeclStatement	 
>6834	IdentifierDecl	* fp = fopen ( model_file_name , \"r\" )
>6835	AssignmentExpr	* fp = fopen ( model_file_name , \"r\" )
>6836	CallExpression	fopen ( model_file_name , \"r\" )
>6837	ArgumentList	model_file_name
>6838	Argument	\"r\"
>6839	PrimaryExpression	\"r\"
>6840	Argument	model_file_name
>6841	Identifier	model_file_name
>6842	Callee	fopen
>6843	Identifier	fopen
>6844	Identifier	fp
>6845	Identifier	fp
>6846	IdentifierDeclType	FILE *
>6847	IdentifierDeclStatement	 
>6848	IdentifierDecl	* solver_type_table [ ] = { \"L2_LR\" , \"L1_LR\" , \"L2LOSS_SVM\" , NULL }
>6849	AssignmentExpr	* solver_type_table [ ] = { \"L2_LR\" , \"L1_LR\" , \"L2LOSS_SVM\" , NULL }
>6850	InitializerList	\"L2_LR\"
>6851	Identifier	NULL
>6852	PrimaryExpression	\"L2LOSS_SVM\"
>6853	PrimaryExpression	\"L1_LR\"
>6854	PrimaryExpression	\"L2_LR\"
>6855	Identifier	solver_type_table
>6856	Identifier	solver_type_table
>6857	IdentifierDeclType	const char * [ ]
>6905	FunctionDef	linear 
>6906	ParameterList	const struct model * model_ , const struct feature_node * x , float * dec_values
>6907	Parameter	 
>6908	Identifier	dec_values
>6909	ParameterType	float *
>6910	Parameter	 
>6911	Identifier	x
>6912	ParameterType	const struct feature_node *
>6913	Parameter	 
>6914	Identifier	model_
>6915	ParameterType	const struct model *
>6916	ReturnType	int
>6917	CompoundStatement	 
>6918	IfStatement	if ( nr_class == 2 )
>6919	ElseStatement	else
>6920	CompoundStatement	 
>6921	ReturnStatement	 
>6922	ArrayIndexing	model_ -> label [ dec_max_idx ]
>6923	Identifier	dec_max_idx
>6924	PtrMemberAccess	model_ -> label
>6925	Identifier	label
>6926	Identifier	model_
>6927	ForStatement	for ( int i = 1 ; i < nr_class ; i ++ )
>6928	CompoundStatement	 
>6929	IfStatement	if ( dec_values [ i ] > dec_values [ dec_max_idx ] )
>6930	ExpressionStatement	 
>6931	AssignmentExpr	dec_max_idx = i
>6932	Identifier	i
>6933	Identifier	dec_max_idx
>6934	Condition	 
>6935	RelationalExpression	dec_values [ i ] > dec_values [ dec_max_idx ]
>6936	ArrayIndexing	dec_values [ dec_max_idx ]
>6937	Identifier	dec_max_idx
>6938	Identifier	dec_values
>6939	ArrayIndexing	dec_values [ i ]
>6940	Identifier	i
>6941	Identifier	dec_values
>6942	IncDecOp	 
>6943	IncDec	++
>6944	Identifier	i
>6945	Condition	 
>6946	RelationalExpression	i < nr_class
>6947	Identifier	nr_class
>6948	Identifier	i
>6949	ForInit	 
>6950	IdentifierDeclStatement	int i = 1 ;
>6951	IdentifierDecl	i = 1
>6952	AssignmentExpr	i = 1
>6953	PrimaryExpression	1
>6954	Identifier	i
>6955	Identifier	i
>6956	IdentifierDeclType	int
>6957	IdentifierDeclStatement	 
>6958	IdentifierDecl	dec_max_idx = 0
>6959	AssignmentExpr	dec_max_idx = 0
>6960	PrimaryExpression	0
>6961	Identifier	dec_max_idx
>6962	Identifier	dec_max_idx
>6963	IdentifierDeclType	int
>6964	ReturnStatement	 
>6965	ConditionalExpression	( dec_values [ 0 ] > 0 ) ? model_ -> label [ 0 ] 
>6966	ArrayIndexing	model_ -> label [ 1 ]
>6967	PrimaryExpression	1
>6968	PtrMemberAccess	model_ -> label
>6969	Identifier	label
>6970	Identifier	model_
>6971	ArrayIndexing	model_ -> label [ 0 ]
>6972	PrimaryExpression	0
>6973	PtrMemberAccess	model_ -> label
>6974	Identifier	label
>6975	Identifier	model_
>6976	Condition	dec_values [ 0 ] > 0
>6977	RelationalExpression	dec_values [ 0 ] > 0
>6978	PrimaryExpression	0
>6979	ArrayIndexing	dec_values [ 0 ]
>6980	PrimaryExpression	0
>6981	Identifier	dec_values
>6982	Condition	 
>6983	EqualityExpression	nr_class == 2
>6984	PrimaryExpression	2
>6985	Identifier	nr_class
>6986	ForStatement	for ( int i = 0 ; i < nr_classifier ; i ++ )
>6987	CompoundStatement	 
>6988	ExpressionStatement	 
>6989	AssignmentExpr	dec_values [ i ] = wtx
>6990	Identifier	wtx
>6991	ArrayIndexing	dec_values [ i ]
>6992	Identifier	i
>6993	Identifier	dec_values
>6994	ForStatement	for ( ; ( idx = lx -> index ) != - 1 ; lx ++ )
>6995	CompoundStatement	 
>6996	IfStatement	if ( idx <= n )
>6997	ExpressionStatement	 
>6998	AssignmentExpr	wtx += w [ i * n + idx - 1 ] * lx -> value
>6999	MultiplicativeExpression	w [ i * n + idx - 1 ] * lx -> value
>7000	PtrMemberAccess	lx -> value
>7001	Identifier	value
>7002	Identifier	lx
>7003	ArrayIndexing	w [ i * n + idx - 1 ]
>7004	AdditiveExpression	i * n + idx - 1
>7005	AdditiveExpression	idx - 1
>7006	PrimaryExpression	1
>7007	Identifier	idx
>7008	MultiplicativeExpression	i * n
>7009	Identifier	n
>7010	Identifier	i
>7011	Identifier	w
>7012	Identifier	wtx
>7013	Condition	 
>7014	RelationalExpression	idx <= n
>7015	Identifier	n
>7016	Identifier	idx
>7017	IncDecOp	 
>7018	IncDec	++
>7019	Identifier	lx
>7020	Condition	 
>7021	EqualityExpression	( idx = lx -> index ) != - 1
>7022	UnaryOp	- 1
>7023	PrimaryExpression	1
>7024	UnaryOperator	-
>7025	AssignmentExpr	idx = lx -> index
>7026	PtrMemberAccess	lx -> index
>7027	Identifier	index
>7028	Identifier	lx
>7029	Identifier	idx
>7030	IdentifierDeclStatement	 
>7031	IdentifierDecl	idx
>7032	Identifier	idx
>7033	IdentifierDeclType	int
>7034	IdentifierDeclStatement	 
>7035	IdentifierDecl	wtx = 0.0f
>7036	AssignmentExpr	wtx = 0.0f
>7037	PrimaryExpression	0.0f
>7038	Identifier	wtx
>7039	Identifier	wtx
>7040	IdentifierDeclType	float
>7041	IdentifierDeclStatement	 
>7042	IdentifierDecl	* lx = x
>7043	AssignmentExpr	* lx = x
>7044	Identifier	x
>7045	Identifier	x
>7046	Identifier	lx
>7047	IdentifierDeclType	const feature_node *
>7048	IncDecOp	 
>7049	IncDec	++
>7050	Identifier	i
>7051	Condition	 
>7052	RelationalExpression	i < nr_classifier
>7053	Identifier	nr_classifier
>7054	Identifier	i
>7055	ForInit	 
>7056	IdentifierDeclStatement	int i = 0 ;
>7057	IdentifierDecl	i = 0
>7058	AssignmentExpr	i = 0
>7059	PrimaryExpression	0
>7060	Identifier	i
>7061	Identifier	i
>7062	IdentifierDeclType	int
>7063	IfStatement	if ( nr_class == 2 )
>7064	ElseStatement	else
>7065	ExpressionStatement	 
>7066	AssignmentExpr	nr_classifier = nr_class
>7067	Identifier	nr_class
>7068	Identifier	nr_classifier
>7069	ExpressionStatement	 
>7070	AssignmentExpr	nr_classifier = 1
>7071	PrimaryExpression	1
>7072	Identifier	nr_classifier
>7073	Condition	 
>7074	EqualityExpression	nr_class == 2
>7075	PrimaryExpression	2
>7076	Identifier	nr_class
>7077	IdentifierDeclStatement	 
>7078	IdentifierDecl	nr_classifier
>7079	Identifier	nr_classifier
>7080	IdentifierDeclType	int
>7081	IdentifierDeclStatement	 
>7082	IdentifierDecl	nr_class = model_ -> nr_class
>7083	AssignmentExpr	nr_class = model_ -> nr_class
>7084	PtrMemberAccess	model_ -> nr_class
>7085	Identifier	nr_class
>7086	Identifier	model_
>7087	Identifier	nr_class
>7088	Identifier	nr_class
>7089	IdentifierDeclType	int
>7090	IdentifierDeclStatement	 
>7091	IdentifierDecl	* w = model_ -> w
>7092	AssignmentExpr	* w = model_ -> w
>7093	PtrMemberAccess	model_ -> w
>7094	Identifier	w
>7095	Identifier	model_
>7096	Identifier	w
>7097	Identifier	w
>7098	IdentifierDeclType	float *
>7099	IfStatement	if ( model_ -> bias >= 0 )
>7100	ElseStatement	else
>7101	ExpressionStatement	 
>7102	AssignmentExpr	n = model_ -> nr_feature
>7103	PtrMemberAccess	model_ -> nr_feature
>7104	Identifier	nr_feature
>7105	Identifier	model_
>7106	Identifier	n
>7107	ExpressionStatement	 
>7108	AssignmentExpr	n = model_ -> nr_feature + 1
>7109	AdditiveExpression	model_ -> nr_feature + 1
>7110	PrimaryExpression	1
>7111	PtrMemberAccess	model_ -> nr_feature
>7112	Identifier	nr_feature
>7113	Identifier	model_
>7114	Identifier	n
>7115	Condition	 
>7116	RelationalExpression	model_ -> bias >= 0
>7117	PrimaryExpression	0
>7118	PtrMemberAccess	model_ -> bias
>7119	Identifier	bias
>7120	Identifier	model_
>7121	IdentifierDeclStatement	 
>7122	IdentifierDecl	n
>7123	Identifier	n
>7124	IdentifierDeclType	int
>7157	FunctionDef	linear 
>7158	ParameterList	const model * model_ , const feature_node * x
>7159	Parameter	 
>7160	Identifier	x
>7161	ParameterType	const feature_node *
>7162	Parameter	 
>7163	Identifier	model_
>7164	ParameterType	const model *
>7165	ReturnType	int
>7166	CompoundStatement	 
>7167	ReturnStatement	 
>7168	Identifier	label
>7169	ExpressionStatement	 
>7170	CallExpression	free ( dec_values )
>7171	ArgumentList	dec_values
>7172	Argument	dec_values
>7173	Identifier	dec_values
>7174	Callee	free
>7175	Identifier	free
>7176	IdentifierDeclStatement	 
>7177	IdentifierDecl	label = predict_values ( model_ , x , dec_values )
>7178	AssignmentExpr	label = predict_values ( model_ , x , dec_values )
>7179	CallExpression	predict_values ( model_ , x , dec_values )
>7180	ArgumentList	model_
>7181	Argument	dec_values
>7182	Identifier	dec_values
>7183	Argument	x
>7184	Identifier	x
>7185	Argument	model_
>7186	Identifier	model_
>7187	Callee	predict_values
>7188	Identifier	predict_values
>7189	Identifier	label
>7190	Identifier	label
>7191	IdentifierDeclType	int
>7192	ExpressionStatement	 
>7193	CallExpression	std 
>7194	ArgumentList	dec_values
>7195	Argument	( float ) 0
>7196	CastExpression	( float ) 0
>7197	PrimaryExpression	0
>7198	CastTarget	float
>7199	Argument	dec_values + model_ -> nr_class
>7200	AdditiveExpression	dec_values + model_ -> nr_class
>7201	PtrMemberAccess	model_ -> nr_class
>7202	Identifier	nr_class
>7203	Identifier	model_
>7204	Identifier	dec_values
>7205	Argument	dec_values
>7206	Identifier	dec_values
>7207	Callee	std 
>7208	Identifier	std 
>7209	IdentifierDeclStatement	 
>7210	IdentifierDecl	* dec_values = Malloc ( float , model_ -> nr_class )
>7211	AssignmentExpr	* dec_values = Malloc ( float , model_ -> nr_class )
>7212	CallExpression	Malloc ( float , model_ -> nr_class )
>7213	ArgumentList	float
>7214	Argument	model_ -> nr_class
>7215	PtrMemberAccess	model_ -> nr_class
>7216	Identifier	nr_class
>7217	Identifier	model_
>7218	Argument	float
>7219	Identifier	float
>7220	Callee	Malloc
>7221	Identifier	Malloc
>7222	Identifier	dec_values
>7223	Identifier	dec_values
>7224	IdentifierDeclType	float *
>7237	FunctionDef	linear 
>7238	ParameterList	const struct model * model_ , const struct feature_node * x , float * prob_estimates
>7239	Parameter	 
>7240	Identifier	prob_estimates
>7241	ParameterType	float *
>7242	Parameter	 
>7243	Identifier	x
>7244	ParameterType	const struct feature_node *
>7245	Parameter	 
>7246	Identifier	model_
>7247	ParameterType	const struct model *
>7248	ReturnType	int
>7249	CompoundStatement	 
>7250	IfStatement	if ( model_ -> param . solver_type == L2_LR )
>7251	ElseStatement	else
>7252	ReturnStatement	 
>7253	PrimaryExpression	0
>7254	CompoundStatement	 
>7255	ReturnStatement	 
>7256	Identifier	label
>7257	IfStatement	if ( nr_class == 2 )
>7258	ElseStatement	else
>7259	CompoundStatement	 
>7260	ForStatement	for ( i = 0 ; i < nr_class ; i ++ )
>7261	ExpressionStatement	 
>7262	AssignmentExpr	prob_estimates [ i ] = prob_estimates [ i ] / sum
>7263	MultiplicativeExpression	prob_estimates [ i ] / sum
>7264	Identifier	sum
>7265	ArrayIndexing	prob_estimates [ i ]
>7266	Identifier	i
>7267	Identifier	prob_estimates
>7268	ArrayIndexing	prob_estimates [ i ]
>7269	Identifier	i
>7270	Identifier	prob_estimates
>7271	IncDecOp	 
>7272	IncDec	++
>7273	Identifier	i
>7274	Condition	 
>7275	RelationalExpression	i < nr_class
>7276	Identifier	nr_class
>7277	Identifier	i
>7278	ForInit	 
>7279	AssignmentExpr	i = 0
>7280	PrimaryExpression	0
>7281	Identifier	i
>7282	ForStatement	for ( i = 0 ; i < nr_class ; i ++ )
>7283	ExpressionStatement	 
>7284	AssignmentExpr	sum += prob_estimates [ i ]
>7285	ArrayIndexing	prob_estimates [ i ]
>7286	Identifier	i
>7287	Identifier	prob_estimates
>7288	Identifier	sum
>7289	IncDecOp	 
>7290	IncDec	++
>7291	Identifier	i
>7292	Condition	 
>7293	RelationalExpression	i < nr_class
>7294	Identifier	nr_class
>7295	Identifier	i
>7296	ForInit	 
>7297	AssignmentExpr	i = 0
>7298	PrimaryExpression	0
>7299	Identifier	i
>7300	IdentifierDeclStatement	 
>7301	IdentifierDecl	sum = 0.0f
>7302	AssignmentExpr	sum = 0.0f
>7303	PrimaryExpression	0.0f
>7304	Identifier	sum
>7305	Identifier	sum
>7306	IdentifierDeclType	float
>7307	ExpressionStatement	 
>7308	AssignmentExpr	prob_estimates [ 1 ] = 1.0f - prob_estimates [ 0 ]
>7309	AdditiveExpression	1.0f - prob_estimates [ 0 ]
>7310	ArrayIndexing	prob_estimates [ 0 ]
>7311	PrimaryExpression	0
>7312	Identifier	prob_estimates
>7313	PrimaryExpression	1.0f
>7314	ArrayIndexing	prob_estimates [ 1 ]
>7315	PrimaryExpression	1
>7316	Identifier	prob_estimates
>7317	Condition	 
>7318	EqualityExpression	nr_class == 2
>7319	PrimaryExpression	2
>7320	Identifier	nr_class
>7321	ForStatement	for ( i = 0 ; i < nr_classifier ; i ++ )
>7322	ExpressionStatement	 
>7323	AssignmentExpr	prob_estimates [ i ] = 1.0f / ( 1.0f + exp ( - prob_estimates [ i ] ) )
>7324	MultiplicativeExpression	1.0f / ( 1.0f + exp ( - prob_estimates [ i ] ) )
>7325	AdditiveExpression	1.0f + exp ( - prob_estimates [ i ] )
>7326	CallExpression	exp ( - prob_estimates [ i ] )
>7327	ArgumentList	- prob_estimates [ i ]
>7328	Argument	- prob_estimates [ i ]
>7329	UnaryOp	- prob_estimates [ i ]
>7330	ArrayIndexing	prob_estimates [ i ]
>7331	Identifier	i
>7332	Identifier	prob_estimates
>7333	UnaryOperator	-
>7334	Callee	exp
>7335	Identifier	exp
>7336	PrimaryExpression	1.0f
>7337	PrimaryExpression	1.0f
>7338	ArrayIndexing	prob_estimates [ i ]
>7339	Identifier	i
>7340	Identifier	prob_estimates
>7341	IncDecOp	 
>7342	IncDec	++
>7343	Identifier	i
>7344	Condition	 
>7345	RelationalExpression	i < nr_classifier
>7346	Identifier	nr_classifier
>7347	Identifier	i
>7348	ForInit	 
>7349	AssignmentExpr	i = 0
>7350	PrimaryExpression	0
>7351	Identifier	i
>7352	IdentifierDeclStatement	 
>7353	IdentifierDecl	label = predict_values ( model_ , x , prob_estimates )
>7354	AssignmentExpr	label = predict_values ( model_ , x , prob_estimates )
>7355	CallExpression	predict_values ( model_ , x , prob_estimates )
>7356	ArgumentList	model_
>7357	Argument	prob_estimates
>7358	Identifier	prob_estimates
>7359	Argument	x
>7360	Identifier	x
>7361	Argument	model_
>7362	Identifier	model_
>7363	Callee	predict_values
>7364	Identifier	predict_values
>7365	Identifier	label
>7366	Identifier	label
>7367	IdentifierDeclType	int
>7368	IfStatement	if ( nr_class == 2 )
>7369	ElseStatement	else
>7370	ExpressionStatement	 
>7371	AssignmentExpr	nr_classifier = nr_class
>7372	Identifier	nr_class
>7373	Identifier	nr_classifier
>7374	ExpressionStatement	 
>7375	AssignmentExpr	nr_classifier = 1
>7376	PrimaryExpression	1
>7377	Identifier	nr_classifier
>7378	Condition	 
>7379	EqualityExpression	nr_class == 2
>7380	PrimaryExpression	2
>7381	Identifier	nr_class
>7382	IdentifierDeclStatement	 
>7383	IdentifierDecl	nr_classifier
>7384	Identifier	nr_classifier
>7385	IdentifierDeclType	int
>7386	IdentifierDeclStatement	 
>7387	IdentifierDecl	nr_class = model_ -> nr_class
>7388	AssignmentExpr	nr_class = model_ -> nr_class
>7389	PtrMemberAccess	model_ -> nr_class
>7390	Identifier	nr_class
>7391	Identifier	model_
>7392	Identifier	nr_class
>7393	Identifier	nr_class
>7394	IdentifierDeclType	int
>7395	IdentifierDeclStatement	 
>7396	IdentifierDecl	i
>7397	Identifier	i
>7398	IdentifierDeclType	int
>7399	Condition	 
>7400	EqualityExpression	model_ -> param . solver_type == L2_LR
>7401	Identifier	L2_LR
>7402	MemberAccess	model_ -> param . solver_type
>7403	Identifier	solver_type
>7404	PtrMemberAccess	model_ -> param
>7405	Identifier	param
>7406	Identifier	model_
>7427	FunctionDef	linear 
>7428	ParameterList	const problem * prob , const parameter * param , int nr_fold , int * target
>7429	Parameter	 
>7430	Identifier	target
>7431	ParameterType	int *
>7432	Parameter	 
>7433	Identifier	nr_fold
>7434	ParameterType	int
>7435	Parameter	 
>7436	Identifier	param
>7437	ParameterType	const parameter *
>7438	Parameter	 
>7439	Identifier	prob
>7440	ParameterType	const problem *
>7441	ReturnType	void
>7442	CompoundStatement	 
>7443	ExpressionStatement	 
>7444	CallExpression	free ( perm )
>7445	ArgumentList	perm
>7446	Argument	perm
>7447	Identifier	perm
>7448	Callee	free
>7449	Identifier	free
>7450	ExpressionStatement	 
>7451	CallExpression	free ( fold_start )
>7452	ArgumentList	fold_start
>7453	Argument	fold_start
>7454	Identifier	fold_start
>7455	Callee	free
>7456	Identifier	free
>7457	ForStatement	for ( i = 0 ; i < nr_fold ; i ++ )
>7458	CompoundStatement	 
>7459	ExpressionStatement	 
>7460	Identifier	submodel
>7461	Statement	 
>7462	ForStatement	for ( j = begin ; j < end ; j ++ )
>7463	ExpressionStatement	 
>7464	AssignmentExpr	target [ perm [ j ] ] = predict ( submodel , prob -> x [ perm [ j ] ] )
>7465	CallExpression	predict ( submodel , prob -> x [ perm [ j ] ] )
>7466	ArgumentList	submodel
>7467	Argument	prob -> x [ perm [ j ] ]
>7468	ArrayIndexing	prob -> x [ perm [ j ] ]
>7469	ArrayIndexing	perm [ j ]
>7470	Identifier	j
>7471	Identifier	perm
>7472	PtrMemberAccess	prob -> x
>7473	Identifier	x
>7474	Identifier	prob
>7475	Argument	submodel
>7476	Identifier	submodel
>7477	Callee	predict
>7478	Identifier	predict
>7479	ArrayIndexing	target [ perm [ j ] ]
>7480	ArrayIndexing	perm [ j ]
>7481	Identifier	j
>7482	Identifier	perm
>7483	Identifier	target
>7484	IncDecOp	 
>7485	IncDec	++
>7486	Identifier	j
>7487	Condition	 
>7488	RelationalExpression	j < end
>7489	Identifier	end
>7490	Identifier	j
>7491	ForInit	 
>7492	AssignmentExpr	j = begin
>7493	Identifier	begin
>7494	Identifier	j
>7495	IdentifierDeclStatement	 
>7496	IdentifierDecl	* submodel = train ( & subprob , param )
>7497	AssignmentExpr	* submodel = train ( & subprob , param )
>7498	CallExpression	train ( & subprob , param )
>7499	ArgumentList	& subprob
>7500	Argument	param
>7501	Identifier	param
>7502	Argument	& subprob
>7503	UnaryOp	& subprob
>7504	Identifier	subprob
>7505	UnaryOperator	&
>7506	Callee	train
>7507	Identifier	train
>7508	Identifier	submodel
>7509	Identifier	submodel
>7510	IdentifierDeclType	struct model *
>7511	ForStatement	for ( j = end ; j < l ; j ++ )
>7512	CompoundStatement	 
>7513	ExpressionStatement	 
>7514	UnaryExpression	++ k
>7515	Identifier	k
>7516	IncDec	++
>7517	ExpressionStatement	 
>7518	AssignmentExpr	subprob . y [ k ] = prob -> y [ perm [ j ] ]
>7519	ArrayIndexing	prob -> y [ perm [ j ] ]
>7520	ArrayIndexing	perm [ j ]
>7521	Identifier	j
>7522	Identifier	perm
>7523	PtrMemberAccess	prob -> y
>7524	Identifier	y
>7525	Identifier	prob
>7526	ArrayIndexing	subprob . y [ k ]
>7527	Identifier	k
>7528	MemberAccess	subprob . y
>7529	Identifier	y
>7530	Identifier	subprob
>7531	ExpressionStatement	 
>7532	AssignmentExpr	subprob . x [ k ] = prob -> x [ perm [ j ] ]
>7533	ArrayIndexing	prob -> x [ perm [ j ] ]
>7534	ArrayIndexing	perm [ j ]
>7535	Identifier	j
>7536	Identifier	perm
>7537	PtrMemberAccess	prob -> x
>7538	Identifier	x
>7539	Identifier	prob
>7540	ArrayIndexing	subprob . x [ k ]
>7541	Identifier	k
>7542	MemberAccess	subprob . x
>7543	Identifier	x
>7544	Identifier	subprob
>7545	IncDecOp	 
>7546	IncDec	++
>7547	Identifier	j
>7548	Condition	 
>7549	RelationalExpression	j < l
>7550	Identifier	l
>7551	Identifier	j
>7552	ForInit	 
>7553	AssignmentExpr	j = end
>7554	Identifier	end
>7555	Identifier	j
>7556	ForStatement	for ( j = 0 ; j < begin ; j ++ )
>7557	CompoundStatement	 
>7558	ExpressionStatement	 
>7559	UnaryExpression	++ k
>7560	Identifier	k
>7561	IncDec	++
>7562	ExpressionStatement	 
>7563	AssignmentExpr	subprob . y [ k ] = prob -> y [ perm [ j ] ]
>7564	ArrayIndexing	prob -> y [ perm [ j ] ]
>7565	ArrayIndexing	perm [ j ]
>7566	Identifier	j
>7567	Identifier	perm
>7568	PtrMemberAccess	prob -> y
>7569	Identifier	y
>7570	Identifier	prob
>7571	ArrayIndexing	subprob . y [ k ]
>7572	Identifier	k
>7573	MemberAccess	subprob . y
>7574	Identifier	y
>7575	Identifier	subprob
>7576	ExpressionStatement	 
>7577	AssignmentExpr	subprob . x [ k ] = prob -> x [ perm [ j ] ]
>7578	ArrayIndexing	prob -> x [ perm [ j ] ]
>7579	ArrayIndexing	perm [ j ]
>7580	Identifier	j
>7581	Identifier	perm
>7582	PtrMemberAccess	prob -> x
>7583	Identifier	x
>7584	Identifier	prob
>7585	ArrayIndexing	subprob . x [ k ]
>7586	Identifier	k
>7587	MemberAccess	subprob . x
>7588	Identifier	x
>7589	Identifier	subprob
>7590	IncDecOp	 
>7591	IncDec	++
>7592	Identifier	j
>7593	Condition	 
>7594	RelationalExpression	j < begin
>7595	Identifier	begin
>7596	Identifier	j
>7597	ForInit	 
>7598	AssignmentExpr	j = 0
>7599	PrimaryExpression	0
>7600	Identifier	j
>7601	ExpressionStatement	 
>7602	AssignmentExpr	k = 0
>7603	PrimaryExpression	0
>7604	Identifier	k
>7605	IdentifierDeclStatement	 
>7606	IdentifierDecl	subprob ( l - ( end - begin ) , prob -> n , prob -> bias )
>7607	Expression	l - ( end - begin ) , prob -> n , prob -> bias
>7608	Expression	prob -> n , prob -> bias
>7609	PtrMemberAccess	prob -> bias
>7610	Identifier	bias
>7611	Identifier	prob
>7612	PtrMemberAccess	prob -> n
>7613	Identifier	n
>7614	Identifier	prob
>7615	AdditiveExpression	l - ( end - begin )
>7616	AdditiveExpression	end - begin
>7617	Identifier	begin
>7618	Identifier	end
>7619	Identifier	l
>7620	Identifier	subprob
>7621	IdentifierDeclType	struct problem
>7622	IdentifierDeclStatement	 
>7623	IdentifierDecl	k
>7624	Identifier	k
>7625	IdentifierDeclType	int
>7626	IdentifierDecl	j
>7627	Identifier	j
>7628	IdentifierDeclType	int
>7629	IdentifierDeclStatement	 
>7630	IdentifierDecl	end = fold_start [ i + 1 ]
>7631	AssignmentExpr	end = fold_start [ i + 1 ]
>7632	ArrayIndexing	fold_start [ i + 1 ]
>7633	AdditiveExpression	i + 1
>7634	PrimaryExpression	1
>7635	Identifier	i
>7636	Identifier	fold_start
>7637	Identifier	end
>7638	Identifier	end
>7639	IdentifierDeclType	int
>7640	IdentifierDeclStatement	 
>7641	IdentifierDecl	begin = fold_start [ i ]
>7642	AssignmentExpr	begin = fold_start [ i ]
>7643	ArrayIndexing	fold_start [ i ]
>7644	Identifier	i
>7645	Identifier	fold_start
>7646	Identifier	begin
>7647	Identifier	begin
>7648	IdentifierDeclType	int
>7649	IncDecOp	 
>7650	IncDec	++
>7651	Identifier	i
>7652	Condition	 
>7653	RelationalExpression	i < nr_fold
>7654	Identifier	nr_fold
>7655	Identifier	i
>7656	ForInit	 
>7657	AssignmentExpr	i = 0
>7658	PrimaryExpression	0
>7659	Identifier	i
>7660	ForStatement	for ( i = 0 ; i <= nr_fold ; i ++ )
>7661	ExpressionStatement	 
>7662	AssignmentExpr	fold_start [ i ] = i * l / nr_fold
>7663	MultiplicativeExpression	i * l / nr_fold
>7664	MultiplicativeExpression	l / nr_fold
>7665	Identifier	nr_fold
>7666	Identifier	l
>7667	Identifier	i
>7668	ArrayIndexing	fold_start [ i ]
>7669	Identifier	i
>7670	Identifier	fold_start
>7671	IncDecOp	 
>7672	IncDec	++
>7673	Identifier	i
>7674	Condition	 
>7675	RelationalExpression	i <= nr_fold
>7676	Identifier	nr_fold
>7677	Identifier	i
>7678	ForInit	 
>7679	AssignmentExpr	i = 0
>7680	PrimaryExpression	0
>7681	Identifier	i
>7682	ForStatement	for ( i = 0 ; i < l ; i ++ )
>7683	CompoundStatement	 
>7684	ExpressionStatement	 
>7685	CallExpression	swap ( perm [ i ] , perm [ j ] )
>7686	ArgumentList	perm [ i ]
>7687	Argument	perm [ j ]
>7688	ArrayIndexing	perm [ j ]
>7689	Identifier	j
>7690	Identifier	perm
>7691	Argument	perm [ i ]
>7692	ArrayIndexing	perm [ i ]
>7693	Identifier	i
>7694	Identifier	perm
>7695	Callee	swap
>7696	Identifier	swap
>7697	IdentifierDeclStatement	 
>7698	IdentifierDecl	j = i + rand ( ) % ( l - i )
>7699	AssignmentExpr	j = i + rand ( ) % ( l - i )
>7700	AdditiveExpression	i + rand ( ) % ( l - i )
>7701	MultiplicativeExpression	rand ( ) % ( l - i )
>7702	AdditiveExpression	l - i
>7703	Identifier	i
>7704	Identifier	l
>7705	CallExpression	rand ( )
>7706	ArgumentList	 
>7707	Callee	rand
>7708	Identifier	rand
>7709	Identifier	i
>7710	Identifier	j
>7711	Identifier	j
>7712	IdentifierDeclType	int
>7713	IncDecOp	 
>7714	IncDec	++
>7715	Identifier	i
>7716	Condition	 
>7717	RelationalExpression	i < l
>7718	Identifier	l
>7719	Identifier	i
>7720	ForInit	 
>7721	AssignmentExpr	i = 0
>7722	PrimaryExpression	0
>7723	Identifier	i
>7724	ForStatement	for ( i = 0 ; i < l ; i ++ )
>7725	ExpressionStatement	 
>7726	AssignmentExpr	perm [ i ] = i
>7727	Identifier	i
>7728	ArrayIndexing	perm [ i ]
>7729	Identifier	i
>7730	Identifier	perm
>7731	IncDecOp	 
>7732	IncDec	++
>7733	Identifier	i
>7734	Condition	 
>7735	RelationalExpression	i < l
>7736	Identifier	l
>7737	Identifier	i
>7738	ForInit	 
>7739	AssignmentExpr	i = 0
>7740	PrimaryExpression	0
>7741	Identifier	i
>7742	IdentifierDeclStatement	 
>7743	IdentifierDecl	* perm = Malloc ( int , l )
>7744	AssignmentExpr	* perm = Malloc ( int , l )
>7745	CallExpression	Malloc ( int , l )
>7746	ArgumentList	int
>7747	Argument	l
>7748	Identifier	l
>7749	Argument	int
>7750	Identifier	int
>7751	Callee	Malloc
>7752	Identifier	Malloc
>7753	Identifier	perm
>7754	Identifier	perm
>7755	IdentifierDeclType	int *
>7756	IdentifierDeclStatement	 
>7757	IdentifierDecl	l = prob -> l
>7758	AssignmentExpr	l = prob -> l
>7759	PtrMemberAccess	prob -> l
>7760	Identifier	l
>7761	Identifier	prob
>7762	Identifier	l
>7763	Identifier	l
>7764	IdentifierDeclType	int
>7765	IdentifierDeclStatement	 
>7766	IdentifierDecl	* fold_start = Malloc ( int , nr_fold + 1 )
>7767	AssignmentExpr	* fold_start = Malloc ( int , nr_fold + 1 )
>7768	CallExpression	Malloc ( int , nr_fold + 1 )
>7769	ArgumentList	int
>7770	Argument	nr_fold + 1
>7771	AdditiveExpression	nr_fold + 1
>7772	PrimaryExpression	1
>7773	Identifier	nr_fold
>7774	Argument	int
>7775	Identifier	int
>7776	Callee	Malloc
>7777	Identifier	Malloc
>7778	Identifier	fold_start
>7779	Identifier	fold_start
>7780	IdentifierDeclType	int *
>7781	IdentifierDeclStatement	 
>7782	IdentifierDecl	i
>7783	Identifier	i
>7784	IdentifierDeclType	int
<3=12,11,4
<4=8,5
<5=7,6
<8=10,9
<12=21,17,13
<13=14
<14=16,15
<17=18
<18=20,19
<21=22
<22=27,26,23
<23=25,24
<34=43,42,35
<35=39,36
<36=38,37
<39=41,40
<43=44
<44=45
<45=48,47,46
<48=49
<49=51,50
<57=66,65,58
<58=62,59
<59=61,60
<62=64,63
<66=67
<67=68
<68=71,70,69
<71=72
<72=74,73
<80=92,91,81
<81=88,85,82
<82=84,83
<85=87,86
<88=90,89
<92=240,224,95,93
<93=94
<95=216,101,96
<96=97
<97=98
<98=100,99
<101=102
<102=212,200,103
<103=104
<104=196,192,116,105
<105=106
<106=115,107
<107=114,108
<108=112,109
<109=110
<110=111
<112=113
<116=184,180,177,117
<117=118
<118=171,119
<119=160,120
<120=156,135,121
<121=122
<122=129,123
<123=124
<124=128,125
<125=127,126
<129=130
<130=134,131
<131=133,132
<135=150,140,136
<136=137
<137=139,138
<140=141
<141=149,142
<142=144,143
<144=148,145
<145=147,146
<150=151
<151=155,152
<152=154,153
<156=157
<157=159,158
<160=161
<161=170,162
<162=168,163
<163=164
<164=165
<165=167,166
<168=169
<171=172
<172=174,173
<174=176,175
<177=179,178
<180=181
<181=183,182
<184=185
<185=191,186
<186=188,187
<188=190,189
<192=193
<193=195,194
<196=197
<197=199,198
<200=201
<201=202
<202=211,203
<203=209,204
<204=205
<205=206
<206=208,207
<209=210
<212=213
<213=215,214
<216=217
<217=221,218
<218=220,219
<221=223,222
<224=237,234,231,228,225
<225=227,226
<228=230,229
<231=233,232
<234=236,235
<237=239,238
<240=257,249,241
<241=248,247,242
<242=246,243
<243=245,244
<249=256,255,250
<250=254,251
<251=253,252
<257=259,258
<280=298,297,281
<281=294,291,288,285,282
<282=284,283
<285=287,286
<288=290,289
<291=293,292
<294=296,295
<298=492,485,478,301,299
<299=300
<301=474,302
<302=303
<303=466,371,304
<304=305
<305=367,363,350,337,306
<306=333,329,326,307
<307=316,312,308
<308=309
<309=311,310
<312=313
<313=315,314
<316=317
<317=325,318
<318=322,319
<319=321,320
<322=324,323
<326=328,327
<329=330
<330=332,331
<333=334
<334=336,335
<337=346,338
<338=339
<339=345,340
<340=342,341
<342=344,343
<346=347
<347=349,348
<350=359,351
<351=352
<352=358,353
<353=355,354
<355=357,356
<359=360
<360=362,361
<363=364
<364=366,365
<367=368
<368=370,369
<371=460,390,372
<372=386,383,373
<373=374
<374=382,375
<375=379,376
<376=378,377
<379=381,380
<383=385,384
<386=387
<387=389,388
<390=456,452,449,391
<391=392
<392=448,393
<393=441,394
<394=430,395
<395=419,396
<396=408,397
<397=403,398
<398=402,399
<399=401,400
<403=407,404
<404=406,405
<408=414,409
<409=413,410
<410=412,411
<414=418,415
<415=417,416
<419=425,420
<420=424,421
<421=423,422
<425=429,426
<426=428,427
<430=436,431
<431=435,432
<432=434,433
<436=440,437
<437=439,438
<441=445,442
<442=444,443
<445=447,446
<449=451,450
<452=453
<453=455,454
<456=457
<457=459,458
<460=461
<461=465,462
<462=464,463
<466=467
<467=471,468
<468=470,469
<471=473,472
<474=475
<475=477,476
<478=482,479
<479=481,480
<482=484,483
<485=486
<486=491,490,487
<487=489,488
<492=520,517,509,501,493
<493=500,499,494
<494=498,495
<495=497,496
<501=508,507,502
<502=506,503
<503=505,504
<509=516,515,510
<510=514,511
<511=513,512
<517=519,518
<520=522,521
<547=568,567,548
<548=564,561,558,555,552,549
<549=551,550
<552=554,553
<555=557,556
<558=560,559
<561=563,562
<564=566,565
<568=751,750,741,571,569
<569=570
<571=733,572
<572=573
<573=725,635,574
<574=575
<575=621,607,576
<576=603,599,596,577
<577=586,582,578
<578=579
<579=581,580
<582=583
<583=585,584
<586=587
<587=593,588
<588=592,589
<589=591,590
<593=595,594
<596=598,597
<599=600
<600=602,601
<603=604
<604=606,605
<607=608
<608=620,609
<609=616,615,610
<610=612,611
<612=614,613
<616=617
<617=619,618
<621=622
<622=634,623
<623=630,629,624
<624=626,625
<626=628,627
<630=631
<631=633,632
<635=719,654,636
<636=650,647,637
<637=638
<638=644,639
<639=643,640
<640=642,641
<644=646,645
<647=649,648
<650=651
<651=653,652
<654=715,711,708,655
<655=698,684,670,656
<656=657
<657=665,658
<658=664,659
<659=663,660
<660=662,661
<665=669,666
<666=668,667
<670=671
<671=679,672
<672=678,673
<673=677,674
<674=676,675
<679=683,680
<680=682,681
<684=685
<685=693,686
<686=692,687
<687=691,688
<688=690,689
<693=697,694
<694=696,695
<698=699
<699=705,700
<700=704,701
<701=703,702
<705=707,706
<708=710,709
<711=712
<712=714,713
<715=716
<716=718,717
<719=720
<720=724,721
<721=723,722
<725=726
<726=730,727
<727=729,728
<730=732,731
<733=734
<734=738,735
<735=737,736
<738=740,739
<741=742
<742=749,748,743
<743=747,744
<744=746,745
<751=785,782,779,776,768,760,752
<752=759,758,753
<753=757,754
<754=756,755
<760=767,766,761
<761=765,762
<762=764,763
<768=775,774,769
<769=773,770
<770=772,771
<776=778,777
<779=781,780
<782=784,783
<785=787,786
<814=829,828,815
<815=825,822,819,816
<816=818,817
<819=821,820
<822=824,823
<825=827,826
<829=990,981,832,830
<830=831
<832=973,833
<833=834
<834=969,865,835
<835=836
<836=859,837
<837=855,851,848,838
<838=839
<839=845,840
<840=844,841
<841=843,842
<845=847,846
<848=850,849
<851=852
<852=854,853
<855=856
<856=858,857
<859=860
<860=864,861
<861=863,862
<865=963,884,866
<866=880,877,867
<867=868
<868=874,869
<869=873,870
<870=872,871
<874=876,875
<877=879,878
<880=881
<881=883,882
<884=959,955,952,885
<885=942,928,914,900,886
<886=887
<887=895,888
<888=894,889
<889=893,890
<890=892,891
<895=899,896
<896=898,897
<900=901
<901=909,902
<902=908,903
<903=907,904
<904=906,905
<909=913,910
<910=912,911
<914=915
<915=923,916
<916=922,917
<917=921,918
<918=920,919
<923=927,924
<924=926,925
<928=929
<929=937,930
<930=936,931
<931=935,932
<932=934,933
<937=941,938
<938=940,939
<942=943
<943=949,944
<944=948,945
<945=947,946
<949=951,950
<952=954,953
<955=956
<956=958,957
<959=960
<960=962,961
<963=964
<964=968,965
<965=967,966
<969=970
<970=972,971
<973=974
<974=978,975
<975=977,976
<978=980,979
<981=982
<982=989,988,983
<983=987,984
<984=986,985
<990=1013,1010,1007,999,991
<991=998,997,992
<992=996,993
<993=995,994
<999=1006,1005,1000
<1000=1004,1001
<1001=1003,1002
<1007=1009,1008
<1010=1012,1011
<1013=1015,1014
<1034=1045,1035
<1035=1042,1039,1036
<1036=1038,1037
<1039=1041,1040
<1042=1044,1043
<1045=1068,1067,1066,1065,1064,1063,1062,1061,1060,1058,1052,1046
<1046=1047
<1047=1049,1048
<1049=1051,1050
<1052=1053
<1053=1055,1054
<1055=1057,1056
<1058=1059
<1079=1081,1080
<1085=1091,1090,1086
<1086=1087
<1087=1089,1088
<1091=1761,1742,1730,1723,1710,1691,1672,1665,1658,1651,1644,1626,1615,1604,1587,1580,1573,1564,1560,1112,1111,1110,1109,1107,1106,1105,1104,1102,1101,1100,1099,1097,1096,1095,1094,1092
<1092=1093
<1097=1098
<1102=1103
<1107=1108
<1112=1554,1113
<1113=1539,1524,1499,1476,1447,1436,1430,1413,1397,1360,1244,1177,1170,1149,1114
<1114=1117,1115
<1115=1116
<1117=1118
<1118=1134,1119
<1119=1128,1120
<1120=1127,1121
<1121=1125,1122
<1122=1123
<1123=1124
<1125=1126
<1128=1132,1129
<1129=1130
<1130=1131
<1132=1133
<1134=1143,1135
<1135=1142,1136
<1136=1140,1137
<1137=1138
<1138=1139
<1140=1141
<1143=1147,1144
<1144=1145
<1145=1146
<1147=1148
<1149=1152,1150
<1150=1151
<1152=1153
<1153=1162,1154
<1154=1156,1155
<1156=1160,1157
<1157=1158
<1158=1159
<1160=1161
<1162=1164,1163
<1164=1168,1165
<1165=1166
<1166=1167
<1168=1169
<1170=1173,1171
<1171=1172
<1173=1174
<1174=1176,1175
<1177=1238,1178
<1178=1234,1219,1215,1204,1187,1179
<1179=1181,1180
<1181=1182
<1182=1186,1183
<1183=1185,1184
<1187=1188
<1188=1203,1189
<1189=1201,1190
<1190=1197,1195,1191
<1191=1192
<1192=1194,1193
<1195=1196
<1197=1198
<1198=1200,1199
<1201=1202
<1204=1205
<1205=1211,1206
<1206=1209,1207
<1207=1208
<1209=1210
<1211=1212
<1212=1214,1213
<1215=1216
<1216=1218,1217
<1219=1220
<1220=1232,1221
<1221=1230,1228,1222
<1222=1223
<1223=1225,1224
<1225=1227,1226
<1228=1229
<1230=1231
<1232=1233
<1234=1235
<1235=1237,1236
<1238=1239
<1239=1243,1240
<1240=1242,1241
<1244=1354,1332,1245
<1245=1246
<1246=1326,1302,1247
<1247=1248
<1248=1296,1272,1249
<1249=1250
<1250=1251
<1251=1271,1252
<1252=1269,1253
<1253=1267,1254
<1254=1255
<1255=1265,1256
<1256=1261,1257
<1257=1258
<1258=1260,1259
<1261=1262
<1262=1264,1263
<1265=1266
<1267=1268
<1269=1270
<1272=1273
<1273=1295,1274
<1274=1293,1275
<1275=1289,1276
<1276=1277
<1277=1287,1278
<1278=1283,1279
<1279=1280
<1280=1282,1281
<1283=1284
<1284=1286,1285
<1287=1288
<1289=1290
<1290=1292,1291
<1293=1294
<1296=1297
<1297=1301,1298
<1298=1300,1299
<1302=1303
<1303=1325,1304
<1304=1323,1305
<1305=1319,1306
<1306=1307
<1307=1317,1308
<1308=1313,1309
<1309=1310
<1310=1312,1311
<1313=1314
<1314=1316,1315
<1317=1318
<1319=1320
<1320=1322,1321
<1323=1324
<1326=1327
<1327=1331,1328
<1328=1330,1329
<1332=1333
<1333=1353,1334
<1334=1351,1335
<1335=1340,1336
<1336=1337
<1337=1339,1338
<1340=1341
<1341=1343,1342
<1343=1349,1344
<1344=1347,1345
<1345=1346
<1347=1348
<1349=1350
<1351=1352
<1354=1355
<1355=1359,1356
<1356=1358,1357
<1360=1389,1385,1361
<1361=1362
<1362=1363
<1363=1384,1364
<1364=1382,1365
<1365=1380,1366
<1366=1367
<1367=1375,1368
<1368=1374,1369
<1369=1373,1370
<1370=1372,1371
<1375=1379,1376
<1376=1378,1377
<1380=1381
<1382=1383
<1385=1386
<1386=1388,1387
<1389=1390
<1390=1392,1391
<1392=1396,1393
<1393=1395,1394
<1397=1409,1398
<1398=1399
<1399=1408,1400
<1400=1406,1401
<1401=1404,1402
<1402=1403
<1404=1405
<1406=1407
<1409=1410
<1410=1412,1411
<1413=1414
<1414=1429,1415
<1415=1427,1416
<1416=1423,1421,1417
<1417=1418
<1418=1420,1419
<1421=1422
<1423=1424
<1424=1426,1425
<1427=1428
<1430=1431
<1431=1435,1432
<1432=1434,1433
<1436=1437
<1437=1446,1438
<1438=1442,1439
<1439=1440
<1440=1441
<1442=1443
<1443=1445,1444
<1447=1448
<1448=1475,1449
<1449=1472,1450
<1450=1471,1451
<1451=1469,1452
<1452=1465,1463,1459,1457,1453
<1453=1454
<1454=1456,1455
<1457=1458
<1459=1460
<1460=1462,1461
<1463=1464
<1465=1466
<1466=1468,1467
<1469=1470
<1472=1474,1473
<1476=1477
<1477=1498,1478
<1478=1496,1479
<1479=1492,1490,1486,1484,1480
<1480=1481
<1481=1483,1482
<1484=1485
<1486=1487
<1487=1489,1488
<1490=1491
<1492=1493
<1493=1495,1494
<1496=1497
<1499=1500
<1500=1522,1501
<1501=1518,1514,1512,1508,1506,1502
<1502=1503
<1503=1505,1504
<1506=1507
<1508=1509
<1509=1511,1510
<1512=1513
<1514=1515
<1515=1517,1516
<1518=1519
<1519=1521,1520
<1522=1523
<1524=1525
<1525=1537,1526
<1526=1535,1533,1527
<1527=1528
<1528=1530,1529
<1530=1532,1531
<1533=1534
<1535=1536
<1537=1538
<1539=1540
<1540=1553,1541
<1541=1551,1542
<1542=1549,1547,1545,1543
<1543=1544
<1545=1546
<1547=1548
<1549=1550
<1551=1552
<1554=1555
<1555=1557,1556
<1557=1559,1558
<1560=1561
<1561=1563,1562
<1564=1569,1565
<1565=1566
<1566=1568,1567
<1569=1570
<1570=1572,1571
<1573=1574
<1574=1579,1578,1575
<1575=1577,1576
<1580=1581
<1581=1586,1585,1582
<1582=1584,1583
<1587=1588
<1588=1603,1589
<1589=1601,1590
<1590=1597,1595,1591
<1591=1592
<1592=1594,1593
<1595=1596
<1597=1598
<1598=1600,1599
<1601=1602
<1604=1605
<1605=1611,1606
<1606=1609,1607
<1607=1608
<1609=1610
<1611=1612
<1612=1614,1613
<1615=1616
<1616=1625,1617
<1617=1621,1618
<1618=1619
<1619=1620
<1621=1622
<1622=1624,1623
<1626=1640,1636,1633,1627
<1627=1628
<1628=1630,1629
<1630=1632,1631
<1633=1635,1634
<1636=1637
<1637=1639,1638
<1640=1641
<1641=1643,1642
<1644=1645
<1645=1650,1649,1646
<1646=1648,1647
<1651=1652
<1652=1657,1656,1653
<1653=1655,1654
<1658=1659
<1659=1664,1663,1660
<1660=1662,1661
<1665=1666
<1666=1671,1670,1667
<1667=1669,1668
<1672=1685,1679,1673
<1673=1678,1677,1674
<1674=1676,1675
<1679=1684,1683,1680
<1680=1682,1681
<1685=1690,1689,1686
<1686=1688,1687
<1691=1707,1704,1701,1698,1695,1692
<1692=1694,1693
<1695=1697,1696
<1698=1700,1699
<1701=1703,1702
<1704=1706,1705
<1707=1709,1708
<1710=1720,1717,1711
<1711=1716,1715,1712
<1712=1714,1713
<1717=1719,1718
<1720=1722,1721
<1723=1727,1724
<1724=1726,1725
<1727=1729,1728
<1730=1731
<1731=1741,1740,1732
<1732=1739,1733
<1733=1735,1734
<1735=1736
<1736=1738,1737
<1742=1755,1749,1743
<1743=1748,1747,1744
<1744=1746,1745
<1749=1754,1753,1750
<1750=1752,1751
<1755=1760,1759,1756
<1756=1758,1757
<1761=1774,1768,1762
<1762=1767,1766,1763
<1763=1765,1764
<1768=1773,1772,1769
<1769=1771,1770
<1774=1779,1778,1775
<1775=1777,1776
<1828=1843,1842,1829
<1829=1839,1836,1833,1830
<1830=1832,1831
<1833=1835,1834
<1836=1838,1837
<1839=1841,1840
<1843=2425,2413,2406,2399,2392,2376,2339,2320,2313,2290,1856,1855,1854,1853,1851,1850,1849,1848,1846,1844
<1844=1845
<1846=1847
<1851=1852
<1856=2288,1857
<1857=2269,2265,2254,2229,2204,1966,1960,1935,1912,1906,1887,1862,1858
<1858=1859
<1859=1861,1860
<1862=1863
<1863=1885,1864
<1864=1881,1877,1875,1871,1869,1865
<1865=1866
<1866=1868,1867
<1869=1870
<1871=1872
<1872=1874,1873
<1875=1876
<1877=1878
<1878=1880,1879
<1881=1882
<1882=1884,1883
<1885=1886
<1887=1888
<1888=1904,1889
<1889=1900,1896,1894,1890
<1890=1891
<1891=1893,1892
<1894=1895
<1896=1897
<1897=1899,1898
<1900=1901
<1901=1903,1902
<1904=1905
<1906=1907
<1907=1911,1908
<1908=1910,1909
<1912=1913
<1913=1934,1914
<1914=1932,1915
<1915=1928,1926,1922,1920,1916
<1916=1917
<1917=1919,1918
<1920=1921
<1922=1923
<1923=1925,1924
<1926=1927
<1928=1929
<1929=1931,1930
<1932=1933
<1935=1936
<1936=1958,1937
<1937=1954,1950,1948,1944,1942,1938
<1938=1939
<1939=1941,1940
<1942=1943
<1944=1945
<1945=1947,1946
<1948=1949
<1950=1951
<1951=1953,1952
<1954=1955
<1955=1957,1956
<1958=1959
<1960=1961
<1961=1965,1962
<1962=1964,1963
<1966=2187,1967
<1967=2181,2156,2130,2104,2078,2069,2049,2025,2000,1994,1969,1968
<1969=1970
<1970=1992,1971
<1971=1988,1984,1982,1978,1976,1972
<1972=1973
<1973=1975,1974
<1976=1977
<1978=1979
<1979=1981,1980
<1982=1983
<1984=1985
<1985=1987,1986
<1988=1989
<1989=1991,1990
<1992=1993
<1994=1995
<1995=1999,1996
<1996=1998,1997
<2000=2001
<2001=2023,2002
<2002=2019,2015,2013,2009,2007,2003
<2003=2004
<2004=2006,2005
<2007=2008
<2009=2010
<2010=2012,2011
<2013=2014
<2015=2016
<2016=2018,2017
<2019=2020
<2020=2022,2021
<2023=2024
<2025=2045,2035,2026
<2026=2027
<2027=2028
<2028=2034,2029
<2029=2031,2030
<2031=2033,2032
<2035=2036
<2036=2044,2037
<2037=2041,2038
<2038=2040,2039
<2041=2043,2042
<2045=2046
<2046=2048,2047
<2049=2050
<2050=2068,2067,2051
<2051=2066,2052
<2052=2064,2053
<2053=2054
<2054=2055
<2055=2061,2056
<2056=2060,2057
<2057=2059,2058
<2061=2063,2062
<2064=2065
<2069=2070
<2070=2077,2076,2071
<2071=2075,2072
<2072=2074,2073
<2078=2079
<2079=2103,2102,2080
<2080=2101,2081
<2081=2099,2082
<2082=2095,2093,2089,2087,2083
<2083=2084
<2084=2086,2085
<2087=2088
<2089=2090
<2090=2092,2091
<2093=2094
<2095=2096
<2096=2098,2097
<2099=2100
<2104=2105
<2105=2129,2128,2106
<2106=2127,2107
<2107=2125,2108
<2108=2121,2119,2115,2113,2109
<2109=2110
<2110=2112,2111
<2113=2114
<2115=2116
<2116=2118,2117
<2119=2120
<2121=2122
<2122=2124,2123
<2125=2126
<2130=2131
<2131=2155,2154,2132
<2132=2153,2133
<2133=2151,2134
<2134=2147,2145,2141,2139,2135
<2135=2136
<2136=2138,2137
<2139=2140
<2141=2142
<2142=2144,2143
<2145=2146
<2147=2148
<2148=2150,2149
<2151=2152
<2156=2157
<2157=2179,2158
<2158=2175,2171,2169,2165,2163,2159
<2159=2160
<2160=2162,2161
<2163=2164
<2165=2166
<2166=2168,2167
<2169=2170
<2171=2172
<2172=2174,2173
<2175=2176
<2176=2178,2177
<2179=2180
<2181=2182
<2182=2186,2183
<2183=2185,2184
<2187=2188
<2188=2190,2189
<2190=2202,2191
<2191=2198,2196,2192
<2192=2193
<2193=2195,2194
<2196=2197
<2198=2199
<2199=2201,2200
<2202=2203
<2204=2205
<2205=2227,2206
<2206=2223,2219,2217,2213,2211,2207
<2207=2208
<2208=2210,2209
<2211=2212
<2213=2214
<2214=2216,2215
<2217=2218
<2219=2220
<2220=2222,2221
<2223=2224
<2224=2226,2225
<2227=2228
<2229=2230
<2230=2253,2231
<2231=2252,2232
<2232=2250,2233
<2233=2246,2244,2240,2238,2234
<2234=2235
<2235=2237,2236
<2238=2239
<2240=2241
<2241=2243,2242
<2244=2245
<2246=2247
<2247=2249,2248
<2250=2251
<2254=2255
<2255=2261,2256
<2256=2259,2257
<2257=2258
<2259=2260
<2261=2262
<2262=2264,2263
<2265=2266
<2266=2268,2267
<2269=2271,2270
<2271=2272
<2272=2274,2273
<2274=2286,2275
<2275=2282,2280,2276
<2276=2277
<2277=2279,2278
<2280=2281
<2282=2283
<2283=2285,2284
<2286=2287
<2288=2289
<2290=2291
<2291=2312,2292
<2292=2310,2293
<2293=2306,2304,2300,2298,2294
<2294=2295
<2295=2297,2296
<2298=2299
<2300=2301
<2301=2303,2302
<2304=2305
<2306=2307
<2307=2309,2308
<2310=2311
<2313=2314
<2314=2319,2318,2315
<2315=2317,2316
<2320=2321
<2321=2338,2322
<2322=2337,2323
<2323=2335,2324
<2324=2331,2329,2325
<2325=2326
<2326=2328,2327
<2329=2330
<2331=2332
<2332=2334,2333
<2335=2336
<2339=2372,2368,2365,2340
<2340=2359,2349,2341
<2341=2342
<2342=2346,2343
<2343=2345,2344
<2346=2348,2347
<2349=2350
<2350=2356,2351
<2351=2355,2352
<2352=2354,2353
<2356=2358,2357
<2359=2360
<2360=2362,2361
<2362=2364,2363
<2365=2367,2366
<2368=2369
<2369=2371,2370
<2372=2373
<2373=2375,2374
<2376=2389,2386,2383,2380,2377
<2377=2379,2378
<2380=2382,2381
<2383=2385,2384
<2386=2388,2387
<2389=2391,2390
<2392=2393
<2393=2398,2397,2394
<2394=2396,2395
<2399=2400
<2400=2405,2404,2401
<2401=2403,2402
<2406=2407
<2407=2412,2411,2408
<2408=2410,2409
<2413=2414
<2414=2424,2423,2415
<2415=2422,2416
<2416=2418,2417
<2418=2419
<2419=2421,2420
<2425=2432,2426
<2426=2431,2430,2427
<2427=2429,2428
<2432=2434,2433
<2475=2484,2483,2476
<2476=2480,2477
<2477=2479,2478
<2480=2482,2481
<2484=2526,2487,2485
<2485=2486
<2487=2518,2514,2511,2488
<2488=2500,2489
<2489=2490
<2490=2499,2491
<2491=2497,2492
<2492=2493
<2493=2494
<2494=2496,2495
<2497=2498
<2500=2501
<2501=2503,2502
<2503=2509,2504
<2504=2505
<2505=2506
<2506=2508,2507
<2509=2510
<2511=2513,2512
<2514=2515
<2515=2517,2516
<2518=2519
<2519=2520
<2520=2525,2524,2521
<2521=2523,2522
<2526=2527
<2527=2539,2538,2528
<2528=2537,2529
<2529=2535,2530
<2530=2531
<2531=2532
<2532=2534,2533
<2535=2536
<2551=2562,2552
<2552=2559,2556,2553
<2553=2555,2554
<2556=2558,2557
<2559=2561,2560
<2562=2614,2605,2596,2563
<2563=2592,2588,2585,2564
<2564=2565
<2565=2579,2573,2566
<2566=2567
<2567=2568
<2568=2570,2569
<2570=2572,2571
<2573=2574
<2574=2576,2575
<2576=2578,2577
<2579=2580
<2580=2582,2581
<2582=2584,2583
<2585=2587,2586
<2588=2589
<2589=2591,2590
<2592=2593
<2593=2595,2594
<2596=2597
<2597=2604,2603,2598
<2598=2602,2599
<2599=2601,2600
<2605=2606
<2606=2613,2612,2607
<2607=2611,2608
<2608=2610,2609
<2614=2615
<2615=2617,2616
<2635=2637,2636
<2637=2657,2656,2655,2653,2652,2651,2650,2648,2647,2646,2645,2643,2642,2641,2640,2638
<2638=2639
<2643=2644
<2648=2649
<2653=2654
<2661=2667,2666,2662
<2662=2663
<2663=2665,2664
<2667=2796,2789,2780,2771,2762,2753,2702,2696,2674,2670,2668
<2668=2669
<2670=2671
<2671=2673,2672
<2674=2692,2688,2685,2675
<2675=2676
<2676=2684,2677
<2677=2681,2678
<2678=2680,2679
<2681=2683,2682
<2685=2687,2686
<2688=2689
<2689=2691,2690
<2692=2693
<2693=2695,2694
<2696=2697
<2697=2701,2698
<2698=2700,2699
<2702=2749,2745,2742,2703
<2703=2730,2719,2704
<2704=2715,2705
<2705=2706
<2706=2714,2707
<2707=2711,2708
<2708=2710,2709
<2711=2713,2712
<2715=2716
<2716=2718,2717
<2719=2720
<2720=2729,2728,2721
<2721=2727,2722
<2722=2724,2723
<2724=2726,2725
<2730=2731
<2731=2739,2732
<2732=2736,2733
<2733=2735,2734
<2736=2738,2737
<2739=2741,2740
<2742=2744,2743
<2745=2746
<2746=2748,2747
<2749=2750
<2750=2752,2751
<2753=2754
<2754=2760,2755
<2755=2758,2756
<2756=2757
<2758=2759
<2760=2761
<2762=2763
<2763=2770,2769,2764
<2764=2768,2765
<2765=2767,2766
<2771=2772
<2772=2779,2778,2773
<2773=2777,2774
<2774=2776,2775
<2780=2781
<2781=2788,2787,2782
<2782=2786,2783
<2783=2785,2784
<2789=2790
<2790=2795,2794,2791
<2791=2793,2792
<2796=2797
<2797=2799,2798
<2822=2831,2830,2823
<2823=2827,2824
<2824=2826,2825
<2827=2829,2828
<2831=2946,2937,2928,2919,2915,2867,2858,2832
<2832=2854,2850,2847,2833
<2833=2834
<2834=2844,2835
<2835=2841,2836
<2836=2840,2837
<2837=2839,2838
<2841=2843,2842
<2844=2846,2845
<2847=2849,2848
<2850=2851
<2851=2853,2852
<2854=2855
<2855=2857,2856
<2858=2859
<2859=2865,2860
<2860=2863,2861
<2861=2862
<2863=2864
<2865=2866
<2867=2911,2907,2904,2868
<2868=2898,2869
<2869=2880,2874,2870
<2870=2871
<2871=2873,2872
<2874=2875
<2875=2877,2876
<2877=2879,2878
<2880=2881
<2881=2895,2882
<2882=2892,2883
<2883=2889,2884
<2884=2886,2885
<2886=2888,2887
<2889=2891,2890
<2892=2894,2893
<2895=2897,2896
<2898=2899
<2899=2901,2900
<2901=2903,2902
<2904=2906,2905
<2907=2908
<2908=2910,2909
<2911=2912
<2912=2914,2913
<2915=2916
<2916=2918,2917
<2919=2920
<2920=2927,2926,2921
<2921=2925,2922
<2922=2924,2923
<2928=2929
<2929=2936,2935,2930
<2930=2934,2931
<2931=2933,2932
<2937=2938
<2938=2945,2944,2939
<2939=2943,2940
<2940=2942,2941
<2946=2947
<2947=2949,2948
<2976=2985,2984,2977
<2977=2981,2978
<2978=2980,2979
<2981=2983,2982
<2985=3086,3077,3068,3061,3052,3026,3017,2991,2990,2989,2988,2986
<2986=2987
<2991=3013,3009,3006,2992
<2992=2993
<2993=3003,2994
<2994=3000,2995
<2995=2999,2996
<2996=2998,2997
<3000=3002,3001
<3003=3005,3004
<3006=3008,3007
<3009=3010
<3010=3012,3011
<3013=3014
<3014=3016,3015
<3017=3018
<3018=3024,3019
<3019=3022,3020
<3020=3021
<3022=3023
<3024=3025
<3026=3048,3044,3041,3027
<3027=3028
<3028=3038,3029
<3029=3033,3030
<3030=3032,3031
<3033=3037,3034
<3034=3036,3035
<3038=3040,3039
<3041=3043,3042
<3044=3045
<3045=3047,3046
<3048=3049
<3049=3051,3050
<3052=3053
<3053=3059,3054
<3054=3057,3055
<3055=3056
<3057=3058
<3059=3060
<3061=3062
<3062=3067,3066,3063
<3063=3065,3064
<3068=3069
<3069=3076,3075,3070
<3070=3074,3071
<3071=3073,3072
<3077=3078
<3078=3085,3084,3079
<3079=3083,3080
<3080=3082,3081
<3086=3087
<3087=3089,3088
<3114=3117,3116,3115
<3117=3118
<3118=3119
<3119=3121,3120
<3128=3137,3136,3129
<3129=3133,3130
<3130=3132,3131
<3133=3135,3134
<3137=3214,3205,3196,3138
<3138=3192,3188,3185,3139
<3139=3176,3170,3140
<3140=3162,3141
<3141=3146,3142
<3142=3143
<3143=3145,3144
<3146=3147
<3147=3159,3148
<3148=3152,3149
<3149=3151,3150
<3152=3158,3153
<3153=3155,3154
<3155=3157,3156
<3159=3161,3160
<3162=3163
<3163=3167,3164
<3164=3166,3165
<3167=3169,3168
<3170=3171
<3171=3173,3172
<3173=3175,3174
<3176=3177
<3177=3184,3183,3178
<3178=3182,3179
<3179=3181,3180
<3185=3187,3186
<3188=3189
<3189=3191,3190
<3192=3193
<3193=3195,3194
<3196=3197
<3197=3204,3203,3198
<3198=3202,3199
<3199=3201,3200
<3205=3206
<3206=3213,3212,3207
<3207=3211,3208
<3208=3210,3209
<3214=3215
<3215=3217,3216
<3240=3249,3248,3241
<3241=3245,3242
<3242=3244,3243
<3245=3247,3246
<3249=3319,3310,3250
<3250=3306,3302,3299,3251
<3251=3288,3282,3252
<3252=3274,3253
<3253=3258,3254
<3254=3255
<3255=3257,3256
<3258=3259
<3259=3271,3260
<3260=3264,3261
<3261=3263,3262
<3264=3270,3265
<3265=3267,3266
<3267=3269,3268
<3271=3273,3272
<3274=3275
<3275=3279,3276
<3276=3278,3277
<3279=3281,3280
<3282=3283
<3283=3285,3284
<3285=3287,3286
<3288=3289
<3289=3298,3297,3290
<3290=3296,3291
<3291=3295,3292
<3292=3294,3293
<3299=3301,3300
<3302=3303
<3303=3305,3304
<3306=3307
<3307=3309,3308
<3310=3311
<3311=3318,3317,3312
<3312=3316,3313
<3313=3315,3314
<3319=3320
<3320=3322,3321
<3348=3357,3356,3349
<3349=3353,3350
<3350=3352,3351
<3353=3355,3354
<3357=3448,3439,3430,3412,3358
<3358=3408,3404,3401,3359
<3359=3390,3360
<3360=3382,3361
<3361=3366,3362
<3362=3363
<3363=3365,3364
<3366=3367
<3367=3375,3368
<3368=3372,3369
<3369=3371,3370
<3372=3374,3373
<3375=3381,3376
<3376=3378,3377
<3378=3380,3379
<3382=3383
<3383=3387,3384
<3384=3386,3385
<3387=3389,3388
<3390=3391
<3391=3400,3399,3392
<3392=3398,3393
<3393=3397,3394
<3394=3396,3395
<3401=3403,3402
<3404=3405
<3405=3407,3406
<3408=3409
<3409=3411,3410
<3412=3426,3422,3419,3413
<3413=3414
<3414=3416,3415
<3416=3418,3417
<3419=3421,3420
<3422=3423
<3423=3425,3424
<3426=3427
<3427=3429,3428
<3430=3431
<3431=3438,3437,3432
<3432=3436,3433
<3433=3435,3434
<3439=3440
<3440=3447,3446,3441
<3441=3445,3442
<3442=3444,3443
<3448=3449
<3449=3451,3450
<3492=3503,3493
<3493=3500,3497,3494
<3494=3496,3495
<3497=3499,3498
<3500=3502,3501
<3503=3561,3552,3546,3542,3538,3534,3504
<3504=3526,3522,3519,3505
<3505=3506
<3506=3516,3507
<3507=3510,3509,3508
<3510=3511
<3511=3513,3512
<3513=3515,3514
<3516=3518,3517
<3519=3521,3520
<3522=3523
<3523=3525,3524
<3526=3527
<3527=3528
<3528=3533,3532,3529
<3529=3531,3530
<3534=3535
<3535=3537,3536
<3538=3539
<3539=3541,3540
<3542=3543
<3543=3545,3544
<3546=3547
<3547=3549,3548
<3549=3551,3550
<3552=3553
<3553=3560,3559,3554
<3554=3558,3555
<3555=3557,3556
<3561=3562
<3562=3569,3568,3563
<3563=3567,3564
<3564=3566,3565
<3591=3593,3592
<3593=3608,3607,3606,3604,3603,3602,3601,3599,3598,3597,3596,3594
<3594=3595
<3599=3600
<3604=3605
<3612=3618,3617,3613
<3613=3614
<3614=3616,3615
<3618=3775,3766,3757,3748,3739,3657,3651,3625,3621,3619
<3619=3620
<3621=3622
<3622=3624,3623
<3625=3643,3639,3636,3626
<3626=3627
<3627=3635,3628
<3628=3632,3629
<3629=3631,3630
<3632=3634,3633
<3636=3638,3637
<3639=3640
<3640=3642,3641
<3643=3644
<3644=3645
<3645=3650,3649,3646
<3646=3648,3647
<3651=3652
<3652=3656,3653
<3653=3655,3654
<3657=3731,3727,3724,3658
<3658=3711,3659
<3659=3707,3685,3660
<3660=3661
<3661=3662
<3662=3684,3663
<3663=3681,3664
<3664=3678,3665
<3665=3676,3666
<3666=3667
<3667=3668
<3668=3675,3669
<3669=3673,3670
<3670=3671
<3671=3672
<3673=3674
<3676=3677
<3678=3680,3679
<3681=3683,3682
<3685=3686
<3686=3706,3687
<3687=3703,3688
<3688=3701,3689
<3689=3690
<3690=3691
<3691=3700,3692
<3692=3698,3693
<3693=3694
<3694=3695
<3695=3697,3696
<3698=3699
<3701=3702
<3703=3705,3704
<3707=3708
<3708=3710,3709
<3711=3712
<3712=3723,3722,3713
<3713=3721,3714
<3714=3718,3715
<3715=3717,3716
<3718=3720,3719
<3724=3726,3725
<3727=3728
<3728=3730,3729
<3731=3732
<3732=3733
<3733=3738,3737,3734
<3734=3736,3735
<3739=3740
<3740=3746,3741
<3741=3744,3742
<3742=3743
<3744=3745
<3746=3747
<3748=3749
<3749=3756,3755,3750
<3750=3754,3751
<3751=3753,3752
<3757=3758
<3758=3765,3764,3759
<3759=3763,3760
<3760=3762,3761
<3766=3767
<3767=3774,3773,3768
<3768=3772,3769
<3769=3771,3770
<3775=3776
<3776=3781,3780,3777
<3777=3779,3778
<3806=3815,3814,3807
<3807=3811,3808
<3808=3810,3809
<3811=3813,3812
<3815=3943,3934,3925,3853,3844,3816
<3816=3836,3832,3829,3817
<3817=3818
<3818=3826,3819
<3819=3823,3820
<3820=3822,3821
<3823=3825,3824
<3826=3828,3827
<3829=3831,3830
<3832=3833
<3833=3835,3834
<3836=3837
<3837=3838
<3838=3843,3842,3839
<3839=3841,3840
<3844=3845
<3845=3851,3846
<3846=3849,3847
<3847=3848
<3849=3850
<3851=3852
<3853=3917,3913,3910,3854
<3854=3887,3873,3855
<3855=3856
<3856=3870,3857
<3857=3867,3858
<3858=3862,3859
<3859=3861,3860
<3862=3864,3863
<3864=3866,3865
<3867=3869,3868
<3870=3872,3871
<3873=3874
<3874=3884,3875
<3875=3881,3876
<3876=3880,3877
<3877=3879,3878
<3881=3883,3882
<3884=3886,3885
<3887=3888
<3888=3907,3889
<3889=3906,3890
<3890=3905,3891
<3891=3903,3892
<3892=3893
<3893=3894
<3894=3898,3895
<3895=3897,3896
<3898=3902,3899
<3899=3901,3900
<3903=3904
<3907=3909,3908
<3910=3912,3911
<3913=3914
<3914=3916,3915
<3917=3918
<3918=3919
<3919=3924,3923,3920
<3920=3922,3921
<3925=3926
<3926=3933,3932,3927
<3927=3931,3928
<3928=3930,3929
<3934=3935
<3935=3942,3941,3936
<3936=3940,3937
<3937=3939,3938
<3943=3944
<3944=3951,3950,3945
<3945=3949,3946
<3946=3948,3947
<3977=3986,3985,3978
<3978=3982,3979
<3979=3981,3980
<3982=3984,3983
<3986=4086,4077,4070,4061,4029,4020,3992,3991,3990,3989,3987
<3987=3988
<3992=4012,4008,4005,3993
<3993=3994
<3994=4002,3995
<3995=3999,3996
<3996=3998,3997
<3999=4001,4000
<4002=4004,4003
<4005=4007,4006
<4008=4009
<4009=4011,4010
<4012=4013
<4013=4014
<4014=4019,4018,4015
<4015=4017,4016
<4020=4021
<4021=4027,4022
<4022=4025,4023
<4023=4024
<4025=4026
<4027=4028
<4029=4053,4049,4046,4030
<4030=4031
<4031=4043,4032
<4032=4040,4033
<4033=4037,4034
<4034=4036,4035
<4037=4039,4038
<4040=4042,4041
<4043=4045,4044
<4046=4048,4047
<4049=4050
<4050=4052,4051
<4053=4054
<4054=4055
<4055=4060,4059,4056
<4056=4058,4057
<4061=4062
<4062=4068,4063
<4063=4066,4064
<4064=4065
<4066=4067
<4068=4069
<4070=4071
<4071=4076,4075,4072
<4072=4074,4073
<4077=4078
<4078=4085,4084,4079
<4079=4083,4080
<4080=4082,4081
<4086=4087
<4087=4094,4093,4088
<4088=4092,4089
<4089=4091,4090
<4116=4119,4118,4117
<4119=4120
<4120=4121
<4121=4123,4122
<4130=4139,4138,4131
<4131=4135,4132
<4132=4134,4133
<4135=4137,4136
<4139=4216,4207,4198,4140
<4140=4194,4190,4187,4141
<4141=4178,4172,4142
<4142=4164,4143
<4143=4148,4144
<4144=4145
<4145=4147,4146
<4148=4149
<4149=4161,4150
<4150=4154,4151
<4151=4153,4152
<4154=4160,4155
<4155=4157,4156
<4157=4159,4158
<4161=4163,4162
<4164=4165
<4165=4169,4166
<4166=4168,4167
<4169=4171,4170
<4172=4173
<4173=4175,4174
<4175=4177,4176
<4178=4179
<4179=4186,4185,4180
<4180=4184,4181
<4181=4183,4182
<4187=4189,4188
<4190=4191
<4191=4193,4192
<4194=4195
<4195=4197,4196
<4198=4199
<4199=4206,4205,4200
<4200=4204,4201
<4201=4203,4202
<4207=4208
<4208=4215,4214,4209
<4209=4213,4210
<4210=4212,4211
<4216=4217
<4217=4219,4218
<4242=4251,4250,4243
<4243=4247,4244
<4244=4246,4245
<4247=4249,4248
<4251=4349,4340,4331,4322,4304,4252
<4252=4300,4296,4293,4253
<4253=4284,4254
<4254=4276,4255
<4255=4260,4256
<4256=4257
<4257=4259,4258
<4260=4261
<4261=4269,4262
<4262=4266,4263
<4263=4265,4264
<4266=4268,4267
<4269=4275,4270
<4270=4272,4271
<4272=4274,4273
<4276=4277
<4277=4281,4278
<4278=4280,4279
<4281=4283,4282
<4284=4285
<4285=4292,4291,4286
<4286=4290,4287
<4287=4289,4288
<4293=4295,4294
<4296=4297
<4297=4299,4298
<4300=4301
<4301=4303,4302
<4304=4318,4314,4311,4305
<4305=4306
<4306=4308,4307
<4308=4310,4309
<4311=4313,4312
<4314=4315
<4315=4317,4316
<4318=4319
<4319=4321,4320
<4322=4323
<4323=4330,4329,4324
<4324=4328,4325
<4325=4327,4326
<4331=4332
<4332=4339,4338,4333
<4333=4337,4334
<4334=4336,4335
<4340=4341
<4341=4348,4347,4342
<4342=4346,4343
<4343=4345,4344
<4349=4350
<4350=4352,4351
<4385=4406,4405,4386
<4386=4402,4399,4396,4393,4390,4387
<4387=4389,4388
<4390=4392,4391
<4393=4395,4394
<4396=4398,4397
<4399=4401,4400
<4402=4404,4403
<4406=4739,4732,4725,4711,4697,4683,4679,4551,4537,4531,4503,4472,4466,4438,4432,4426,4420,4414,4407
<4407=4408
<4408=4412,4409
<4409=4410
<4410=4411
<4412=4413
<4414=4415
<4415=4417,4416
<4417=4419,4418
<4420=4421
<4421=4423,4422
<4423=4425,4424
<4426=4427
<4427=4429,4428
<4429=4431,4430
<4432=4433
<4433=4435,4434
<4435=4437,4436
<4438=4462,4458,4455,4439
<4439=4440
<4440=4452,4441
<4441=4447,4442
<4442=4446,4443
<4443=4445,4444
<4447=4451,4448
<4448=4450,4449
<4452=4454,4453
<4455=4457,4456
<4458=4459
<4459=4461,4460
<4462=4463
<4463=4465,4464
<4466=4467
<4467=4469,4468
<4469=4471,4470
<4472=4499,4495,4492,4473
<4473=4482,4474
<4474=4475
<4475=4481,4476
<4476=4480,4477
<4477=4479,4478
<4482=4483
<4483=4485,4484
<4485=4491,4486
<4486=4490,4487
<4487=4489,4488
<4492=4494,4493
<4495=4496
<4496=4498,4497
<4499=4500
<4500=4502,4501
<4503=4527,4523,4520,4504
<4504=4505
<4505=4517,4506
<4506=4512,4507
<4507=4511,4508
<4508=4510,4509
<4512=4516,4513
<4513=4515,4514
<4517=4519,4518
<4520=4522,4521
<4523=4524
<4524=4526,4525
<4527=4528
<4528=4530,4529
<4531=4532
<4532=4534,4533
<4534=4536,4535
<4537=4538
<4538=4550,4549,4539
<4539=4548,4540
<4540=4546,4541
<4541=4544,4542
<4542=4543
<4544=4545
<4546=4547
<4551=4675,4671,4668,4552
<4552=4657,4653,4625,4619,4553
<4553=4615,4554
<4554=4571,4565,4559,4555
<4555=4556
<4556=4558,4557
<4559=4560
<4560=4562,4561
<4562=4564,4563
<4565=4566
<4566=4568,4567
<4568=4570,4569
<4571=4611,4572
<4572=4607,4590,4573
<4573=4574
<4574=4589,4575
<4575=4588,4576
<4576=4586,4577
<4577=4584,4578
<4578=4579
<4579=4583,4580
<4580=4582,4581
<4584=4585
<4586=4587
<4590=4591
<4591=4606,4592
<4592=4605,4593
<4593=4603,4594
<4594=4601,4595
<4595=4596
<4596=4600,4597
<4597=4599,4598
<4601=4602
<4603=4604
<4607=4608
<4608=4610,4609
<4611=4612
<4612=4614,4613
<4615=4616
<4616=4618,4617
<4619=4620
<4620=4622,4621
<4622=4624,4623
<4625=4649,4645,4642,4626
<4626=4627
<4627=4636,4628
<4628=4630,4629
<4630=4631
<4631=4635,4632
<4632=4634,4633
<4636=4637
<4637=4641,4638
<4638=4640,4639
<4642=4644,4643
<4645=4646
<4646=4648,4647
<4649=4650
<4650=4652,4651
<4653=4654
<4654=4656,4655
<4657=4658
<4658=4667,4666,4659
<4659=4665,4660
<4660=4662,4661
<4662=4664,4663
<4668=4670,4669
<4671=4672
<4672=4674,4673
<4675=4676
<4676=4678,4677
<4679=4680
<4680=4682,4681
<4683=4684
<4684=4696,4695,4685
<4685=4694,4686
<4686=4692,4687
<4687=4690,4688
<4688=4689
<4690=4691
<4692=4693
<4697=4698
<4698=4710,4709,4699
<4699=4708,4700
<4700=4706,4701
<4701=4704,4702
<4702=4703
<4704=4705
<4706=4707
<4711=4712
<4712=4724,4723,4713
<4713=4722,4714
<4714=4720,4715
<4715=4718,4716
<4716=4717
<4718=4719
<4720=4721
<4725=4726
<4726=4731,4730,4727
<4727=4729,4728
<4732=4733
<4733=4738,4737,4734
<4734=4736,4735
<4739=4740
<4740=4747,4746,4741
<4741=4745,4742
<4742=4744,4743
<4792=4810,4809,4793
<4793=4806,4803,4800,4797,4794
<4794=4796,4795
<4797=4799,4798
<4800=4802,4801
<4803=4805,4804
<4806=4808,4807
<4810=4872,4865,4834,4811
<4811=4832,4812
<4812=4825,4816,4815,4813
<4813=4814
<4816=4817
<4817=4821,4818
<4818=4819
<4819=4820
<4821=4822
<4822=4824,4823
<4825=4826
<4826=4831,4830,4827
<4827=4829,4828
<4832=4833
<4834=4861,4835
<4835=4859,4851,4850,4848,4840,4839,4837,4836
<4837=4838
<4840=4841
<4841=4847,4842
<4842=4846,4843
<4843=4845,4844
<4848=4849
<4851=4852
<4852=4858,4853
<4853=4857,4854
<4854=4856,4855
<4859=4860
<4861=4862
<4862=4864,4863
<4865=4866
<4866=4871,4870,4867
<4867=4869,4868
<4872=4873
<4873=4880,4879,4874
<4874=4878,4875
<4875=4877,4876
<4896=4914,4913,4897
<4897=4910,4907,4904,4901,4898
<4898=4900,4899
<4901=4903,4902
<4904=4906,4905
<4907=4909,4908
<4910=4912,4911
<4914=5104,5096,5089,4978,4915
<4915=4974,4923,4916
<4916=4917
<4917=4918
<4918=4920,4919
<4920=4922,4921
<4923=4966,4936,4924
<4924=4925
<4925=4929,4926
<4926=4928,4927
<4929=4931,4930
<4931=4935,4932
<4932=4934,4933
<4936=4958,4954,4951,4937
<4937=4938
<4938=4942,4939
<4939=4941,4940
<4942=4944,4943
<4944=4946,4945
<4946=4948,4947
<4948=4950,4949
<4951=4953,4952
<4954=4955
<4955=4957,4956
<4958=4959
<4959=4960
<4960=4965,4964,4961
<4961=4963,4962
<4966=4967
<4967=4971,4968
<4968=4970,4969
<4971=4973,4972
<4974=4975
<4975=4977,4976
<4978=5081,5077,5074,4979
<4979=5062,5050,5007,4992,4980
<4980=4981
<4981=4985,4982
<4982=4984,4983
<4985=4987,4986
<4987=4991,4988
<4988=4990,4989
<4992=5003,4993
<4993=4994
<4994=4996,4995
<4996=4998,4997
<4998=5002,4999
<4999=5001,5000
<5003=5004
<5004=5006,5005
<5007=5042,5036,5033,5008
<5008=5023,5013,5009
<5009=5010
<5010=5012,5011
<5013=5014
<5014=5018,5015
<5015=5017,5016
<5018=5020,5019
<5020=5022,5021
<5023=5024
<5024=5028,5025
<5025=5027,5026
<5028=5030,5029
<5030=5032,5031
<5033=5035,5034
<5036=5037
<5037=5041,5038
<5038=5040,5039
<5042=5043
<5043=5044
<5044=5049,5048,5045
<5045=5047,5046
<5050=5051
<5051=5057,5052
<5052=5056,5053
<5053=5055,5054
<5057=5059,5058
<5059=5061,5060
<5062=5063
<5063=5069,5064
<5064=5068,5065
<5065=5067,5066
<5069=5071,5070
<5071=5073,5072
<5074=5076,5075
<5077=5078
<5078=5080,5079
<5081=5082
<5082=5083
<5083=5088,5087,5084
<5084=5086,5085
<5089=5090
<5090=5095,5094,5091
<5091=5093,5092
<5096=5097
<5097=5103,5098
<5098=5102,5099
<5099=5101,5100
<5104=5105
<5105=5111,5106
<5106=5110,5107
<5107=5109,5108
<5148=5157,5156,5149
<5149=5153,5150
<5150=5152,5151
<5153=5155,5154
<5157=5803,5794,5785,5771,5749,5741,5733,5729,5722,5715,5708,5694,5669,5663,5650,5628,5614,5594,5520,5519,5518,5517,5516,5515,5514,5513,5512,5511,5510,5509,5508,5507,5483,5479,5470,5442,5202,5195,5188,5181,5174,5167,5160,5158
<5158=5159
<5160=5161
<5161=5165,5162
<5162=5163
<5163=5164
<5165=5166
<5167=5168
<5168=5172,5169
<5169=5170
<5170=5171
<5172=5173
<5174=5175
<5175=5179,5176
<5176=5177
<5177=5178
<5179=5180
<5181=5182
<5182=5186,5183
<5183=5184
<5184=5185
<5186=5187
<5188=5189
<5189=5193,5190
<5190=5191
<5191=5192
<5193=5194
<5195=5196
<5196=5200,5197
<5197=5198
<5198=5199
<5200=5201
<5202=5438,5342,5203
<5203=5204
<5204=5327,5205
<5205=5323,5319,5316,5206
<5206=5307,5296,5292,5274,5256,5236,5207
<5207=5208
<5208=5234,5209
<5209=5230,5228,5218,5214,5210
<5210=5211
<5211=5213,5212
<5214=5215
<5215=5217,5216
<5218=5219
<5219=5227,5220
<5220=5224,5221
<5221=5223,5222
<5224=5226,5225
<5228=5229
<5230=5231
<5231=5233,5232
<5234=5235
<5236=5250,5247,5237
<5237=5238
<5238=5242,5239
<5239=5241,5240
<5242=5244,5243
<5244=5246,5245
<5247=5249,5248
<5250=5251
<5251=5255,5252
<5252=5254,5253
<5256=5270,5267,5257
<5257=5258
<5258=5262,5259
<5259=5261,5260
<5262=5264,5263
<5264=5266,5265
<5267=5269,5268
<5270=5271
<5271=5273,5272
<5274=5288,5285,5275
<5275=5276
<5276=5280,5277
<5277=5279,5278
<5280=5282,5281
<5282=5284,5283
<5285=5287,5286
<5288=5289
<5289=5291,5290
<5292=5293
<5293=5295,5294
<5296=5297
<5297=5306,5305,5298
<5298=5304,5299
<5299=5303,5300
<5300=5302,5301
<5307=5308
<5308=5315,5314,5309
<5309=5313,5310
<5310=5312,5311
<5316=5318,5317
<5319=5320
<5320=5322,5321
<5323=5324
<5324=5326,5325
<5327=5328
<5328=5339,5329
<5329=5337,5330
<5330=5335,5331
<5331=5332
<5332=5334,5333
<5335=5336
<5337=5338
<5339=5341,5340
<5342=5425,5412,5408,5390,5370,5343
<5343=5344
<5344=5368,5345
<5345=5364,5362,5354,5350,5346
<5346=5347
<5347=5349,5348
<5350=5351
<5351=5353,5352
<5354=5355
<5355=5361,5356
<5356=5358,5357
<5358=5360,5359
<5362=5363
<5364=5365
<5365=5367,5366
<5368=5369
<5370=5384,5381,5371
<5371=5372
<5372=5376,5373
<5373=5375,5374
<5376=5378,5377
<5378=5380,5379
<5381=5383,5382
<5384=5385
<5385=5389,5386
<5386=5388,5387
<5390=5404,5401,5391
<5391=5392
<5392=5396,5393
<5393=5395,5394
<5396=5398,5397
<5398=5400,5399
<5401=5403,5402
<5404=5405
<5405=5407,5406
<5408=5409
<5409=5411,5410
<5412=5413
<5413=5424,5423,5414
<5414=5422,5415
<5415=5419,5416
<5416=5418,5417
<5419=5421,5420
<5425=5426
<5426=5435,5427
<5427=5433,5428
<5428=5431,5429
<5429=5430
<5431=5432
<5433=5434
<5435=5437,5436
<5438=5439
<5439=5441,5440
<5442=5462,5456,5453,5443
<5443=5444
<5444=5448,5445
<5445=5447,5446
<5448=5450,5449
<5450=5452,5451
<5453=5455,5454
<5456=5457
<5457=5461,5458
<5458=5460,5459
<5462=5463
<5463=5464
<5464=5469,5468,5465
<5465=5467,5466
<5470=5471
<5471=5478,5477,5472
<5472=5476,5473
<5473=5475,5474
<5479=5480
<5480=5482,5481
<5483=5503,5499,5496,5484
<5484=5485
<5485=5493,5486
<5486=5490,5487
<5487=5489,5488
<5490=5492,5491
<5493=5495,5494
<5496=5498,5497
<5499=5500
<5500=5502,5501
<5503=5504
<5504=5506,5505
<5520=5590,5584,5581,5521
<5521=5577,5553,5522
<5522=5549,5534,5523
<5523=5524
<5524=5525
<5525=5531,5526
<5526=5528,5527
<5528=5530,5529
<5531=5533,5532
<5534=5535
<5535=5547,5536
<5536=5545,5543,5537
<5537=5538
<5538=5540,5539
<5540=5542,5541
<5543=5544
<5545=5546
<5547=5548
<5549=5550
<5550=5552,5551
<5553=5573,5569,5566,5554
<5554=5556,5555
<5556=5557
<5557=5561,5558
<5558=5560,5559
<5561=5563,5562
<5563=5565,5564
<5566=5568,5567
<5569=5570
<5570=5572,5571
<5573=5574
<5574=5576,5575
<5577=5578
<5578=5580,5579
<5581=5583,5582
<5584=5585
<5585=5589,5586
<5586=5588,5587
<5590=5591
<5591=5593,5592
<5594=5610,5606,5603,5595
<5595=5596
<5596=5600,5597
<5597=5599,5598
<5600=5602,5601
<5603=5605,5604
<5606=5607
<5607=5609,5608
<5610=5611
<5611=5613,5612
<5614=5615
<5615=5627,5626,5616
<5616=5625,5617
<5617=5623,5618
<5618=5621,5619
<5619=5620
<5621=5622
<5623=5624
<5628=5646,5642,5639,5629
<5629=5630
<5630=5634,5631
<5631=5633,5632
<5634=5636,5635
<5636=5638,5637
<5639=5641,5640
<5642=5643
<5643=5645,5644
<5646=5647
<5647=5649,5648
<5650=5651
<5651=5660,5652
<5652=5658,5653
<5653=5656,5654
<5654=5655
<5656=5657
<5658=5659
<5660=5662,5661
<5663=5664
<5664=5666,5665
<5666=5668,5667
<5669=5670
<5670=5692,5671
<5671=5690,5686,5682,5678,5674,5672
<5672=5673
<5674=5675
<5675=5677,5676
<5678=5679
<5679=5681,5680
<5682=5683
<5683=5685,5684
<5686=5687
<5687=5689,5688
<5690=5691
<5692=5693
<5694=5695
<5695=5707,5706,5696
<5696=5705,5697
<5697=5703,5698
<5698=5701,5699
<5699=5700
<5701=5702
<5703=5704
<5708=5709
<5709=5714,5713,5710
<5710=5712,5711
<5715=5716
<5716=5721,5720,5717
<5717=5719,5718
<5722=5723
<5723=5728,5727,5724
<5724=5726,5725
<5729=5730
<5730=5732,5731
<5733=5734
<5734=5738,5735
<5735=5737,5736
<5738=5740,5739
<5741=5742
<5742=5746,5743
<5743=5745,5744
<5746=5748,5747
<5749=5765,5757,5750
<5750=5751
<5751=5752
<5752=5754,5753
<5754=5756,5755
<5757=5758
<5758=5762,5759
<5759=5761,5760
<5762=5764,5763
<5765=5766
<5766=5768,5767
<5768=5770,5769
<5771=5772
<5772=5784,5783,5773
<5773=5782,5774
<5774=5780,5775
<5775=5778,5776
<5776=5777
<5778=5779
<5780=5781
<5785=5786
<5786=5793,5792,5787
<5787=5791,5788
<5788=5790,5789
<5794=5795
<5795=5802,5801,5796
<5796=5800,5797
<5797=5799,5798
<5803=5804
<5804=5806,5805
<5885=5894,5893,5886
<5886=5890,5887
<5887=5889,5888
<5890=5892,5891
<5894=6175,6171,6162,6158,6149,6131,6117,6108,6104,6086,6071,6058,6049,6020,6011,6000,5987,5978,5921,5895
<5895=5903,5899,5896
<5896=5897
<5897=5898
<5899=5900
<5900=5902,5901
<5903=5904
<5904=5913,5905
<5905=5907,5906
<5907=5911,5908
<5908=5909
<5909=5910
<5911=5912
<5913=5915,5914
<5915=5919,5916
<5916=5917
<5917=5918
<5919=5920
<5921=5974,5970,5967,5922
<5922=5963,5932,5923
<5923=5924
<5924=5930,5925
<5925=5928,5926
<5926=5927
<5928=5929
<5930=5931
<5932=5959,5955,5952,5933
<5933=5934
<5934=5950,5935
<5935=5948,5946,5936
<5936=5937
<5937=5943,5938
<5938=5940,5939
<5940=5942,5941
<5943=5945,5944
<5946=5947
<5948=5949
<5950=5951
<5952=5954,5953
<5955=5956
<5956=5958,5957
<5959=5960
<5960=5962,5961
<5963=5964
<5964=5966,5965
<5967=5969,5968
<5970=5971
<5971=5973,5972
<5974=5975
<5975=5977,5976
<5978=5979
<5979=5985,5980
<5980=5983,5981
<5981=5982
<5983=5984
<5985=5986
<5987=5988
<5988=5998,5989
<5989=5996,5994,5990
<5990=5991
<5991=5993,5992
<5994=5995
<5996=5997
<5998=5999
<6000=6001
<6001=6009,6002
<6002=6007,6005,6003
<6003=6004
<6005=6006
<6007=6008
<6009=6010
<6011=6012
<6012=6018,6013
<6013=6016,6014
<6014=6015
<6016=6017
<6018=6019
<6020=6045,6039,6036,6021
<6021=6022
<6022=6034,6023
<6023=6032,6030,6024
<6024=6025
<6025=6027,6026
<6027=6029,6028
<6030=6031
<6032=6033
<6034=6035
<6036=6038,6037
<6039=6040
<6040=6044,6041
<6041=6043,6042
<6045=6046
<6046=6048,6047
<6049=6050
<6050=6056,6051
<6051=6054,6052
<6052=6053
<6054=6055
<6056=6057
<6058=6059
<6059=6069,6060
<6060=6067,6065,6061
<6061=6062
<6062=6064,6063
<6065=6066
<6067=6068
<6069=6070
<6071=6072
<6072=6084,6073
<6073=6082,6080,6074
<6074=6075
<6075=6079,6076
<6076=6078,6077
<6080=6081
<6082=6083
<6084=6085
<6086=6098,6094,6087
<6087=6088
<6088=6089
<6089=6093,6090
<6090=6092,6091
<6094=6095
<6095=6097,6096
<6098=6099
<6099=6101,6100
<6101=6103,6102
<6104=6105
<6105=6107,6106
<6108=6113,6109
<6109=6110
<6110=6112,6111
<6113=6114
<6114=6116,6115
<6117=6118
<6118=6130,6129,6119
<6119=6128,6120
<6120=6126,6121
<6121=6124,6122
<6122=6123
<6124=6125
<6126=6127
<6131=6143,6137,6132
<6132=6133
<6133=6134
<6134=6136,6135
<6137=6138
<6138=6142,6139
<6139=6141,6140
<6143=6144
<6144=6146,6145
<6146=6148,6147
<6149=6150
<6150=6157,6156,6151
<6151=6155,6152
<6152=6154,6153
<6158=6159
<6159=6161,6160
<6162=6163
<6163=6170,6169,6164
<6164=6168,6165
<6165=6167,6166
<6171=6172
<6172=6174,6173
<6175=6176
<6176=6185,6184,6177
<6177=6183,6178
<6178=6182,6181,6180,6179
<6220=6226,6225,6221
<6221=6222
<6222=6224,6223
<6226=6847,6833,6826,6822,6818,6814,6810,6806,6792,6783,6777,6772,6385,6379,6361,6357,6343,6328,6250,6229,6227
<6227=6228
<6229=6232,6230
<6230=6231
<6232=6233
<6233=6242,6234
<6234=6236,6235
<6236=6240,6237
<6237=6238
<6238=6239
<6240=6241
<6242=6244,6243
<6244=6248,6245
<6245=6246
<6246=6247
<6248=6249
<6250=6324,6320,6317,6251
<6251=6313,6270,6256,6252
<6252=6253
<6253=6255,6254
<6256=6257
<6257=6269,6268,6258
<6258=6267,6259
<6259=6265,6260
<6260=6263,6261
<6261=6262
<6263=6264
<6265=6266
<6270=6309,6305,6302,6271
<6271=6276,6272
<6272=6273
<6273=6275,6274
<6276=6277
<6277=6301,6300,6278
<6278=6299,6279
<6279=6297,6280
<6280=6295,6293,6281
<6281=6282
<6282=6292,6283
<6283=6289,6284
<6284=6286,6285
<6286=6288,6287
<6289=6291,6290
<6293=6294
<6295=6296
<6297=6298
<6302=6304,6303
<6305=6306
<6306=6308,6307
<6309=6310
<6310=6312,6311
<6313=6314
<6314=6316,6315
<6317=6319,6318
<6320=6321
<6321=6323,6322
<6324=6325
<6325=6327,6326
<6328=6329
<6329=6340,6330
<6330=6338,6331
<6331=6336,6332
<6332=6333
<6333=6335,6334
<6336=6337
<6338=6339
<6340=6342,6341
<6343=6353,6349,6344
<6344=6345
<6345=6346
<6346=6348,6347
<6349=6350
<6350=6352,6351
<6353=6354
<6354=6356,6355
<6357=6358
<6358=6360,6359
<6361=6373,6367,6362
<6362=6363
<6363=6364
<6364=6366,6365
<6367=6368
<6368=6372,6369
<6369=6371,6370
<6373=6374
<6374=6376,6375
<6376=6378,6377
<6379=6380
<6380=6384,6381
<6381=6383,6382
<6385=6770,6386
<6386=6754,6750,6387
<6387=6739,6637,6388
<6388=6389
<6389=6626,6597,6390
<6390=6391
<6391=6586,6557,6392
<6392=6393
<6393=6546,6517,6394
<6394=6395
<6395=6506,6504,6396
<6396=6397
<6397=6493,6427,6398
<6398=6399
<6399=6416,6409,6402,6400
<6400=6401
<6402=6403
<6403=6407,6404
<6404=6405
<6405=6406
<6407=6408
<6409=6410
<6410=6414,6411
<6411=6412
<6412=6413
<6414=6415
<6416=6417
<6417=6425,6418
<6418=6423,6421,6419
<6419=6420
<6421=6422
<6423=6424
<6425=6426
<6427=6484,6471,6428
<6428=6463,6459,6456,6429
<6429=6434,6430
<6430=6431
<6431=6433,6432
<6434=6435
<6435=6455,6454,6436
<6436=6453,6437
<6437=6451,6438
<6438=6449,6447,6439
<6439=6440
<6440=6446,6441
<6441=6443,6442
<6443=6445,6444
<6447=6448
<6449=6450
<6451=6452
<6456=6458,6457
<6459=6460
<6460=6462,6461
<6463=6464
<6464=6465
<6465=6470,6469,6466
<6466=6468,6467
<6471=6472
<6472=6481,6473
<6473=6479,6474
<6474=6477,6475
<6475=6476
<6477=6478
<6479=6480
<6481=6483,6482
<6484=6485
<6485=6492,6491,6486
<6486=6490,6487
<6487=6489,6488
<6493=6494
<6494=6496,6495
<6496=6502,6497
<6497=6500,6498
<6498=6499
<6500=6501
<6502=6503
<6504=6505
<6506=6507
<6507=6509,6508
<6509=6515,6510
<6510=6513,6511
<6511=6512
<6513=6514
<6515=6516
<6517=6528,6524,6518
<6518=6519
<6519=6521,6520
<6521=6523,6522
<6524=6525
<6525=6527,6526
<6528=6529
<6529=6545,6544,6530
<6530=6543,6531
<6531=6541,6532
<6532=6539,6537,6533
<6533=6534
<6534=6536,6535
<6537=6538
<6539=6540
<6541=6542
<6546=6547
<6547=6549,6548
<6549=6555,6550
<6550=6553,6551
<6551=6552
<6553=6554
<6555=6556
<6557=6568,6564,6558
<6558=6559
<6559=6561,6560
<6561=6563,6562
<6564=6565
<6565=6567,6566
<6568=6569
<6569=6585,6584,6570
<6570=6583,6571
<6571=6581,6572
<6572=6579,6577,6573
<6573=6574
<6574=6576,6575
<6577=6578
<6579=6580
<6581=6582
<6586=6587
<6587=6589,6588
<6589=6595,6590
<6590=6593,6591
<6591=6592
<6593=6594
<6595=6596
<6597=6608,6604,6598
<6598=6599
<6599=6601,6600
<6601=6603,6602
<6604=6605
<6605=6607,6606
<6608=6609
<6609=6625,6624,6610
<6610=6623,6611
<6611=6621,6612
<6612=6619,6617,6613
<6613=6614
<6614=6616,6615
<6617=6618
<6619=6620
<6621=6622
<6626=6627
<6627=6629,6628
<6629=6635,6630
<6630=6633,6631
<6631=6632
<6633=6634
<6635=6636
<6637=6723,6719,6715,6680,6638
<6638=6674,6639
<6639=6665,6656,6649,6642,6640
<6640=6641
<6642=6643
<6643=6647,6644
<6644=6645
<6645=6646
<6647=6648
<6649=6650
<6650=6654,6651
<6651=6652
<6652=6653
<6654=6655
<6656=6657
<6657=6663,6658
<6658=6659
<6659=6660
<6660=6662,6661
<6663=6664
<6665=6666
<6666=6672,6667
<6667=6670,6668
<6668=6669
<6670=6671
<6672=6673
<6674=6675
<6675=6677,6676
<6677=6679,6678
<6680=6711,6707,6704,6681
<6681=6682
<6682=6691,6683
<6683=6685,6684
<6685=6686
<6686=6688,6687
<6688=6690,6689
<6691=6692
<6692=6694,6693
<6694=6702,6695
<6695=6698,6696
<6696=6697
<6698=6699
<6699=6701,6700
<6702=6703
<6704=6706,6705
<6707=6708
<6708=6710,6709
<6711=6712
<6712=6714,6713
<6715=6716
<6716=6718,6717
<6719=6720
<6720=6722,6721
<6723=6724
<6724=6738,6737,6725
<6725=6736,6726
<6726=6734,6727
<6727=6732,6730,6728
<6728=6729
<6730=6731
<6732=6733
<6734=6735
<6739=6740
<6740=6742,6741
<6742=6748,6743
<6743=6746,6744
<6744=6745
<6746=6747
<6748=6749
<6750=6751
<6751=6753,6752
<6754=6755
<6755=6769,6768,6756
<6756=6767,6757
<6757=6765,6758
<6758=6763,6761,6759
<6759=6760
<6761=6762
<6763=6764
<6765=6766
<6770=6771
<6772=6773
<6773=6776,6775,6774
<6777=6778
<6778=6780,6779
<6780=6782,6781
<6783=6784
<6784=6791,6790,6785
<6785=6789,6786
<6786=6788,6787
<6792=6793
<6793=6805,6804,6794
<6794=6803,6795
<6795=6801,6796
<6796=6799,6797
<6797=6798
<6799=6800
<6801=6802
<6806=6807
<6807=6809,6808
<6810=6811
<6811=6813,6812
<6814=6815
<6815=6817,6816
<6818=6819
<6819=6821,6820
<6822=6823
<6823=6825,6824
<6826=6829,6827
<6827=6828
<6829=6830
<6830=6832,6831
<6833=6834
<6834=6846,6845,6835
<6835=6844,6836
<6836=6842,6837
<6837=6840,6838
<6838=6839
<6840=6841
<6842=6843
<6847=6848
<6848=6857,6856,6849
<6849=6855,6850
<6850=6854,6853,6852,6851
<6905=6917,6916,6906
<6906=6913,6910,6907
<6907=6909,6908
<6910=6912,6911
<6913=6915,6914
<6917=7121,7099,7090,7081,7077,7063,6986,6918
<6918=6982,6964,6919
<6919=6920
<6920=6957,6927,6921
<6921=6922
<6922=6924,6923
<6924=6926,6925
<6927=6949,6945,6942,6928
<6928=6929
<6929=6934,6930
<6930=6931
<6931=6933,6932
<6934=6935
<6935=6939,6936
<6936=6938,6937
<6939=6941,6940
<6942=6944,6943
<6945=6946
<6946=6948,6947
<6949=6950
<6950=6951
<6951=6956,6955,6952
<6952=6954,6953
<6957=6958
<6958=6963,6962,6959
<6959=6961,6960
<6964=6965
<6965=6976,6971,6966
<6966=6968,6967
<6968=6970,6969
<6971=6973,6972
<6973=6975,6974
<6976=6977
<6977=6979,6978
<6979=6981,6980
<6982=6983
<6983=6985,6984
<6986=7055,7051,7048,6987
<6987=7041,7034,7030,6994,6988
<6988=6989
<6989=6991,6990
<6991=6993,6992
<6994=7020,7017,6995
<6995=6996
<6996=7013,6997
<6997=6998
<6998=7012,6999
<6999=7003,7000
<7000=7002,7001
<7003=7011,7004
<7004=7008,7005
<7005=7007,7006
<7008=7010,7009
<7013=7014
<7014=7016,7015
<7017=7019,7018
<7020=7021
<7021=7025,7022
<7022=7024,7023
<7025=7029,7026
<7026=7028,7027
<7030=7031
<7031=7033,7032
<7034=7035
<7035=7040,7039,7036
<7036=7038,7037
<7041=7042
<7042=7047,7046,7043
<7043=7045,7044
<7048=7050,7049
<7051=7052
<7052=7054,7053
<7055=7056
<7056=7057
<7057=7062,7061,7058
<7058=7060,7059
<7063=7073,7069,7064
<7064=7065
<7065=7066
<7066=7068,7067
<7069=7070
<7070=7072,7071
<7073=7074
<7074=7076,7075
<7077=7078
<7078=7080,7079
<7081=7082
<7082=7089,7088,7083
<7083=7087,7084
<7084=7086,7085
<7090=7091
<7091=7098,7097,7092
<7092=7096,7093
<7093=7095,7094
<7099=7115,7107,7100
<7100=7101
<7101=7102
<7102=7106,7103
<7103=7105,7104
<7107=7108
<7108=7114,7109
<7109=7111,7110
<7111=7113,7112
<7115=7116
<7116=7118,7117
<7118=7120,7119
<7121=7122
<7122=7124,7123
<7157=7166,7165,7158
<7158=7162,7159
<7159=7161,7160
<7162=7164,7163
<7166=7209,7192,7176,7169,7167
<7167=7168
<7169=7170
<7170=7174,7171
<7171=7172
<7172=7173
<7174=7175
<7176=7177
<7177=7191,7190,7178
<7178=7189,7179
<7179=7187,7180
<7180=7185,7183,7181
<7181=7182
<7183=7184
<7185=7186
<7187=7188
<7192=7193
<7193=7207,7194
<7194=7205,7199,7195
<7195=7196
<7196=7198,7197
<7199=7200
<7200=7204,7201
<7201=7203,7202
<7205=7206
<7207=7208
<7209=7210
<7210=7224,7223,7211
<7211=7222,7212
<7212=7220,7213
<7213=7218,7214
<7214=7215
<7215=7217,7216
<7218=7219
<7220=7221
<7237=7249,7248,7238
<7238=7245,7242,7239
<7239=7241,7240
<7242=7244,7243
<7245=7247,7246
<7249=7250
<7250=7399,7254,7251
<7251=7252
<7252=7253
<7254=7395,7386,7382,7368,7352,7321,7257,7255
<7255=7256
<7257=7317,7307,7258
<7258=7259
<7259=7300,7282,7260
<7260=7278,7274,7271,7261
<7261=7262
<7262=7268,7263
<7263=7265,7264
<7265=7267,7266
<7268=7270,7269
<7271=7273,7272
<7274=7275
<7275=7277,7276
<7278=7279
<7279=7281,7280
<7282=7296,7292,7289,7283
<7283=7284
<7284=7288,7285
<7285=7287,7286
<7289=7291,7290
<7292=7293
<7293=7295,7294
<7296=7297
<7297=7299,7298
<7300=7301
<7301=7306,7305,7302
<7302=7304,7303
<7307=7308
<7308=7314,7309
<7309=7313,7310
<7310=7312,7311
<7314=7316,7315
<7317=7318
<7318=7320,7319
<7321=7348,7344,7341,7322
<7322=7323
<7323=7338,7324
<7324=7337,7325
<7325=7336,7326
<7326=7334,7327
<7327=7328
<7328=7329
<7329=7333,7330
<7330=7332,7331
<7334=7335
<7338=7340,7339
<7341=7343,7342
<7344=7345
<7345=7347,7346
<7348=7349
<7349=7351,7350
<7352=7353
<7353=7367,7366,7354
<7354=7365,7355
<7355=7363,7356
<7356=7361,7359,7357
<7357=7358
<7359=7360
<7361=7362
<7363=7364
<7368=7378,7374,7369
<7369=7370
<7370=7371
<7371=7373,7372
<7374=7375
<7375=7377,7376
<7378=7379
<7379=7381,7380
<7382=7383
<7383=7385,7384
<7386=7387
<7387=7394,7393,7388
<7388=7392,7389
<7389=7391,7390
<7395=7396
<7396=7398,7397
<7399=7400
<7400=7402,7401
<7402=7404,7403
<7404=7406,7405
<7427=7442,7441,7428
<7428=7438,7435,7432,7429
<7429=7431,7430
<7432=7434,7433
<7435=7437,7436
<7438=7440,7439
<7442=7781,7765,7756,7742,7724,7682,7660,7457,7450,7443
<7443=7444
<7444=7448,7445
<7445=7446
<7446=7447
<7448=7449
<7450=7451
<7451=7455,7452
<7452=7453
<7453=7454
<7455=7456
<7457=7656,7652,7649,7458
<7458=7640,7629,7622,7605,7601,7556,7511,7495,7462,7461,7459
<7459=7460
<7462=7491,7487,7484,7463
<7463=7464
<7464=7479,7465
<7465=7477,7466
<7466=7475,7467
<7467=7468
<7468=7472,7469
<7469=7471,7470
<7472=7474,7473
<7475=7476
<7477=7478
<7479=7483,7480
<7480=7482,7481
<7484=7486,7485
<7487=7488
<7488=7490,7489
<7491=7492
<7492=7494,7493
<7495=7496
<7496=7510,7509,7497
<7497=7508,7498
<7498=7506,7499
<7499=7502,7500
<7500=7501
<7502=7503
<7503=7505,7504
<7506=7507
<7511=7552,7548,7545,7512
<7512=7531,7517,7513
<7513=7514
<7514=7516,7515
<7517=7518
<7518=7526,7519
<7519=7523,7520
<7520=7522,7521
<7523=7525,7524
<7526=7528,7527
<7528=7530,7529
<7531=7532
<7532=7540,7533
<7533=7537,7534
<7534=7536,7535
<7537=7539,7538
<7540=7542,7541
<7542=7544,7543
<7545=7547,7546
<7548=7549
<7549=7551,7550
<7552=7553
<7553=7555,7554
<7556=7597,7593,7590,7557
<7557=7576,7562,7558
<7558=7559
<7559=7561,7560
<7562=7563
<7563=7571,7564
<7564=7568,7565
<7565=7567,7566
<7568=7570,7569
<7571=7573,7572
<7573=7575,7574
<7576=7577
<7577=7585,7578
<7578=7582,7579
<7579=7581,7580
<7582=7584,7583
<7585=7587,7586
<7587=7589,7588
<7590=7592,7591
<7593=7594
<7594=7596,7595
<7597=7598
<7598=7600,7599
<7601=7602
<7602=7604,7603
<7605=7606
<7606=7621,7620,7607
<7607=7615,7608
<7608=7612,7609
<7609=7611,7610
<7612=7614,7613
<7615=7619,7616
<7616=7618,7617
<7622=7626,7623
<7623=7625,7624
<7626=7628,7627
<7629=7630
<7630=7639,7638,7631
<7631=7637,7632
<7632=7636,7633
<7633=7635,7634
<7640=7641
<7641=7648,7647,7642
<7642=7646,7643
<7643=7645,7644
<7649=7651,7650
<7652=7653
<7653=7655,7654
<7656=7657
<7657=7659,7658
<7660=7678,7674,7671,7661
<7661=7662
<7662=7668,7663
<7663=7667,7664
<7664=7666,7665
<7668=7670,7669
<7671=7673,7672
<7674=7675
<7675=7677,7676
<7678=7679
<7679=7681,7680
<7682=7720,7716,7713,7683
<7683=7697,7684
<7684=7685
<7685=7695,7686
<7686=7691,7687
<7687=7688
<7688=7690,7689
<7691=7692
<7692=7694,7693
<7695=7696
<7697=7698
<7698=7712,7711,7699
<7699=7710,7700
<7700=7709,7701
<7701=7705,7702
<7702=7704,7703
<7705=7707,7706
<7707=7708
<7713=7715,7714
<7716=7717
<7717=7719,7718
<7720=7721
<7721=7723,7722
<7724=7738,7734,7731,7725
<7725=7726
<7726=7728,7727
<7728=7730,7729
<7731=7733,7732
<7734=7735
<7735=7737,7736
<7738=7739
<7739=7741,7740
<7742=7743
<7743=7755,7754,7744
<7744=7753,7745
<7745=7751,7746
<7746=7749,7747
<7747=7748
<7749=7750
<7751=7752
<7756=7757
<7757=7764,7763,7758
<7758=7762,7759
<7759=7761,7760
<7765=7766
<7766=7780,7779,7767
<7767=7778,7768
<7768=7776,7769
<7769=7774,7770
<7770=7771
<7771=7773,7772
<7774=7775
<7776=7777
<7781=7782
<7782=7784,7783
