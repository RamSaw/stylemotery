>3	FunctionDef	ConstraintProposalValidator 
>4	ParameterList	int id
>5	Parameter	 
>6	Identifier	id
>7	ParameterType	int
>8	CompoundStatement	 
>13	FunctionDef	ConstraintProposalValidator 
>14	ParameterList	 
>15	ReturnType	ConstraintProposalValidator 
>16	CompoundStatement	 
>17	ReturnStatement	 
>18	UnaryOp	* this
>19	Identifier	this
>20	UnaryOperator	*
>21	ExpressionStatement	 
>22	AssignmentExpr	OnlyKeepBest = true
>23	Identifier	true
>24	Identifier	OnlyKeepBest
>32	FunctionDef	ConstraintProposalValidator 
>33	ParameterList	 
>34	ReturnType	ConstraintProposalValidator 
>35	CompoundStatement	 
>36	ReturnStatement	 
>37	UnaryOp	* this
>38	Identifier	this
>39	UnaryOperator	*
>40	ExpressionStatement	 
>41	AssignmentExpr	OnlyKeepBest = false
>42	Identifier	false
>43	Identifier	OnlyKeepBest
>51	FunctionDef	ConstraintProposalValidator 
>52	ParameterList	const dvo 
>53	Parameter	 
>54	Identifier	cfg
>55	ParameterType	const dvo 
>56	ReturnType	ConstraintProposalValidator 
>57	CompoundStatement	 
>58	ReturnStatement	 
>59	UnaryOp	* this
>60	Identifier	this
>61	UnaryOperator	*
>62	ExpressionStatement	 
>63	AssignmentExpr	TrackingConfig = cfg
>64	Identifier	cfg
>65	Identifier	TrackingConfig
>73	FunctionDef	ConstraintProposalValidator 
>74	ParameterList	ConstraintProposalVoter * v
>75	Parameter	 
>76	Identifier	v
>77	ParameterType	ConstraintProposalVoter *
>78	ReturnType	ConstraintProposalValidator 
>79	CompoundStatement	 
>80	ReturnStatement	 
>81	UnaryOp	* this
>82	Identifier	this
>83	UnaryOperator	*
>84	ExpressionStatement	 
>85	CallExpression	Voters . push_back ( ConstraintProposalVoterPtr ( v ) )
>86	ArgumentList	ConstraintProposalVoterPtr ( v )
>87	Argument	ConstraintProposalVoterPtr ( v )
>88	CallExpression	ConstraintProposalVoterPtr ( v )
>89	ArgumentList	v
>90	Argument	v
>91	Identifier	v
>92	Callee	ConstraintProposalVoterPtr
>93	Identifier	ConstraintProposalVoterPtr
>94	Callee	Voters . push_back
>95	MemberAccess	Voters . push_back
>96	Identifier	push_back
>97	Identifier	Voters
>106	FunctionDef	ConstraintProposalValidator 
>107	ParameterList	 
>108	CompoundStatement	 
>112	FunctionDef	ConstraintProposalValidator 
>113	ParameterList	int id
>114	Parameter	 
>115	Identifier	id
>116	ParameterType	int
>117	ReturnType	ConstraintProposalValidator 
>118	CompoundStatement	 
>119	ReturnStatement	 
>120	CallExpression	stages_ . back ( )
>121	ArgumentList	 
>122	Callee	stages_ . back
>123	MemberAccess	stages_ . back
>124	Identifier	back
>125	Identifier	stages_
>126	ExpressionStatement	 
>127	CallExpression	stages_ . push_back ( Stage ( id ) )
>128	ArgumentList	Stage ( id )
>129	Argument	Stage ( id )
>130	CallExpression	Stage ( id )
>131	ArgumentList	id
>132	Argument	id
>133	Identifier	id
>134	Callee	Stage
>135	Identifier	Stage
>136	Callee	stages_ . push_back
>137	MemberAccess	stages_ . push_back
>138	Identifier	push_back
>139	Identifier	stages_
>147	FunctionDef	ConstraintProposalValidator 
>148	ParameterList	ConstraintProposalVector & proposals , bool debug
>149	Parameter	 
>150	Identifier	debug
>151	ParameterType	bool
>152	Parameter	 
>153	Identifier	proposals
>154	ParameterType	ConstraintProposalVector &
>155	ReturnType	void
>156	CompoundStatement	 
>157	ForStatement	for ( StageVector 
>158	CompoundStatement	 
>159	ForStatement	for ( ConstraintProposalVector 
>160	CompoundStatement	 
>161	ExpressionStatement	 
>162	AssignmentExpr	p -> InitialTransformation = p -> TrackingResult . Transformation . inverse ( )
>163	CallExpression	p -> TrackingResult . Transformation . inverse ( )
>164	ArgumentList	 
>165	Callee	p -> TrackingResult . Transformation . inverse
>166	MemberAccess	p -> TrackingResult . Transformation . inverse
>167	Identifier	inverse
>168	MemberAccess	p -> TrackingResult . Transformation
>169	Identifier	Transformation
>170	PtrMemberAccess	p -> TrackingResult
>171	Identifier	TrackingResult
>172	Identifier	p
>173	PtrMemberAccess	p -> InitialTransformation
>174	Identifier	InitialTransformation
>175	Identifier	p
>176	IdentifierDeclStatement	 
>177	IdentifierDecl	& p = * proposal_it
>178	AssignmentExpr	& p = * proposal_it
>179	UnaryOp	* proposal_it
>180	Identifier	proposal_it
>181	UnaryOperator	*
>182	Identifier	p
>183	Identifier	p
>184	IdentifierDeclType	ConstraintProposalPtr &
>185	UnaryExpression	 
>186	Identifier	proposal_it
>187	IncDec	++
>188	Condition	 
>189	EqualityExpression	proposal_it != proposals . end ( )
>190	CallExpression	proposals . end ( )
>191	ArgumentList	 
>192	Callee	proposals . end
>193	MemberAccess	proposals . end
>194	Identifier	end
>195	Identifier	proposals
>196	Identifier	proposal_it
>197	ForInit	 
>198	IdentifierDeclStatement	ConstraintProposalVector 
>199	IdentifierDecl	proposal_it = proposals . begin ( )
>200	AssignmentExpr	proposal_it = proposals . begin ( )
>201	CallExpression	proposals . begin ( )
>202	ArgumentList	 
>203	Callee	proposals . begin
>204	MemberAccess	proposals . begin
>205	Identifier	begin
>206	Identifier	proposals
>207	Identifier	proposal_it
>208	Identifier	proposal_it
>209	IdentifierDeclType	ConstraintProposalVector 
>210	IfStatement	if ( it -> OnlyKeepBest )
>211	ExpressionStatement	 
>212	CallExpression	keepBest ( proposals )
>213	ArgumentList	proposals
>214	Argument	proposals
>215	Identifier	proposals
>216	Callee	keepBest
>217	Identifier	keepBest
>218	Condition	 
>219	PtrMemberAccess	it -> OnlyKeepBest
>220	Identifier	OnlyKeepBest
>221	Identifier	it
>222	ExpressionStatement	 
>223	CallExpression	proposals . erase ( std 
>224	ArgumentList	std 
>225	Argument	proposals . end ( )
>226	CallExpression	proposals . end ( )
>227	ArgumentList	 
>228	Callee	proposals . end
>229	MemberAccess	proposals . end
>230	Identifier	end
>231	Identifier	proposals
>232	Argument	std 
>233	CallExpression	std 
>234	ArgumentList	proposals . begin ( )
>235	Argument	boost 
>236	CallExpression	boost 
>237	ArgumentList	& ConstraintProposal 
>238	Argument	_1
>239	Identifier	_1
>240	Argument	& ConstraintProposal 
>241	UnaryOp	& ConstraintProposal 
>242	Identifier	ConstraintProposal 
>243	UnaryOperator	&
>244	Callee	boost 
>245	Identifier	boost 
>246	Argument	proposals . end ( )
>247	CallExpression	proposals . end ( )
>248	ArgumentList	 
>249	Callee	proposals . end
>250	MemberAccess	proposals . end
>251	Identifier	end
>252	Identifier	proposals
>253	Argument	proposals . begin ( )
>254	CallExpression	proposals . begin ( )
>255	ArgumentList	 
>256	Callee	proposals . begin
>257	MemberAccess	proposals . begin
>258	Identifier	begin
>259	Identifier	proposals
>260	Callee	std 
>261	Identifier	std 
>262	Callee	proposals . erase
>263	MemberAccess	proposals . erase
>264	Identifier	erase
>265	Identifier	proposals
>266	IfStatement	if ( debug )
>267	ExpressionStatement	 
>268	CallExpression	printVotingResults ( * it , proposals )
>269	ArgumentList	* it
>270	Argument	proposals
>271	Identifier	proposals
>272	Argument	* it
>273	UnaryOp	* it
>274	Identifier	it
>275	UnaryOperator	*
>276	Callee	printVotingResults
>277	Identifier	printVotingResults
>278	Condition	 
>279	Identifier	debug
>280	ExpressionStatement	 
>281	CallExpression	validate ( * it , proposals , debug )
>282	ArgumentList	* it
>283	Argument	debug
>284	Identifier	debug
>285	Argument	proposals
>286	Identifier	proposals
>287	Argument	* it
>288	UnaryOp	* it
>289	Identifier	it
>290	UnaryOperator	*
>291	Callee	validate
>292	Identifier	validate
>293	ForStatement	for ( ConstraintProposalVector 
>294	CompoundStatement	 
>295	ExpressionStatement	 
>296	CallExpression	p -> TrackingResult . clearStatistics ( )
>297	ArgumentList	 
>298	Callee	p -> TrackingResult . clearStatistics
>299	MemberAccess	p -> TrackingResult . clearStatistics
>300	Identifier	clearStatistics
>301	PtrMemberAccess	p -> TrackingResult
>302	Identifier	TrackingResult
>303	Identifier	p
>304	ExpressionStatement	 
>305	CallExpression	p -> clearVotes ( )
>306	ArgumentList	 
>307	Callee	p -> clearVotes
>308	PtrMemberAccess	p -> clearVotes
>309	Identifier	clearVotes
>310	Identifier	p
>311	IdentifierDeclStatement	 
>312	IdentifierDecl	& p = * proposal_it
>313	AssignmentExpr	& p = * proposal_it
>314	UnaryOp	* proposal_it
>315	Identifier	proposal_it
>316	UnaryOperator	*
>317	Identifier	p
>318	Identifier	p
>319	IdentifierDeclType	ConstraintProposalPtr &
>320	UnaryExpression	 
>321	Identifier	proposal_it
>322	IncDec	++
>323	Condition	 
>324	EqualityExpression	proposal_it != proposals . end ( )
>325	CallExpression	proposals . end ( )
>326	ArgumentList	 
>327	Callee	proposals . end
>328	MemberAccess	proposals . end
>329	Identifier	end
>330	Identifier	proposals
>331	Identifier	proposal_it
>332	ForInit	 
>333	IdentifierDeclStatement	ConstraintProposalVector 
>334	IdentifierDecl	proposal_it = proposals . begin ( )
>335	AssignmentExpr	proposal_it = proposals . begin ( )
>336	CallExpression	proposals . begin ( )
>337	ArgumentList	 
>338	Callee	proposals . begin
>339	MemberAccess	proposals . begin
>340	Identifier	begin
>341	Identifier	proposals
>342	Identifier	proposal_it
>343	Identifier	proposal_it
>344	IdentifierDeclType	ConstraintProposalVector 
>345	UnaryExpression	 
>346	Identifier	it
>347	IncDec	++
>348	Condition	 
>349	EqualityExpression	it != stages_ . end ( )
>350	CallExpression	stages_ . end ( )
>351	ArgumentList	 
>352	Callee	stages_ . end
>353	MemberAccess	stages_ . end
>354	Identifier	end
>355	Identifier	stages_
>356	Identifier	it
>357	ForInit	 
>358	IdentifierDeclStatement	StageVector 
>359	IdentifierDecl	it = stages_ . begin ( )
>360	AssignmentExpr	it = stages_ . begin ( )
>361	CallExpression	stages_ . begin ( )
>362	ArgumentList	 
>363	Callee	stages_ . begin
>364	MemberAccess	stages_ . begin
>365	Identifier	begin
>366	Identifier	stages_
>367	Identifier	it
>368	Identifier	it
>369	IdentifierDeclType	StageVector 
>395	FunctionDef	ConstraintProposalValidator 
>396	ParameterList	ConstraintProposalVector & proposals
>397	Parameter	 
>398	Identifier	proposals
>399	ParameterType	ConstraintProposalVector &
>400	ReturnType	void
>401	CompoundStatement	 
>402	ForStatement	for ( ConstraintProposalVector 
>403	CompoundStatement	 
>404	ForStatement	for ( ConstraintProposalVector 
>405	CompoundStatement	 
>406	IfStatement	if ( p -> isConstraintBetweenSameFrames ( * inner_p ) )
>407	ElseStatement	else
>408	CompoundStatement	 
>409	ExpressionStatement	 
>410	UnaryExpression	++ inner_it
>411	Identifier	inner_it
>412	IncDec	++
>413	CompoundStatement	 
>414	ExpressionStatement	 
>415	AssignmentExpr	inner_it = proposals . erase ( inner_it )
>416	CallExpression	proposals . erase ( inner_it )
>417	ArgumentList	inner_it
>418	Argument	inner_it
>419	Identifier	inner_it
>420	Callee	proposals . erase
>421	MemberAccess	proposals . erase
>422	Identifier	erase
>423	Identifier	proposals
>424	Identifier	inner_it
>425	IfStatement	if ( inner_p -> TotalScore ( ) > p -> TotalScore ( ) )
>426	CompoundStatement	 
>427	ExpressionStatement	 
>428	CallExpression	p . swap ( inner_p )
>429	ArgumentList	inner_p
>430	Argument	inner_p
>431	Identifier	inner_p
>432	Callee	p . swap
>433	MemberAccess	p . swap
>434	Identifier	swap
>435	Identifier	p
>436	Condition	 
>437	RelationalExpression	inner_p -> TotalScore ( ) > p -> TotalScore ( )
>438	CallExpression	p -> TotalScore ( )
>439	ArgumentList	 
>440	Callee	p -> TotalScore
>441	PtrMemberAccess	p -> TotalScore
>442	Identifier	TotalScore
>443	Identifier	p
>444	CallExpression	inner_p -> TotalScore ( )
>445	ArgumentList	 
>446	Callee	inner_p -> TotalScore
>447	PtrMemberAccess	inner_p -> TotalScore
>448	Identifier	TotalScore
>449	Identifier	inner_p
>450	Condition	 
>451	CallExpression	p -> isConstraintBetweenSameFrames ( * inner_p )
>452	ArgumentList	* inner_p
>453	Argument	* inner_p
>454	UnaryOp	* inner_p
>455	Identifier	inner_p
>456	UnaryOperator	*
>457	Callee	p -> isConstraintBetweenSameFrames
>458	PtrMemberAccess	p -> isConstraintBetweenSameFrames
>459	Identifier	isConstraintBetweenSameFrames
>460	Identifier	p
>461	IdentifierDeclStatement	 
>462	IdentifierDecl	& inner_p = * inner_it
>463	AssignmentExpr	& inner_p = * inner_it
>464	UnaryOp	* inner_it
>465	Identifier	inner_it
>466	UnaryOperator	*
>467	Identifier	inner_p
>468	Identifier	inner_p
>469	IdentifierDeclType	ConstraintProposalPtr &
>470	Condition	 
>471	EqualityExpression	inner_it != proposals . end ( )
>472	CallExpression	proposals . end ( )
>473	ArgumentList	 
>474	Callee	proposals . end
>475	MemberAccess	proposals . end
>476	Identifier	end
>477	Identifier	proposals
>478	Identifier	inner_it
>479	ForInit	 
>480	IdentifierDeclStatement	ConstraintProposalVector 
>481	IdentifierDecl	inner_it = it + 1
>482	AssignmentExpr	inner_it = it + 1
>483	AdditiveExpression	it + 1
>484	PrimaryExpression	1
>485	Identifier	it
>486	Identifier	inner_it
>487	Identifier	inner_it
>488	IdentifierDeclType	ConstraintProposalVector 
>489	IdentifierDeclStatement	 
>490	IdentifierDecl	& p = * it
>491	AssignmentExpr	& p = * it
>492	UnaryOp	* it
>493	Identifier	it
>494	UnaryOperator	*
>495	Identifier	p
>496	Identifier	p
>497	IdentifierDeclType	ConstraintProposalPtr &
>498	UnaryExpression	 
>499	Identifier	it
>500	IncDec	++
>501	Condition	 
>502	EqualityExpression	it != proposals . end ( )
>503	CallExpression	proposals . end ( )
>504	ArgumentList	 
>505	Callee	proposals . end
>506	MemberAccess	proposals . end
>507	Identifier	end
>508	Identifier	proposals
>509	Identifier	it
>510	ForInit	 
>511	IdentifierDeclStatement	ConstraintProposalVector 
>512	IdentifierDecl	it = proposals . begin ( )
>513	AssignmentExpr	it = proposals . begin ( )
>514	CallExpression	proposals . begin ( )
>515	ArgumentList	 
>516	Callee	proposals . begin
>517	MemberAccess	proposals . begin
>518	Identifier	begin
>519	Identifier	proposals
>520	Identifier	it
>521	Identifier	it
>522	IdentifierDeclType	ConstraintProposalVector 
>541	FunctionDef	ConstraintProposalValidator 
>542	ParameterList	Stage & stage , ConstraintProposalVector & proposals , bool debug
>543	Parameter	 
>544	Identifier	debug
>545	ParameterType	bool
>546	Parameter	 
>547	Identifier	proposals
>548	ParameterType	ConstraintProposalVector &
>549	Parameter	 
>550	Identifier	stage
>551	ParameterType	Stage &
>552	ReturnType	void
>553	CompoundStatement	 
>554	ForStatement	for ( ConstraintProposalVoterVector 
>555	ExpressionStatement	 
>556	CallExpression	( * it ) -> removeAdditionalProposals ( proposals )
>557	ArgumentList	proposals
>558	Argument	proposals
>559	Identifier	proposals
>560	Callee	( * it ) -> removeAdditionalProposals
>561	PtrMemberAccess	( * it ) -> removeAdditionalProposals
>562	Identifier	removeAdditionalProposals
>563	UnaryOp	* it
>564	Identifier	it
>565	UnaryOperator	*
>566	UnaryExpression	 
>567	Identifier	it
>568	IncDec	++
>569	Condition	 
>570	EqualityExpression	it != stage . Voters . rend ( )
>571	CallExpression	stage . Voters . rend ( )
>572	ArgumentList	 
>573	Callee	stage . Voters . rend
>574	MemberAccess	stage . Voters . rend
>575	Identifier	rend
>576	MemberAccess	stage . Voters
>577	Identifier	Voters
>578	Identifier	stage
>579	Identifier	it
>580	ForInit	 
>581	IdentifierDeclStatement	ConstraintProposalVoterVector 
>582	IdentifierDecl	it = stage . Voters . rbegin ( )
>583	AssignmentExpr	it = stage . Voters . rbegin ( )
>584	CallExpression	stage . Voters . rbegin ( )
>585	ArgumentList	 
>586	Callee	stage . Voters . rbegin
>587	MemberAccess	stage . Voters . rbegin
>588	Identifier	rbegin
>589	MemberAccess	stage . Voters
>590	Identifier	Voters
>591	Identifier	stage
>592	Identifier	it
>593	Identifier	it
>594	IdentifierDeclType	ConstraintProposalVoterVector 
>595	ForStatement	for ( ConstraintProposalVector 
>596	CompoundStatement	 
>597	ForStatement	for ( ConstraintProposalVoterVector 
>598	CompoundStatement	 
>599	IfStatement	if ( p . Votes . back ( ) . Decision == ConstraintProposal 
>600	BreakStatement	 
>601	Condition	 
>602	AndExpression	p . Votes . back ( ) . Decision == ConstraintProposal 
>603	UnaryOp	! debug
>604	Identifier	debug
>605	UnaryOperator	!
>606	EqualityExpression	p . Votes . back ( ) . Decision == ConstraintProposal 
>607	Identifier	ConstraintProposal 
>608	MemberAccess	p . Votes . back ( ) . Decision
>609	Identifier	Decision
>610	CallExpression	p . Votes . back ( )
>611	ArgumentList	 
>612	Callee	p . Votes . back
>613	MemberAccess	p . Votes . back
>614	Identifier	back
>615	MemberAccess	p . Votes
>616	Identifier	Votes
>617	Identifier	p
>618	ExpressionStatement	 
>619	CallExpression	p . Votes . push_back ( ( * voter_it ) -> vote ( p , debug ) )
>620	ArgumentList	( * voter_it ) -> vote ( p , debug )
>621	Argument	( * voter_it ) -> vote ( p , debug )
>622	CallExpression	( * voter_it ) -> vote ( p , debug )
>623	ArgumentList	p
>624	Argument	debug
>625	Identifier	debug
>626	Argument	p
>627	Identifier	p
>628	Callee	( * voter_it ) -> vote
>629	PtrMemberAccess	( * voter_it ) -> vote
>630	Identifier	vote
>631	UnaryOp	* voter_it
>632	Identifier	voter_it
>633	UnaryOperator	*
>634	Callee	p . Votes . push_back
>635	MemberAccess	p . Votes . push_back
>636	Identifier	push_back
>637	MemberAccess	p . Votes
>638	Identifier	Votes
>639	Identifier	p
>640	UnaryExpression	 
>641	Identifier	voter_it
>642	IncDec	++
>643	Condition	 
>644	EqualityExpression	voter_it != stage . Voters . end ( )
>645	CallExpression	stage . Voters . end ( )
>646	ArgumentList	 
>647	Callee	stage . Voters . end
>648	MemberAccess	stage . Voters . end
>649	Identifier	end
>650	MemberAccess	stage . Voters
>651	Identifier	Voters
>652	Identifier	stage
>653	Identifier	voter_it
>654	ForInit	 
>655	IdentifierDeclStatement	ConstraintProposalVoterVector 
>656	IdentifierDecl	voter_it = stage . Voters . begin ( )
>657	AssignmentExpr	voter_it = stage . Voters . begin ( )
>658	CallExpression	stage . Voters . begin ( )
>659	ArgumentList	 
>660	Callee	stage . Voters . begin
>661	MemberAccess	stage . Voters . begin
>662	Identifier	begin
>663	MemberAccess	stage . Voters
>664	Identifier	Voters
>665	Identifier	stage
>666	Identifier	voter_it
>667	Identifier	voter_it
>668	IdentifierDeclType	ConstraintProposalVoterVector 
>669	IdentifierDeclStatement	 
>670	IdentifierDecl	& p = * ( * it )
>671	AssignmentExpr	& p = * ( * it )
>672	UnaryOp	* ( * it )
>673	UnaryOp	* it
>674	Identifier	it
>675	UnaryOperator	*
>676	UnaryOperator	*
>677	Identifier	p
>678	Identifier	p
>679	IdentifierDeclType	ConstraintProposal &
>680	UnaryExpression	 
>681	Identifier	it
>682	IncDec	++
>683	Condition	 
>684	EqualityExpression	it != proposals . end ( )
>685	CallExpression	proposals . end ( )
>686	ArgumentList	 
>687	Callee	proposals . end
>688	MemberAccess	proposals . end
>689	Identifier	end
>690	Identifier	proposals
>691	Identifier	it
>692	ForInit	 
>693	IdentifierDeclStatement	ConstraintProposalVector 
>694	IdentifierDecl	it = proposals . begin ( )
>695	AssignmentExpr	it = proposals . begin ( )
>696	CallExpression	proposals . begin ( )
>697	ArgumentList	 
>698	Callee	proposals . begin
>699	MemberAccess	proposals . begin
>700	Identifier	begin
>701	Identifier	proposals
>702	Identifier	it
>703	Identifier	it
>704	IdentifierDeclType	ConstraintProposalVector 
>705	ForStatement	for ( ConstraintProposalVector 
>706	CompoundStatement	 
>707	ExpressionStatement	 
>708	CallExpression	tracker_ . match ( * p -> Reference -> image ( ) , * p -> Current -> image ( ) , p -> TrackingResult )
>709	ArgumentList	* p -> Reference -> image ( )
>710	Argument	p -> TrackingResult
>711	PtrMemberAccess	p -> TrackingResult
>712	Identifier	TrackingResult
>713	Identifier	p
>714	Argument	* p -> Current -> image ( )
>715	UnaryOp	* p -> Current -> image ( )
>716	CallExpression	p -> Current -> image ( )
>717	ArgumentList	 
>718	Callee	p -> Current -> image
>719	PtrMemberAccess	p -> Current -> image
>720	Identifier	image
>721	PtrMemberAccess	p -> Current
>722	Identifier	Current
>723	Identifier	p
>724	UnaryOperator	*
>725	Argument	* p -> Reference -> image ( )
>726	UnaryOp	* p -> Reference -> image ( )
>727	CallExpression	p -> Reference -> image ( )
>728	ArgumentList	 
>729	Callee	p -> Reference -> image
>730	PtrMemberAccess	p -> Reference -> image
>731	Identifier	image
>732	PtrMemberAccess	p -> Reference
>733	Identifier	Reference
>734	Identifier	p
>735	UnaryOperator	*
>736	Callee	tracker_ . match
>737	MemberAccess	tracker_ . match
>738	Identifier	match
>739	Identifier	tracker_
>740	ExpressionStatement	 
>741	AssignmentExpr	p -> TrackingResult . Transformation = p -> InitialTransformation
>742	PtrMemberAccess	p -> InitialTransformation
>743	Identifier	InitialTransformation
>744	Identifier	p
>745	MemberAccess	p -> TrackingResult . Transformation
>746	Identifier	Transformation
>747	PtrMemberAccess	p -> TrackingResult
>748	Identifier	TrackingResult
>749	Identifier	p
>750	IdentifierDeclStatement	 
>751	IdentifierDecl	& p = ( * it )
>752	AssignmentExpr	& p = ( * it )
>753	UnaryOp	* it
>754	Identifier	it
>755	UnaryOperator	*
>756	Identifier	p
>757	Identifier	p
>758	IdentifierDeclType	ConstraintProposalPtr &
>759	UnaryExpression	 
>760	Identifier	it
>761	IncDec	++
>762	Condition	 
>763	EqualityExpression	it != proposals . end ( )
>764	CallExpression	proposals . end ( )
>765	ArgumentList	 
>766	Callee	proposals . end
>767	MemberAccess	proposals . end
>768	Identifier	end
>769	Identifier	proposals
>770	Identifier	it
>771	ForInit	 
>772	IdentifierDeclStatement	ConstraintProposalVector 
>773	IdentifierDecl	it = proposals . begin ( )
>774	AssignmentExpr	it = proposals . begin ( )
>775	CallExpression	proposals . begin ( )
>776	ArgumentList	 
>777	Callee	proposals . begin
>778	MemberAccess	proposals . begin
>779	Identifier	begin
>780	Identifier	proposals
>781	Identifier	it
>782	Identifier	it
>783	IdentifierDeclType	ConstraintProposalVector 
>784	ForStatement	for ( ConstraintProposalVoterVector 
>785	ExpressionStatement	 
>786	CallExpression	( * it ) -> createAdditionalProposals ( proposals )
>787	ArgumentList	proposals
>788	Argument	proposals
>789	Identifier	proposals
>790	Callee	( * it ) -> createAdditionalProposals
>791	PtrMemberAccess	( * it ) -> createAdditionalProposals
>792	Identifier	createAdditionalProposals
>793	UnaryOp	* it
>794	Identifier	it
>795	UnaryOperator	*
>796	UnaryExpression	 
>797	Identifier	it
>798	IncDec	++
>799	Condition	 
>800	EqualityExpression	it != stage . Voters . end ( )
>801	CallExpression	stage . Voters . end ( )
>802	ArgumentList	 
>803	Callee	stage . Voters . end
>804	MemberAccess	stage . Voters . end
>805	Identifier	end
>806	MemberAccess	stage . Voters
>807	Identifier	Voters
>808	Identifier	stage
>809	Identifier	it
>810	ForInit	 
>811	IdentifierDeclStatement	ConstraintProposalVoterVector 
>812	IdentifierDecl	it = stage . Voters . begin ( )
>813	AssignmentExpr	it = stage . Voters . begin ( )
>814	CallExpression	stage . Voters . begin ( )
>815	ArgumentList	 
>816	Callee	stage . Voters . begin
>817	MemberAccess	stage . Voters . begin
>818	Identifier	begin
>819	MemberAccess	stage . Voters
>820	Identifier	Voters
>821	Identifier	stage
>822	Identifier	it
>823	Identifier	it
>824	IdentifierDeclType	ConstraintProposalVoterVector 
>825	ExpressionStatement	 
>826	CallExpression	tracker_ . configure ( stage . TrackingConfig )
>827	ArgumentList	stage . TrackingConfig
>828	Argument	stage . TrackingConfig
>829	MemberAccess	stage . TrackingConfig
>830	Identifier	TrackingConfig
>831	Identifier	stage
>832	Callee	tracker_ . configure
>833	MemberAccess	tracker_ . configure
>834	Identifier	configure
>835	Identifier	tracker_
>882	FunctionDef	ConstraintProposalValidator 
>883	ParameterList	const Stage & stage , const ConstraintProposalVector & proposals
>884	Parameter	 
>885	Identifier	proposals
>886	ParameterType	const ConstraintProposalVector &
>887	Parameter	 
>888	Identifier	stage
>889	ParameterType	const Stage &
>890	ReturnType	void
>891	CompoundStatement	 
>892	ForStatement	for ( ConstraintProposalVector 
>893	ExpressionStatement	 
>894	CallExpression	( * it ) -> printVotingResults ( std 
>895	ArgumentList	std 
>896	Argument	\"  \"
>897	PrimaryExpression	\"  \"
>898	Argument	std 
>899	Identifier	std 
>900	Callee	( * it ) -> printVotingResults
>901	PtrMemberAccess	( * it ) -> printVotingResults
>902	Identifier	printVotingResults
>903	UnaryOp	* it
>904	Identifier	it
>905	UnaryOperator	*
>906	UnaryExpression	 
>907	Identifier	it
>908	IncDec	++
>909	Condition	 
>910	EqualityExpression	it != proposals . end ( )
>911	CallExpression	proposals . end ( )
>912	ArgumentList	 
>913	Callee	proposals . end
>914	MemberAccess	proposals . end
>915	Identifier	end
>916	Identifier	proposals
>917	Identifier	it
>918	ForInit	 
>919	IdentifierDeclStatement	ConstraintProposalVector 
>920	IdentifierDecl	it = proposals . begin ( )
>921	AssignmentExpr	it = proposals . begin ( )
>922	CallExpression	proposals . begin ( )
>923	ArgumentList	 
>924	Callee	proposals . begin
>925	MemberAccess	proposals . begin
>926	Identifier	begin
>927	Identifier	proposals
>928	Identifier	it
>929	Identifier	it
>930	IdentifierDeclType	ConstraintProposalVector 
>931	ExpressionStatement	 
>932	ShiftExpression	std 
>933	ShiftExpression	\"Stage \" << stage . Id << \"
>934	ShiftExpression	stage . Id << \"
>935	ShiftExpression	\"
>936	Identifier	std 
>937	PrimaryExpression	\"
>938	MemberAccess	stage . Id
>939	Identifier	Id
>940	Identifier	stage
>941	PrimaryExpression	\"Stage \"
>942	Identifier	std 
<3=8,4
<4=5
<5=7,6
<13=16,15,14
<16=21,17
<17=18
<18=20,19
<21=22
<22=24,23
<32=35,34,33
<35=40,36
<36=37
<37=39,38
<40=41
<41=43,42
<51=57,56,52
<52=53
<53=55,54
<57=62,58
<58=59
<59=61,60
<62=63
<63=65,64
<73=79,78,74
<74=75
<75=77,76
<79=84,80
<80=81
<81=83,82
<84=85
<85=94,86
<86=87
<87=88
<88=92,89
<89=90
<90=91
<92=93
<94=95
<95=97,96
<106=108,107
<112=118,117,113
<113=114
<114=116,115
<118=126,119
<119=120
<120=122,121
<122=123
<123=125,124
<126=127
<127=136,128
<128=129
<129=130
<130=134,131
<131=132
<132=133
<134=135
<136=137
<137=139,138
<147=156,155,148
<148=152,149
<149=151,150
<152=154,153
<156=157
<157=357,348,345,158
<158=293,280,266,222,210,159
<159=197,188,185,160
<160=176,161
<161=162
<162=173,163
<163=165,164
<165=166
<166=168,167
<168=170,169
<170=172,171
<173=175,174
<176=177
<177=184,183,178
<178=182,179
<179=181,180
<185=187,186
<188=189
<189=196,190
<190=192,191
<192=193
<193=195,194
<197=198
<198=199
<199=209,208,200
<200=207,201
<201=203,202
<203=204
<204=206,205
<210=218,211
<211=212
<212=216,213
<213=214
<214=215
<216=217
<218=219
<219=221,220
<222=223
<223=262,224
<224=232,225
<225=226
<226=228,227
<228=229
<229=231,230
<232=233
<233=260,234
<234=253,246,235
<235=236
<236=244,237
<237=240,238
<238=239
<240=241
<241=243,242
<244=245
<246=247
<247=249,248
<249=250
<250=252,251
<253=254
<254=256,255
<256=257
<257=259,258
<260=261
<262=263
<263=265,264
<266=278,267
<267=268
<268=276,269
<269=272,270
<270=271
<272=273
<273=275,274
<276=277
<278=279
<280=281
<281=291,282
<282=287,285,283
<283=284
<285=286
<287=288
<288=290,289
<291=292
<293=332,323,320,294
<294=311,304,295
<295=296
<296=298,297
<298=299
<299=301,300
<301=303,302
<304=305
<305=307,306
<307=308
<308=310,309
<311=312
<312=319,318,313
<313=317,314
<314=316,315
<320=322,321
<323=324
<324=331,325
<325=327,326
<327=328
<328=330,329
<332=333
<333=334
<334=344,343,335
<335=342,336
<336=338,337
<338=339
<339=341,340
<345=347,346
<348=349
<349=356,350
<350=352,351
<352=353
<353=355,354
<357=358
<358=359
<359=369,368,360
<360=367,361
<361=363,362
<363=364
<364=366,365
<395=401,400,396
<396=397
<397=399,398
<401=402
<402=510,501,498,403
<403=489,404
<404=479,470,405
<405=461,406
<406=450,413,407
<407=408
<408=409
<409=410
<410=412,411
<413=425,414
<414=415
<415=424,416
<416=420,417
<417=418
<418=419
<420=421
<421=423,422
<425=436,426
<426=427
<427=428
<428=432,429
<429=430
<430=431
<432=433
<433=435,434
<436=437
<437=444,438
<438=440,439
<440=441
<441=443,442
<444=446,445
<446=447
<447=449,448
<450=451
<451=457,452
<452=453
<453=454
<454=456,455
<457=458
<458=460,459
<461=462
<462=469,468,463
<463=467,464
<464=466,465
<470=471
<471=478,472
<472=474,473
<474=475
<475=477,476
<479=480
<480=481
<481=488,487,482
<482=486,483
<483=485,484
<489=490
<490=497,496,491
<491=495,492
<492=494,493
<498=500,499
<501=502
<502=509,503
<503=505,504
<505=506
<506=508,507
<510=511
<511=512
<512=522,521,513
<513=520,514
<514=516,515
<516=517
<517=519,518
<541=553,552,542
<542=549,546,543
<543=545,544
<546=548,547
<549=551,550
<553=825,784,705,595,554
<554=580,569,566,555
<555=556
<556=560,557
<557=558
<558=559
<560=561
<561=563,562
<563=565,564
<566=568,567
<569=570
<570=579,571
<571=573,572
<573=574
<574=576,575
<576=578,577
<580=581
<581=582
<582=594,593,583
<583=592,584
<584=586,585
<586=587
<587=589,588
<589=591,590
<595=692,683,680,596
<596=669,597
<597=654,643,640,598
<598=618,599
<599=601,600
<601=602
<602=606,603
<603=605,604
<606=608,607
<608=610,609
<610=612,611
<612=613
<613=615,614
<615=617,616
<618=619
<619=634,620
<620=621
<621=622
<622=628,623
<623=626,624
<624=625
<626=627
<628=629
<629=631,630
<631=633,632
<634=635
<635=637,636
<637=639,638
<640=642,641
<643=644
<644=653,645
<645=647,646
<647=648
<648=650,649
<650=652,651
<654=655
<655=656
<656=668,667,657
<657=666,658
<658=660,659
<660=661
<661=663,662
<663=665,664
<669=670
<670=679,678,671
<671=677,672
<672=676,673
<673=675,674
<680=682,681
<683=684
<684=691,685
<685=687,686
<687=688
<688=690,689
<692=693
<693=694
<694=704,703,695
<695=702,696
<696=698,697
<698=699
<699=701,700
<705=771,762,759,706
<706=750,740,707
<707=708
<708=736,709
<709=725,714,710
<710=711
<711=713,712
<714=715
<715=724,716
<716=718,717
<718=719
<719=721,720
<721=723,722
<725=726
<726=735,727
<727=729,728
<729=730
<730=732,731
<732=734,733
<736=737
<737=739,738
<740=741
<741=745,742
<742=744,743
<745=747,746
<747=749,748
<750=751
<751=758,757,752
<752=756,753
<753=755,754
<759=761,760
<762=763
<763=770,764
<764=766,765
<766=767
<767=769,768
<771=772
<772=773
<773=783,782,774
<774=781,775
<775=777,776
<777=778
<778=780,779
<784=810,799,796,785
<785=786
<786=790,787
<787=788
<788=789
<790=791
<791=793,792
<793=795,794
<796=798,797
<799=800
<800=809,801
<801=803,802
<803=804
<804=806,805
<806=808,807
<810=811
<811=812
<812=824,823,813
<813=822,814
<814=816,815
<816=817
<817=819,818
<819=821,820
<825=826
<826=832,827
<827=828
<828=829
<829=831,830
<832=833
<833=835,834
<882=891,890,883
<883=887,884
<884=886,885
<887=889,888
<891=931,892
<892=918,909,906,893
<893=894
<894=900,895
<895=898,896
<896=897
<898=899
<900=901
<901=903,902
<903=905,904
<906=908,907
<909=910
<910=917,911
<911=913,912
<913=914
<914=916,915
<918=919
<919=920
<920=930,929,921
<921=928,922
<922=924,923
<924=925
<925=927,926
<931=932
<932=942,933
<933=941,934
<934=938,935
<935=937,936
<938=940,939
