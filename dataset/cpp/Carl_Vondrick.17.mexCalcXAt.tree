>3	FunctionDef	callFunction (mxArray * plhs [ ] , const mxArray * prhs [ ])
>4	ParameterList	mxArray * plhs [ ] , const mxArray * prhs [ ]
>5	Parameter	 
>6	Identifier	prhs
>7	ParameterType	const mxArray * [ ]
>8	Parameter	 
>9	Identifier	plhs
>10	ParameterType	mxArray * [ ]
>11	ReturnType	inline void
>12	CompoundStatement	 
>13	ExpressionStatement	 
>14	RelationalExpression	deleteCopySparse < T > ( alpha_v2 , alpha_r2 , alpha_pB2 , alpha_pE2 , alpha_v , alpha_r )
>15	RelationalExpression	T > ( alpha_v2 , alpha_r2 , alpha_pB2 , alpha_pE2 , alpha_v , alpha_r )
>16	Expression	alpha_v2 , alpha_r2 , alpha_pB2 , alpha_pE2 , alpha_v , alpha_r
>17	Expression	alpha_r2 , alpha_pB2 , alpha_pE2 , alpha_v , alpha_r
>18	Expression	alpha_pB2 , alpha_pE2 , alpha_v , alpha_r
>19	Expression	alpha_pE2 , alpha_v , alpha_r
>20	Expression	alpha_v , alpha_r
>21	Identifier	alpha_r
>22	Identifier	alpha_v
>23	Identifier	alpha_pE2
>24	Identifier	alpha_pB2
>25	Identifier	alpha_r2
>26	Identifier	alpha_v2
>27	Identifier	T
>28	Identifier	deleteCopySparse
>29	ExpressionStatement	 
>30	CallExpression	alpha . XAt ( X , Xat )
>31	ArgumentList	X
>32	Argument	Xat
>33	Identifier	Xat
>34	Argument	X
>35	Identifier	X
>36	Callee	alpha . XAt
>37	MemberAccess	alpha . XAt
>38	Identifier	XAt
>39	Identifier	alpha
>40	IdentifierDeclStatement	 
>41	IdentifierDecl	alpha ( alpha_v2 , alpha_r2 , alpha_pB2 , alpha_pE2 , K , M , alpha_pB2 [ M ] )
>42	Expression	alpha_v2 , alpha_r2 , alpha_pB2 , alpha_pE2 , K , M , alpha_pB2 [ M ]
>43	Expression	alpha_r2 , alpha_pB2 , alpha_pE2 , K , M , alpha_pB2 [ M ]
>44	Expression	alpha_pB2 , alpha_pE2 , K , M , alpha_pB2 [ M ]
>45	Expression	alpha_pE2 , K , M , alpha_pB2 [ M ]
>46	Expression	K , M , alpha_pB2 [ M ]
>47	Expression	M , alpha_pB2 [ M ]
>48	ArrayIndexing	alpha_pB2 [ M ]
>49	Identifier	M
>50	Identifier	alpha_pB2
>51	Identifier	M
>52	Identifier	K
>53	Identifier	alpha_pE2
>54	Identifier	alpha_pB2
>55	Identifier	alpha_r2
>56	Identifier	alpha_v2
>57	Identifier	alpha
>58	IdentifierDeclType	SpMatrix < T >
>59	IdentifierDeclStatement	 
>60	IdentifierDecl	X ( prX , n , M )
>61	Expression	prX , n , M
>62	Expression	n , M
>63	Identifier	M
>64	Identifier	n
>65	Identifier	prX
>66	Identifier	X
>67	IdentifierDeclType	Matrix < T >
>68	IdentifierDeclStatement	 
>69	IdentifierDecl	Xat ( prXat , n , K )
>70	Expression	prXat , n , K
>71	Expression	n , K
>72	Identifier	K
>73	Identifier	n
>74	Identifier	prXat
>75	Identifier	Xat
>76	IdentifierDeclType	Matrix < T >
>77	ExpressionStatement	 
>78	CallExpression	mxGetPr ( plhs [ 0 ] )
>79	ArgumentList	plhs [ 0 ]
>80	Argument	plhs [ 0 ]
>81	ArrayIndexing	plhs [ 0 ]
>82	PrimaryExpression	0
>83	Identifier	plhs
>84	Callee	mxGetPr
>85	Identifier	mxGetPr
>86	Statement	 
>87	Statement	 
>88	Statement	 
>89	Statement	 
>90	Statement	 
>91	Statement	 
>92	Statement	 
>93	Statement	 
>94	Statement	 
>95	ExpressionStatement	 
>96	AssignmentExpr	plhs [ 0 ] = createMatrix < T > ( n , K )
>97	RelationalExpression	createMatrix < T > ( n , K )
>98	RelationalExpression	T > ( n , K )
>99	Expression	n , K
>100	Identifier	K
>101	Identifier	n
>102	Identifier	T
>103	Identifier	createMatrix
>104	ArrayIndexing	plhs [ 0 ]
>105	PrimaryExpression	0
>106	Identifier	plhs
>107	ExpressionStatement	 
>108	RelationalExpression	createCopySparse < T > ( alpha_v2 , alpha_r2 , alpha_pB2 , alpha_pE2 , alpha_v , alpha_r , alpha_pB , \
>109	RelationalExpression	T > ( alpha_v2 , alpha_r2 , alpha_pB2 , alpha_pE2 , alpha_v , alpha_r , alpha_pB , alpha_pE , M )
>110	Expression	alpha_v2 , alpha_r2 , alpha_pB2 , alpha_pE2 , alpha_v , alpha_r , alpha_pB , alpha_pE , M
>111	Expression	alpha_r2 , alpha_pB2 , alpha_pE2 , alpha_v , alpha_r , alpha_pB , alpha_pE , M
>112	Expression	alpha_pB2 , alpha_pE2 , alpha_v , alpha_r , alpha_pB , alpha_pE , M
>113	Expression	alpha_pE2 , alpha_v , alpha_r , alpha_pB , alpha_pE , M
>114	Expression	alpha_v , alpha_r , alpha_pB , alpha_pE , M
>115	Expression	alpha_r , alpha_pB , alpha_pE , M
>116	Expression	alpha_pB , alpha_pE , M
>117	Expression	alpha_pE , M
>118	Identifier	M
>119	Identifier	alpha_pE
>120	Identifier	alpha_pB
>121	Identifier	alpha_r
>122	Identifier	alpha_v
>123	Identifier	alpha_pE2
>124	Identifier	alpha_pB2
>125	Identifier	alpha_r2
>126	Identifier	alpha_v2
>127	Identifier	T
>128	Identifier	createCopySparse
>129	IdentifierDeclStatement	 
>130	IdentifierDecl	* alpha_v2
>131	Identifier	alpha_v2
>132	IdentifierDeclType	T *
>133	IdentifierDeclStatement	 
>134	IdentifierDecl	* alpha_pE2
>135	Identifier	alpha_pE2
>136	IdentifierDeclType	long *
>137	IdentifierDecl	* alpha_pB2
>138	Identifier	alpha_pB2
>139	IdentifierDeclType	long *
>140	IdentifierDecl	* alpha_r2
>141	Identifier	alpha_r2
>142	IdentifierDeclType	long *
>143	IdentifierDeclStatement	 
>144	IdentifierDecl	* alpha_pE = alpha_pB + 1
>145	AssignmentExpr	* alpha_pE = alpha_pB + 1
>146	AdditiveExpression	alpha_pB + 1
>147	PrimaryExpression	1
>148	Identifier	alpha_pB
>149	Identifier	alpha_pE
>150	Identifier	alpha_pE
>151	IdentifierDeclType	mwSize *
>152	IdentifierDeclStatement	 
>153	IdentifierDecl	* alpha_pB = mxGetJc ( prhs [ 1 ] )
>154	AssignmentExpr	* alpha_pB = mxGetJc ( prhs [ 1 ] )
>155	CallExpression	mxGetJc ( prhs [ 1 ] )
>156	ArgumentList	prhs [ 1 ]
>157	Argument	prhs [ 1 ]
>158	ArrayIndexing	prhs [ 1 ]
>159	PrimaryExpression	1
>160	Identifier	prhs
>161	Callee	mxGetJc
>162	Identifier	mxGetJc
>163	Identifier	alpha_pB
>164	Identifier	alpha_pB
>165	IdentifierDeclType	mwSize *
>166	IdentifierDeclStatement	 
>167	IdentifierDecl	* alpha_r = mxGetIr ( prhs [ 1 ] )
>168	AssignmentExpr	* alpha_r = mxGetIr ( prhs [ 1 ] )
>169	CallExpression	mxGetIr ( prhs [ 1 ] )
>170	ArgumentList	prhs [ 1 ]
>171	Argument	prhs [ 1 ]
>172	ArrayIndexing	prhs [ 1 ]
>173	PrimaryExpression	1
>174	Identifier	prhs
>175	Callee	mxGetIr
>176	Identifier	mxGetIr
>177	Identifier	alpha_r
>178	Identifier	alpha_r
>179	IdentifierDeclType	mwSize *
>180	IfStatement	if ( M != M2 )
>181	ExpressionStatement	 
>182	CallExpression	mexErrMsgTxt ( \"argument sizes are not consistent\" )
>183	ArgumentList	\"argument sizes are not consistent\"
>184	Argument	\"argument sizes are not consistent\"
>185	PrimaryExpression	\"argument sizes are not consistent\"
>186	Callee	mexErrMsgTxt
>187	Identifier	mexErrMsgTxt
>188	Condition	 
>189	EqualityExpression	M != M2
>190	Identifier	M2
>191	Identifier	M
>192	ExpressionStatement	 
>193	ArrayIndexing	dims [ 1 ]
>194	PrimaryExpression	1
>195	Identifier	dims
>196	Statement	 
>197	Statement	 
>198	Statement	 
>199	Statement	 
>200	Statement	 
>201	Statement	 
>202	Statement	 
>203	ExpressionStatement	 
>204	ArrayIndexing	dims [ 0 ]
>205	PrimaryExpression	0
>206	Identifier	dims
>207	Statement	 
>208	Statement	 
>209	Statement	 
>210	Statement	 
>211	Statement	 
>212	Statement	 
>213	Statement	 
>214	IdentifierDeclStatement	 
>215	IdentifierDecl	* dims = mxGetDimensions ( prhs [ 1 ] )
>216	AssignmentExpr	* dims = mxGetDimensions ( prhs [ 1 ] )
>217	CallExpression	mxGetDimensions ( prhs [ 1 ] )
>218	ArgumentList	prhs [ 1 ]
>219	Argument	prhs [ 1 ]
>220	ArrayIndexing	prhs [ 1 ]
>221	PrimaryExpression	1
>222	Identifier	prhs
>223	Callee	mxGetDimensions
>224	Identifier	mxGetDimensions
>225	Identifier	dims
>226	Identifier	dims
>227	IdentifierDeclType	const mwSize *
>228	ExpressionStatement	 
>229	CallExpression	mxGetPr ( prhs [ 1 ] )
>230	ArgumentList	prhs [ 1 ]
>231	Argument	prhs [ 1 ]
>232	ArrayIndexing	prhs [ 1 ]
>233	PrimaryExpression	1
>234	Identifier	prhs
>235	Callee	mxGetPr
>236	Identifier	mxGetPr
>237	Statement	 
>238	Statement	 
>239	Statement	 
>240	Statement	 
>241	Statement	 
>242	Statement	 
>243	Statement	 
>244	Statement	 
>245	Statement	 
>246	ExpressionStatement	 
>247	ArrayIndexing	dimsX [ 1 ]
>248	PrimaryExpression	1
>249	Identifier	dimsX
>250	Statement	 
>251	Statement	 
>252	Statement	 
>253	Statement	 
>254	Statement	 
>255	Statement	 
>256	Statement	 
>257	ExpressionStatement	 
>258	ArrayIndexing	dimsX [ 0 ]
>259	PrimaryExpression	0
>260	Identifier	dimsX
>261	Statement	 
>262	Statement	 
>263	Statement	 
>264	Statement	 
>265	Statement	 
>266	Statement	 
>267	Statement	 
>268	IdentifierDeclStatement	 
>269	IdentifierDecl	* dimsX = mxGetDimensions ( prhs [ 0 ] )
>270	AssignmentExpr	* dimsX = mxGetDimensions ( prhs [ 0 ] )
>271	CallExpression	mxGetDimensions ( prhs [ 0 ] )
>272	ArgumentList	prhs [ 0 ]
>273	Argument	prhs [ 0 ]
>274	ArrayIndexing	prhs [ 0 ]
>275	PrimaryExpression	0
>276	Identifier	prhs
>277	Callee	mxGetDimensions
>278	Identifier	mxGetDimensions
>279	Identifier	dimsX
>280	Identifier	dimsX
>281	IdentifierDeclType	const mwSize *
>282	ExpressionStatement	 
>283	CallExpression	mxGetPr ( prhs [ 0 ] )
>284	ArgumentList	prhs [ 0 ]
>285	Argument	prhs [ 0 ]
>286	ArrayIndexing	prhs [ 0 ]
>287	PrimaryExpression	0
>288	Identifier	prhs
>289	Callee	mxGetPr
>290	Identifier	mxGetPr
>291	Statement	 
>292	Statement	 
>293	Statement	 
>294	Statement	 
>295	Statement	 
>296	Statement	 
>297	Statement	 
>298	Statement	 
>299	Statement	 
>300	IfStatement	if ( ! mxIsSparse ( prhs [ 1 ] ) )
>301	ExpressionStatement	 
>302	CallExpression	mexErrMsgTxt ( \"argument 2 should be sparse\" )
>303	ArgumentList	\"argument 2 should be sparse\"
>304	Argument	\"argument 2 should be sparse\"
>305	PrimaryExpression	\"argument 2 should be sparse\"
>306	Callee	mexErrMsgTxt
>307	Identifier	mexErrMsgTxt
>308	Condition	 
>309	UnaryOp	! mxIsSparse ( prhs [ 1 ] )
>310	CallExpression	mxIsSparse ( prhs [ 1 ] )
>311	ArgumentList	prhs [ 1 ]
>312	Argument	prhs [ 1 ]
>313	ArrayIndexing	prhs [ 1 ]
>314	PrimaryExpression	1
>315	Identifier	prhs
>316	Callee	mxIsSparse
>317	Identifier	mxIsSparse
>318	UnaryOperator	!
>319	IfStatement	if ( ! mexCheckType < T > ( prhs [ 1 ] ) )
>320	ExpressionStatement	 
>321	CallExpression	mexErrMsgTxt ( \"type of argument 2 is not consistent\" )
>322	ArgumentList	\"type of argument 2 is not consistent\"
>323	Argument	\"type of argument 2 is not consistent\"
>324	PrimaryExpression	\"type of argument 2 is not consistent\"
>325	Callee	mexErrMsgTxt
>326	Identifier	mexErrMsgTxt
>327	Condition	 
>328	RelationalExpression	! mexCheckType < T > ( prhs [ 1 ] )
>329	RelationalExpression	T > ( prhs [ 1 ] )
>330	ArrayIndexing	prhs [ 1 ]
>331	PrimaryExpression	1
>332	Identifier	prhs
>333	Identifier	T
>334	UnaryOp	! mexCheckType
>335	Identifier	mexCheckType
>336	UnaryOperator	!
>337	IfStatement	if ( mxIsSparse ( prhs [ 0 ] ) )
>338	ExpressionStatement	 
>339	CallExpression	mexErrMsgTxt ( \"argument 1 should be full\" )
>340	ArgumentList	\"argument 1 should be full\"
>341	Argument	\"argument 1 should be full\"
>342	PrimaryExpression	\"argument 1 should be full\"
>343	Callee	mexErrMsgTxt
>344	Identifier	mexErrMsgTxt
>345	Condition	 
>346	CallExpression	mxIsSparse ( prhs [ 0 ] )
>347	ArgumentList	prhs [ 0 ]
>348	Argument	prhs [ 0 ]
>349	ArrayIndexing	prhs [ 0 ]
>350	PrimaryExpression	0
>351	Identifier	prhs
>352	Callee	mxIsSparse
>353	Identifier	mxIsSparse
>354	IfStatement	if ( ! mexCheckType < T > ( prhs [ 0 ] ) )
>355	ExpressionStatement	 
>356	CallExpression	mexErrMsgTxt ( \"type of argument 1 is not consistent\" )
>357	ArgumentList	\"type of argument 1 is not consistent\"
>358	Argument	\"type of argument 1 is not consistent\"
>359	PrimaryExpression	\"type of argument 1 is not consistent\"
>360	Callee	mexErrMsgTxt
>361	Identifier	mexErrMsgTxt
>362	Condition	 
>363	RelationalExpression	! mexCheckType < T > ( prhs [ 0 ] )
>364	RelationalExpression	T > ( prhs [ 0 ] )
>365	ArrayIndexing	prhs [ 0 ]
>366	PrimaryExpression	0
>367	Identifier	prhs
>368	Identifier	T
>369	UnaryOp	! mexCheckType
>370	Identifier	mexCheckType
>371	UnaryOperator	!
>402	FunctionDef	mexFunction (int nlhs , mxArray * plhs [ ] , int nrhs , const mxArray * prhs [ ])
>403	ParameterList	int nlhs , mxArray * plhs [ ] , int nrhs , const mxArray * prhs [ ]
>404	Parameter	 
>405	Identifier	prhs
>406	ParameterType	const mxArray * [ ]
>407	Parameter	 
>408	Identifier	nrhs
>409	ParameterType	int
>410	Parameter	 
>411	Identifier	plhs
>412	ParameterType	mxArray * [ ]
>413	Parameter	 
>414	Identifier	nlhs
>415	ParameterType	int
>416	ReturnType	void
>417	CompoundStatement	 
>418	IfStatement	if ( mxGetClassID ( prhs [ 0 ] ) == mxDOUBLE_CLASS )
>419	ElseStatement	else
>420	CompoundStatement	 
>421	ExpressionStatement	 
>422	RelationalExpression	callFunction < float > ( plhs , prhs )
>423	RelationalExpression	float > ( plhs , prhs )
>424	Expression	plhs , prhs
>425	Identifier	prhs
>426	Identifier	plhs
>427	Identifier	float
>428	Identifier	callFunction
>429	CompoundStatement	 
>430	ExpressionStatement	 
>431	RelationalExpression	callFunction < double > ( plhs , prhs )
>432	RelationalExpression	double > ( plhs , prhs )
>433	Expression	plhs , prhs
>434	Identifier	prhs
>435	Identifier	plhs
>436	Identifier	double
>437	Identifier	callFunction
>438	Condition	 
>439	EqualityExpression	mxGetClassID ( prhs [ 0 ] ) == mxDOUBLE_CLASS
>440	Identifier	mxDOUBLE_CLASS
>441	CallExpression	mxGetClassID ( prhs [ 0 ] )
>442	ArgumentList	prhs [ 0 ]
>443	Argument	prhs [ 0 ]
>444	ArrayIndexing	prhs [ 0 ]
>445	PrimaryExpression	0
>446	Identifier	prhs
>447	Callee	mxGetClassID
>448	Identifier	mxGetClassID
>449	IfStatement	if ( nlhs != 1 )
>450	ExpressionStatement	 
>451	CallExpression	mexErrMsgTxt ( \"Bad number of output arguments\" )
>452	ArgumentList	\"Bad number of output arguments\"
>453	Argument	\"Bad number of output arguments\"
>454	PrimaryExpression	\"Bad number of output arguments\"
>455	Callee	mexErrMsgTxt
>456	Identifier	mexErrMsgTxt
>457	Condition	 
>458	EqualityExpression	nlhs != 1
>459	PrimaryExpression	1
>460	Identifier	nlhs
>461	IfStatement	if ( nrhs != 2 )
>462	ExpressionStatement	 
>463	CallExpression	mexErrMsgTxt ( \"Bad number of inputs arguments\" )
>464	ArgumentList	\"Bad number of inputs arguments\"
>465	Argument	\"Bad number of inputs arguments\"
>466	PrimaryExpression	\"Bad number of inputs arguments\"
>467	Callee	mexErrMsgTxt
>468	Identifier	mexErrMsgTxt
>469	Condition	 
>470	EqualityExpression	nrhs != 2
>471	PrimaryExpression	2
>472	Identifier	nrhs
<3=12,11,4
<4=8,5
<5=7,6
<8=10,9
<12=354,337,319,300,299,298,297,296,295,294,293,292,291,282,268,267,266,265,264,263,262,261,257,256,255,254,253,252,251,250,246,13,29,40,59,68,77,86,87,88,89,90,91,92,93,94,95,107,129,133,143,152,166,180,192,196,197,198,199,200,201,202,203,207,208,209,210,211,212,213,214,228,237,238,239,240,241,242,243,244,245
<13=14
<14=28,15
<15=27,16
<16=26,17
<17=25,18
<18=24,19
<19=23,20
<20=22,21
<29=30
<30=36,31
<31=34,32
<32=33
<34=35
<36=37
<37=39,38
<40=41
<41=58,57,42
<42=56,43
<43=55,44
<44=54,45
<45=53,46
<46=52,47
<47=51,48
<48=50,49
<59=60
<60=67,66,61
<61=65,62
<62=64,63
<68=69
<69=76,75,70
<70=74,71
<71=73,72
<77=78
<78=84,79
<79=80
<80=81
<81=83,82
<84=85
<95=96
<96=104,97
<97=103,98
<98=102,99
<99=101,100
<104=106,105
<107=108
<108=128,109
<109=127,110
<110=126,111
<111=125,112
<112=124,113
<113=123,114
<114=122,115
<115=121,116
<116=120,117
<117=119,118
<129=130
<130=132,131
<133=140,137,134
<134=136,135
<137=139,138
<140=142,141
<143=144
<144=151,150,145
<145=149,146
<146=148,147
<152=153
<153=165,164,154
<154=163,155
<155=161,156
<156=157
<157=158
<158=160,159
<161=162
<166=167
<167=179,178,168
<168=177,169
<169=175,170
<170=171
<171=172
<172=174,173
<175=176
<180=188,181
<181=182
<182=186,183
<183=184
<184=185
<186=187
<188=189
<189=191,190
<192=193
<193=195,194
<203=204
<204=206,205
<214=215
<215=227,226,216
<216=225,217
<217=223,218
<218=219
<219=220
<220=222,221
<223=224
<228=229
<229=235,230
<230=231
<231=232
<232=234,233
<235=236
<246=247
<247=249,248
<257=258
<258=260,259
<268=269
<269=281,280,270
<270=279,271
<271=277,272
<272=273
<273=274
<274=276,275
<277=278
<282=283
<283=289,284
<284=285
<285=286
<286=288,287
<289=290
<300=308,301
<301=302
<302=306,303
<303=304
<304=305
<306=307
<308=309
<309=318,310
<310=316,311
<311=312
<312=313
<313=315,314
<316=317
<319=327,320
<320=321
<321=325,322
<322=323
<323=324
<325=326
<327=328
<328=334,329
<329=333,330
<330=332,331
<334=336,335
<337=345,338
<338=339
<339=343,340
<340=341
<341=342
<343=344
<345=346
<346=352,347
<347=348
<348=349
<349=351,350
<352=353
<354=362,355
<355=356
<356=360,357
<357=358
<358=359
<360=361
<362=363
<363=369,364
<364=368,365
<365=367,366
<369=371,370
<402=417,416,403
<403=413,410,407,404
<404=406,405
<407=409,408
<410=412,411
<413=415,414
<417=461,449,418
<418=438,429,419
<419=420
<420=421
<421=422
<422=428,423
<423=427,424
<424=426,425
<429=430
<430=431
<431=437,432
<432=436,433
<433=435,434
<438=439
<439=441,440
<441=447,442
<442=443
<443=444
<444=446,445
<447=448
<449=457,450
<450=451
<451=455,452
<452=453
<453=454
<455=456
<457=458
<458=460,459
<461=469,462
<462=463
<463=467,464
<464=465
<465=466
<467=468
<469=470
<470=472,471
